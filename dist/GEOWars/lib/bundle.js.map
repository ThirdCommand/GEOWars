{"version":3,"file":"./GEOWars/lib/bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAA8D;AACM;AACT;AACA;AACG;AACe;AACH;AAC1E;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uEAAM;AACjC,6BAA6B,6EAAQ;AACrC,iCAAiC,oEAAK;AACtC,0BAA0B,oEAAK;AAC/B,2BAA2B,uEAAM;AACjC,gCAAgC,sFAAW;AAC3C,8BAA8B,mFAAS;AACvC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8D;AAC9D;AACsD;AAC4B;AACH;AACA;AACS;AACN;AACe;AACjG;AACA;AACA,+BAA+B,oFAAY;AAC3C,8BAA8B,iFAAW;AACzC,8BAA8B,iFAAW;AACzC,iCAAiC,0FAAc;AAC/C,+BAA+B,oFAAY;AAC3C,oCAAoC,mGAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,gEAAU;AAC3C;AACA;AACA;AACA;AACA,oCAAoC,+DAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+DAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnE8D;AAC9D;AACO,+BAA+B,gEAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACjCuD;AACM;AACC;AACE;AACjB;AAC/C;AAQiB;AACjB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uDAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAW;AACvB;AACA;AACA;AACA,YAAY,yCAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAK;AACxB;AACA;AACA;AACA,mBAAmB,mEAAI;AACvB;AACA;AACA;AACA,mBAAmB,kEAAO;AAC1B;AACA;AACA;AACA,qBAAqB,oDAAU,iBAAiB,oDAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,iBAAiB,oDAAU;AAC3B,iBAAiB,oDAAU;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA,0BAA0B,IAAI,6CAA6C;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,6DAA6D;AAC7D;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd;AAC8B;AAC9B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uCAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1DA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO,GAAG,OAAO,GAAG,OAAO;AACrD,UAAU;AACV,0BAA0B,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,OAAO;AAC/D,UAAU;AACV,0BAA0B,OAAO,GAAG,OAAO,IAAI,OAAO;AACtD,UAAU;AACV,2BAA2B,OAAO,IAAI,OAAO,KAAK,OAAO,KAAK,OAAO;AACrE;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnE4C;AAC5C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzb8B;AACE;AAChC;AACwC;AACe;AACZ;AACL;AACtC;AACO;AACP;AACA;AACA;AACA,6BAA6B,iDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gEAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjIO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACfO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1BA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/C2C;AAC3C;AACO,2BAA2B,oDAAU;AAC5C,0BAA0B;AAC1B;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;ACtHO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrHO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,mCAAmC;AACnC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACpCyD;AACX;AACyB;AAC1B;AACqB;AAC3D,qBAAqB,gEAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAK;AAChC;AACA;AACA,+BAA+B,wDAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iFAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,sCAAsC,4EAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClF2D;AAC3D;AACO,2BAA2B,gEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,+BAA+B;AAC/B,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClCA;AACA;AACiD;AACU;AAC3D;AACO,sBAAsB,gEAAU;AACvC;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClB2D;AACX;AACzC,4BAA4B,gEAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAK;AACpC;AACA,SAAS;AACT,yBAAyB,qDAAK;AAC9B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/B6C;AACc;AAC3D;AACO,oBAAoB,gEAAU;AACrC;AACA;AACA;AACA;AACA,+BAA+B,sDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACd2D;AACX;AACzC,0BAA0B,gEAAU;AAC3C;AACA;AACA;AACA;AACA,+BAA+B,qDAAK;AACpC;AACA,SAAS;AACT,yBAAyB,qDAAK;AAC9B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,iCAAiC;AACjC;AACA,8BAA8B;AAC9B;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrD8D;AACb;AACE;AACM;AACZ;AAC7C;AACO,oBAAoB,gEAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAI;AACjC;AACA,8BAA8B,qDAAK;AACnC;AACA,+BAA+B,sDAAW;AAC1C,oCAAoC,8DAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7D8D;AACvD,0BAA0B,gEAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,0CAA0C;AAC1C,2CAA2C;AAC3C,6CAA6C;AAC7C,oCAAoC;AACpC;AACA;AACA;AACA;AACA,oCAAoC;AACpC,8CAA8C;AAC9C,4CAA4C;AAC5C,2CAA2C;AAC3C,mCAAmC;AACnC;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,8CAA8C;AAC9C,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,6CAA6C;AAC7C,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChM4D;AACX;AACM;AACV;AAC7C;AACO,qBAAqB,gEAAU;AACtC;AACA;AACA,8BAA8B,qDAAK;AACnC;AACA;AACA;AACA;AACA,+BAA+B,wDAAY;AAC3C,oCAAoC,8DAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClC8D;AAC9D;AACO,2BAA2B,gEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnE4D;AACX;AACM;AACZ;AACpC,oBAAoB,gEAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAK;AACnC;AACA,+BAA+B,sDAAW;AAC1C,oCAAoC,8DAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzE4D;AACrD,0BAA0B,gEAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B,8BAA8B;AAC9B,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1DiD;AACF;AACa;AACL;AACN;AACjD;AACO,uBAAuB,gEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAI;AACjC,8BAA8B,qDAAK;AACnC;AACA,+BAA+B,4DAAc;AAC7C,oCAAoC,8DAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1C8D;AACvD,6BAA6B,gEAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,4BAA4B;AAC5B,2BAA2B;AAC3B,0BAA0B;AAC1B,2BAA2B;AAC3B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,2BAA2B;AAC3B,2BAA2B;AAC3B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvE8D;AACX;AACF;AACK;AACtD;AACO,wBAAwB,gEAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+DAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5E8D;AAC9D;AACO,8BAA8B,gEAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC1C8D;AACX;AACF;AACsB;AACa;AAC3B;AACA;AACoB;AACpC;AAClC,0BAA0B,gEAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAK;AACnC,uCAAuC,qDAAK;AAC5C,iCAAiC,qDAAK;AACtC;AACA,8BAA8B,qDAAK;AACnC;AACA;AACA;AACA,+BAA+B,kEAAiB;AAChD,oCAAoC,8DAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kFAAoB;AACxD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,kCAAkC,4EAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4EAAiB;AACnD;AACA;AACA;AACA,UAAU;AACV,kCAAkC,yFAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAI;AAC/B;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA,gBAAgB,kDAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzJA;AAC8D;AACvD,gCAAgC,gEAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtDA;AAC8D;AACX;AACF;AACQ;AACV;AAC/C;AACA;AACO,qBAAqB,gEAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAK;AACnC;AACA,+BAA+B,wDAAY;AAC3C,oCAAoC,8DAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAI;AAClC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtH8D;AAC9D;AACO,2BAA2B,gEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,0BAA0B;AAC1B,0BAA0B;AAC1B,2BAA2B;AAC3B,2BAA2B;AAC3B,oCAAoC;AACpC,mCAAmC;AACnC,kCAAkC;AAClC,mCAAmC;AACnC,oCAAoC;AACpC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClEA;AAC8D;AACrB;AACE;AACM;AAC1C,mBAAmB,gEAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B;AACA;AACA;AACA,+BAA+B,oDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sCAAsC;AACtE,oCAAoC,sCAAsC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7E4D;AAC5D;AACA;AACO,wBAAwB,gEAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvB8D;AACX;AACnD;AACO,yBAAyB,gEAAU;AAC1C;AACA;AACA;AACA;AACA,yBAAyB,qDAAK;AAC9B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACA;AACa;AAC9D;AACA;AACA;AACO,uBAAuB,gEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,6BAA6B,mDAAI;AACjC;AACA,0CAA0C;AAC1C,6BAA6B,mDAAI;AACjC,+BAA+B,4DAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1E8D;AAC9D;AACO,6BAA6B,gEAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AAC9C;AACO,kCAAkC,wDAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1CA;AACA;AAC6C;AACY;AACX;AACA;AACvC,kCAAkC,gEAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAK;AACrC;AACA,SAAS;AACT;AACA,kCAAkC,qDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9D2D;AAC3D;AACO,yBAAyB,gEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/B6C;AACY;AACX;AACA;AAC9C;AACO,gCAAgC,gEAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAK;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,mCAAmC,qDAAK;AACxC;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtD+C;AACY;AACX;AACA;AACzC,4BAA4B,gEAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAK;AACrC;AACA,SAAS;AACT;AACA,mCAAmC,qDAAK;AACxC;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxC+C;AACY;AACX;AACA;AACzC,sCAAsC,gEAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAK;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,mCAAmC,qDAAK;AACxC;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnD2D;AACb;AACoC;AAClC;AAChD;AACO,mCAAmC,gEAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAK;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2FAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9E2D;AACA;AAC3D;AACO,mBAAmB,gEAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,gEAAU;AAC1C;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxC2D;AACX;AACL;AACD;AACc;AACxD;AACO,mBAAmB,gEAAU;AACpC;AACA;AACA;AACA,mCAAmC,6DAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAU;AACzC;AACA;AACA;AACA,+BAA+B,qDAAK;AACpC,uCAAuC,qDAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAoD;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kDAAM;AACrC,+BAA+B,kDAAM;AACrC;AACA;AACA,oCAAoC,kDAAM;AAC1C;AACA;AACA;AACA,oCAAoC,kDAAM;AAC1C,oCAAoC,kDAAM;AAC1C,oCAAoC,kDAAM;AAC1C,oCAAoC,kDAAM;AAC1C;AACA;AACA;AACA;AACA,wCAAwC,kDAAM;AAC9C,wCAAwC,kDAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnX2D;AAC3D;AACO,yBAAyB,gEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,2DAA2D;AAC3D,2DAA2D;AAC3D,2DAA2D;AAC3D,iEAAiE;AACjE,kCAAkC;AAClC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9DgD;AACG;AACM;AACC;AACI;AACM;AACT;AACA;AACG;AACe;AACH;AACM;AACR;AACrB;AACnD;AAC0C;AACE;AACe;AAC3D;AACO;AACP;AACA,yBAAyB,sDAAK;AAC9B,iCAAiC,sDAAK;AACtC,kCAAkC,sDAAK;AACvC,kCAAkC,sDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC,oFAAoF;AACpF;AACA;AACA;AACA,gBAAgB,+DAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qBAAqB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kFAAa;AACjC,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,oBAAoB,0FAAiB;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uEAAM;AACvC,mCAAmC,6EAAQ;AAC3C,uCAAuC,oEAAK;AAC5C,gCAAgC,oEAAK;AACrC,iCAAiC,uEAAM;AACvC,sCAAsC,sFAAW;AACjD;AACA,oBAAoB,oFAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,OAAO;AACvC,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,OAAO;AACvC,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,6DAA6D,sCAAsC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAI;AACvB;AACA;AACA;AACA,mBAAmB,4DAAK;AACxB;AACA;AACA;AACA,mBAAmB,mEAAI;AACvB;AACA;AACA;AACA,mBAAmB,kEAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrmBO;AACP;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,YAAY;AACZ;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA,4CAA4C;AAC5C,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,8EAA8E;AAC9E,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,qEAAqE;AACrE,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCnLA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACN2C;AACJ;AACgB;AACY;AACnB;AAChD;AACA;AACA;AACA,qBAAqB,oDAAU;AAC/B,sBAAsB,oDAAU;AAChC;AACA;AACA,2BAA2B,gEAAU;AACrC;AACA,8BAA8B,yDAAa;AAC3C,QAAQ,4EAAa;AACrB;AACA;AACA,QAAQ,gDAAQ;AAChB,CAAC","sources":["webpack://GEOWars/./GEOWars/src/AnimationView.js","webpack://GEOWars/./GEOWars/src/game_engine/Levels/LevelDesign/EnemyPlacer.js","webpack://GEOWars/./GEOWars/src/game_engine/Levels/LevelDesign/PlacingAnimation.js","webpack://GEOWars/./GEOWars/src/game_engine/Levels/levelDesigner.js","webpack://GEOWars/./GEOWars/src/game_engine/Levels/scene.js","webpack://GEOWars/./GEOWars/src/game_engine/collider.js","webpack://GEOWars/./GEOWars/src/game_engine/color.js","webpack://GEOWars/./GEOWars/src/game_engine/game_engine.js","webpack://GEOWars/./GEOWars/src/game_engine/game_object.js","webpack://GEOWars/./GEOWars/src/game_engine/line_sprite.js","webpack://GEOWars/./GEOWars/src/game_engine/physics_component.js","webpack://GEOWars/./GEOWars/src/game_engine/sound.js","webpack://GEOWars/./GEOWars/src/game_engine/state_machine.js","webpack://GEOWars/./GEOWars/src/game_engine/transform.js","webpack://GEOWars/./GEOWars/src/game_engine/util.js","webpack://GEOWars/./GEOWars/src/game_objects/Bullet/bullet.js","webpack://GEOWars/./GEOWars/src/game_objects/Bullet/bullet_sprite.js","webpack://GEOWars/./GEOWars/src/game_objects/Overlay/overlay.js","webpack://GEOWars/./GEOWars/src/game_objects/Overlay/overlay_sprite.js","webpack://GEOWars/./GEOWars/src/game_objects/Walls/walls.js","webpack://GEOWars/./GEOWars/src/game_objects/Walls/walls_sprite.js","webpack://GEOWars/./GEOWars/src/game_objects/enemies/Arrow/arrow.js","webpack://GEOWars/./GEOWars/src/game_objects/enemies/Arrow/arrow_sprite.js","webpack://GEOWars/./GEOWars/src/game_objects/enemies/BoxBox/boxbox.js","webpack://GEOWars/./GEOWars/src/game_objects/enemies/BoxBox/boxbox_sprite.js","webpack://GEOWars/./GEOWars/src/game_objects/enemies/Grunt/grunt.js","webpack://GEOWars/./GEOWars/src/game_objects/enemies/Grunt/grunt_sprite.js","webpack://GEOWars/./GEOWars/src/game_objects/enemies/Pinwheel/pinwheel.js","webpack://GEOWars/./GEOWars/src/game_objects/enemies/Pinwheel/pinwheel_sprite.js","webpack://GEOWars/./GEOWars/src/game_objects/enemies/Singularity/alien_ship.js","webpack://GEOWars/./GEOWars/src/game_objects/enemies/Singularity/alien_ship_sprite.js","webpack://GEOWars/./GEOWars/src/game_objects/enemies/Singularity/singularity.js","webpack://GEOWars/./GEOWars/src/game_objects/enemies/Singularity/singularity_sprite.js","webpack://GEOWars/./GEOWars/src/game_objects/enemies/Weaver/weaver.js","webpack://GEOWars/./GEOWars/src/game_objects/enemies/Weaver/weaver_sprite.js","webpack://GEOWars/./GEOWars/src/game_objects/particles/Grid/grid.js","webpack://GEOWars/./GEOWars/src/game_objects/particles/Grid/grid_point.js","webpack://GEOWars/./GEOWars/src/game_objects/particles/Grid/grid_sprite.js","webpack://GEOWars/./GEOWars/src/game_objects/particles/Particle/particle.js","webpack://GEOWars/./GEOWars/src/game_objects/particles/Particle/particle_sprite.js","webpack://GEOWars/./GEOWars/src/game_objects/particles/Singularity_Particle/singularity_particle.js","webpack://GEOWars/./GEOWars/src/game_objects/particles/bullet_wall_explosion.js","webpack://GEOWars/./GEOWars/src/game_objects/particles/enemy_spawn.js","webpack://GEOWars/./GEOWars/src/game_objects/particles/particle_explosion.js","webpack://GEOWars/./GEOWars/src/game_objects/particles/ship_explosion.js","webpack://GEOWars/./GEOWars/src/game_objects/particles/singularity_hit_explosion.js","webpack://GEOWars/./GEOWars/src/game_objects/particles/singularity_particles.js","webpack://GEOWars/./GEOWars/src/game_objects/particles/star.js","webpack://GEOWars/./GEOWars/src/game_objects/ship/ship.js","webpack://GEOWars/./GEOWars/src/game_objects/ship/ship_sprite.js","webpack://GEOWars/./GEOWars/src/game_script.js","webpack://GEOWars/./GEOWars/src/game_view.js","webpack://GEOWars/webpack/bootstrap","webpack://GEOWars/webpack/runtime/define property getters","webpack://GEOWars/webpack/runtime/hasOwnProperty shorthand","webpack://GEOWars/webpack/runtime/make namespace object","webpack://GEOWars/./GEOWars/src/GEOWars.js"],"sourcesContent":["import { BoxBox } from \"./game_objects/enemies/BoxBox/boxbox\";\r\nimport { Pinwheel } from \"./game_objects/enemies/Pinwheel/pinwheel\";\r\nimport { Arrow } from \"./game_objects/enemies/Arrow/arrow\";\r\nimport { Grunt } from \"./game_objects/enemies/Grunt/grunt\";\r\nimport { Weaver } from \"./game_objects/enemies/Weaver/weaver\";\r\nimport { Singularity } from \"./game_objects/enemies/Singularity/singularity\";\r\nimport { AlienShip } from \"./game_objects/enemies/Singularity/alien_ship\";\r\n\r\nexport class AnimationView {\r\n  constructor(ctx) {\r\n    this.ctx = ctx;\r\n    this.gameObjects = [];\r\n    this.lineSprites = [];\r\n    this.zoomScale = 1;\r\n    this.ship = {\r\n      transform: {\r\n        pos: [],\r\n      },\r\n    };\r\n    this.lastTime = 0;\r\n    this.animate = this.animate.bind(this);\r\n  }\r\n\r\n  start() {\r\n    requestAnimationFrame(this.animate);\r\n    this.lastTime = 0;\r\n  }\r\n\r\n  animate(time) {\r\n    const timeDelta = time - this.lastTime;\r\n    this.lastTime = time;\r\n    this.animateGameObjects(timeDelta);\r\n    this.clearCanvas();\r\n    this.renderLineSprites(this.ctx);\r\n    // every call to animate requests causes another call to animate\r\n    requestAnimationFrame(this.animate.bind(this));\r\n  }\r\n\r\n  animateGameObjects(delta) {\r\n    this.gameObjects.forEach((object) => {\r\n      object.animate(delta);\r\n    });\r\n  }\r\n\r\n  clearCanvas() {\r\n    this.ctx.clearRect(0, 0, 200, 200);\r\n    this.ctx.fillStyle = \"#000000\";\r\n    this.ctx.fillRect(0, 0, 200, 200);\r\n  }\r\n\r\n  clear() {\r\n    const removeList = [...this.gameObjects];\r\n    removeList.forEach((gameObject) => {\r\n      this.remove(gameObject);\r\n    });\r\n  }\r\n\r\n  renderLineSprites(ctx) {\r\n    // ctx.scale = gameEngine.currentCamera.zoomScale\r\n    this.ctx.save();\r\n\r\n    this.ctx.scale(this.zoomScale, this.zoomScale);\r\n    this.lineSprites.forEach((sprite) => {\r\n      sprite.draw(ctx);\r\n    });\r\n    this.ctx.restore();\r\n    // ctx.scale(1,1)\r\n  }\r\n\r\n  addGameObject(gameObject) {\r\n    this.gameObjects.push(gameObject);\r\n  }\r\n\r\n  queueSound(sound) {}\r\n\r\n  addCollider() {}\r\n\r\n  addPhysicsComponent(physicsComponent) {}\r\n\r\n  remove(gameObject) {\r\n    if (gameObject.lineSprite) {\r\n      this.lineSprites.splice(\r\n        this.lineSprites.indexOf(gameObject.lineSprite),\r\n        1\r\n      );\r\n    }\r\n\r\n    this.gameObjects.splice(this.gameObjects.indexOf(gameObject), 1);\r\n  }\r\n\r\n  addLineSprite(lineSprite) {\r\n    this.lineSprites.push(lineSprite);\r\n  }\r\n\r\n  addEnemy(type) {\r\n    const enemyMap = {\r\n      BoxBox: (pos) => new BoxBox(this, pos),\r\n      Pinwheel: (pos) => new Pinwheel(this, pos),\r\n      Arrow: (pos, angle) => new Arrow(this, pos, angle),\r\n      Grunt: (pos) => new Grunt(this, pos, this.ship.transform),\r\n      Weaver: (pos) => new Weaver(this, pos, this.ship.transform),\r\n      Singularity: (pos) => new Singularity(this, pos),\r\n      AlienShip: (pos) => new AlienShip(this, pos, [0, 0], this.ship.transform),\r\n    };\r\n    enemyMap[type]([100, 100]);\r\n  }\r\n}\r\n","// while placing, could do spawning animation over mouse position\r\n// once placed, draw it at the placed location\r\n// store the location\r\n\r\n// maybe I need a nested canvas for the pallet\r\n\r\n// load spawn event\r\n// save spawn event\r\n// create spawn event\r\nimport { GameObject } from \"../../../game_engine/game_object\";\r\n\r\nimport { PlacingAnimation } from \"./PlacingAnimation\";\r\nimport { BoxBoxSprite } from \"../../../game_objects/enemies/BoxBox/boxbox_sprite\";\r\nimport { ArrowSprite } from \"../../../game_objects/enemies/Arrow/arrow_sprite\";\r\nimport { GruntSprite } from \"../../../game_objects/enemies/Grunt/grunt_sprite\";\r\nimport { PinwheelSprite } from \"../../../game_objects/enemies/Pinwheel/pinwheel_sprite\";\r\nimport { WeaverSprite } from \"../../../game_objects/enemies/Weaver/weaver_sprite\";\r\nimport { SingularitySprite } from \"../../../game_objects/enemies/Singularity/singularity_sprite\";\r\n\r\nconst spriteMap = {\r\n    BoxBox: (transform) => new BoxBoxSprite(transform),\r\n    Arrow: (transform) => new ArrowSprite(transform),\r\n    Grunt: (transform) => new GruntSprite(transform),\r\n    Pinwheel: (transform) => new PinwheelSprite(transform),\r\n    Weaver: (transform) => new WeaverSprite(transform),\r\n    Singularity: (transform) => new SingularitySprite(transform),\r\n};\r\n\r\n// if trying to spawn multiple things on top of each other, I should only grab the first placer that is found in the click colission\r\nconst getClickRadius = {\r\n    BoxBox: 10,\r\n    Arrow: 10,\r\n    Grunt: 10,\r\n    Pinwheel: 10,\r\n    Weaver: 10,\r\n    Singularity: 10,\r\n};\r\n\r\nexport class EnemyPlacer extends GameObject {\r\n    constructor(engine, type, levelDesigner) {\r\n        super(engine);\r\n        this.addLineSprite(spriteMap[type](this.transform));\r\n        this.addMousePosListener();\r\n        this.addChildGameObject(new PlacingAnimation(this.gameEngine));\r\n        this.levelDesigner = levelDesigner;\r\n        this.clickRadius = getClickRadius[type];\r\n        this.type = type;\r\n    // collider should be added after placed\r\n    }\r\n\r\n    place() {\r\n        this.addCollider(\"General\", this, this.clickRadius);\r\n        const spawn = { type: this.type, location: this.transform.pos };\r\n        this.levelDesigner.addSpawnToEvent();\r\n        this.removeMousePosListener();\r\n    }\r\n\r\n    followMouse() {\r\n        this.addMousePosListener();\r\n        this.addChildGameObject(new PlacingAnimation(this.gameEngine));\r\n    }\r\n\r\n    updateMousePos(mousePos) {\r\n        this.transform.pos[0] = mousePos[0];\r\n        this.transform.pos[1] = mousePos[1];\r\n    }\r\n}\r\n\r\n","import { GameObject } from \"../../../game_engine/game_object\";\r\n\r\nexport class PlacingAnimation extends GameObject {\r\n    constructor(engine) {\r\n        super(engine);\r\n        this.initialSpawningScale = 1.5;\r\n        this.cycleSpeed = 0.1;\r\n        this.addClickListener();\r\n    }\r\n\r\n    // Mouse handling should call this I think?\r\n    placeEnemy() {\r\n        this.parentObject.place();\r\n        this.parentObject.lineSprite.spawningScale = 1;\r\n        this.removeClickListener();\r\n        this.remove();\r\n    }\r\n\r\n    mouseClicked(mousePos) {\r\n        this.placeEnemy();\r\n    }\r\n\r\n    update(timeDelta) {\r\n        const cycleSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\r\n\r\n        if (this.parentObject.lineSprite.spawningScale < 0.7) {\r\n            this.parentObject.lineSprite.spawningScale = this.initialSpawningScale;\r\n        } else {\r\n            this.parentObject.lineSprite.spawningScale -=\r\n        this.cycleSpeed * cycleSpeedScale;\r\n        }\r\n    }\r\n}\r\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\r\n","import { Walls } from \"../../game_objects/Walls/walls\";\r\nimport { Overlay } from \"../../game_objects/Overlay/overlay\";\r\nimport { Grid } from \"../../game_objects/particles/Grid/grid\";\r\nimport { EnemyPlacer } from \"../Levels/LevelDesign/EnemyPlacer\";\r\nimport { GameScript } from \"../../game_script\";\r\n\r\nimport {\r\n    Spawn,\r\n    GameSequence,\r\n    GameSequenceDisplay,\r\n    Event,\r\n    Operation,\r\n    Scene,\r\n} from \"./scene\";\r\n\r\n// I should collect palced enemies\r\n\r\nexport class LevelDesigner {\r\n    constructor(engine, animationView) {\r\n        this.DIM_X = 1000;\r\n        this.DIM_Y = 600;\r\n        this.BG_COLOR = \"#000000\";\r\n        this.engine = engine;\r\n        this.animationView = animationView;\r\n        // this.walls = this.createWalls();\r\n        // this.grid = this.createGrid();\r\n        this.palletModal = this.getPalletModal();\r\n        this.gameEditorOpened = false;\r\n\r\n        const addArrowButton = document.getElementById(\"Arrow\");\r\n        const addBoxBox = document.getElementById(\"BoxBox\");\r\n        const addPinwheel = document.getElementById(\"Pinwheel\");\r\n        const addWeaver = document.getElementById(\"Weaver\");\r\n        const addSingularity = document.getElementById(\"Singularity\");\r\n        const makeGame = document.getElementById(\"LevelEditor\");\r\n        this.gameSequenceDisplay = new GameSequenceDisplay();\r\n\r\n        addArrowButton.onclick = (e) => {\r\n            e.stopPropagation();\r\n            const type = \"Arrow\";\r\n            this.addEnemy(type);\r\n            this.animationView.clear();\r\n            this.animationView.addEnemy(type);\r\n        };\r\n        addBoxBox.onclick = (e) => {\r\n            e.stopPropagation();\r\n            const type = \"BoxBox\";\r\n            this.addEnemy(type);\r\n            this.animationView.clear();\r\n            this.animationView.addEnemy(type);\r\n        };\r\n        addPinwheel.onclick = (e) => {\r\n            e.stopPropagation();\r\n            const type = \"Pinwheel\";\r\n            this.addEnemy(type);\r\n            this.animationView.clear();\r\n            this.animationView.addEnemy(type);\r\n        };\r\n        addWeaver.onclick = (e) => {\r\n            e.stopPropagation();\r\n            const type = \"Weaver\";\r\n            this.addEnemy(type);\r\n            this.animationView.clear();\r\n            this.animationView.addEnemy(type);\r\n        };\r\n        addSingularity.onclick = (e) => {\r\n            e.stopPropagation();\r\n            const type = \"Singularity\";\r\n            this.addEnemy(type);\r\n            this.animationView.clear();\r\n            this.animationView.addEnemy(type);\r\n        };\r\n        makeGame.onclick = (e) => {\r\n            e.stopPropagation();\r\n            console.log(\"game editor opened clicked\");\r\n            this.gameEditorOpened = !this.gameEditorOpened;\r\n            this.engine.gameEditorOpened = this.gameEditorOpened;\r\n            // change text to save or something. accidental click seems bad though\r\n        };\r\n\r\n        console.log({\r\n            addSingularity,\r\n            makeGame,\r\n        });\r\n    }\r\n\r\n    levelDesigner(time) {\r\n        const timeDelta = time - this.lastTime;\r\n        this.engine;\r\n    }\r\n\r\n    getPalletModal() {\r\n        const modal = document.getElementById(\"pallet\");\r\n\r\n    // add functions to buttons of the pallet\r\n    }\r\n\r\n    addEnemy(type) {\r\n        new EnemyPlacer(this.engine, type, this);\r\n    }\r\n\r\n    addSpawnToEvent(spawn) {\r\n        new Spawn(this.engine, spawn);\r\n    }\r\n\r\n    addNewEvent() {}\r\n\r\n    update(deltaTime) {}\r\n\r\n    createWalls() {\r\n        return new Walls(this.engine, this);\r\n    }\r\n\r\n    createGrid() {\r\n        return new Grid(this.engine, this);\r\n    }\r\n\r\n    createOverlay() {\r\n        return new Overlay(this.engine, this, this.ship.transform);\r\n    }\r\n\r\n    isOutOfBounds(pos, radius) {\r\n        const max = [GameScript.DIM_X - radius, GameScript.DIM_Y - radius];\r\n        if (radius) {\r\n            return (\r\n                pos[0] <= radius ||\r\n        pos[0] >= max[0] ||\r\n        pos[1] <= radius ||\r\n        pos[1] >= max[1]\r\n            );\r\n        } else {\r\n            return (\r\n                pos[0] < 0 ||\r\n        pos[1] < 0 ||\r\n        pos[0] > GameScript.DIM_X ||\r\n        pos[1] > GameScript.DIM_Y\r\n            );\r\n        }\r\n    }\r\n}\r\n","const DIM_X = 1000;\r\nconst DIM_Y = 600;\r\nconst game = {\r\n    flatOES: [\r\n        {\r\n            name: 'LevelOne-Start',\r\n            __typename: 'Scene'\r\n        },\r\n        {\r\n            name: 'EasySpawns-Start',\r\n            __typename: 'Scene'\r\n        },\r\n        {\r\n            spawns: [\r\n                {\r\n                    type: 'RANDOM', // if random, then possibleTypes exists\r\n                    location: 'RANDOM', \r\n                    possibleTypes: ['BoxBox','Pinwheel','Arrow'], \r\n                    numberToGenerate: 10, // if there's a location it will be 1\r\n                    angle: undefined // for arrows\r\n                }\r\n            ],\r\n            __typename: 'Event'\r\n        },\r\n        {\r\n            type: 'WAIT',\r\n            time: 0,\r\n            waitTime: 10,\r\n            __typename: 'Operation'\r\n        },\r\n        {\r\n            name: 'EasySpawns-End',\r\n            __typename: 'Scene'\r\n        },\r\n        {\r\n            type: 'LOOP',\r\n            loop: {\r\n                loopIdx: 0,\r\n                sequenceIndexToLoopTo: 0,\r\n                repeatTimes: 5\r\n            },\r\n            __typename: 'Operation'\r\n        },\r\n        {\r\n            name: 'LevelOne-End',\r\n            __typename: 'Scene'\r\n        }\r\n    ]\r\n};\r\n\r\nexport class GameSequenceDisplay {\r\n    constructor(engine) {\r\n        this.engine = engine;\r\n        this.displaySequence = [];\r\n    }\r\n    \r\n\r\n}\r\n\r\nexport class GameSequence{\r\n    constructor (engine, flatOES) {\r\n        this.engine = engine;\r\n        this.sequenceIdx = 0;\r\n        this.flatOES = engine.flatOES;\r\n    }\r\n\r\n    loadGame() {\r\n\r\n    }\r\n    update(dT) {\r\n        flatOES[sequenceIdx].update(dT);\r\n    }\r\n\r\n    nextSequence(i=1) {\r\n        if(typeOf(flatOES[this.sequenceIdx + i]) === 'Scene') { // TODO fix class name\r\n            this.nextSequence(++i);\r\n        }\r\n        this.sequenceIdx += i;\r\n    }\r\n\r\n    serialize() {\r\n\r\n    }\r\n}\r\n\r\nexport class Scene {\r\n    constructor(gameSequence, name) {\r\n        this.name = name;\r\n    }\r\n}\r\n\r\n// loop, wait, \r\nexport class Operation {\r\n    constructor(gameSequence, {type,waitTime,loop}) {\r\n        this.gameSequence = gameSequence;\r\n        this.type = type;\r\n        this.waitTime = waitTime;\r\n        this.time = 0;\r\n        this.loop = loop; // {loopIdx, sequenceIndexToLoopTo, repeatTimes} // \r\n        this.startingValues = {\r\n            type: type,\r\n            time: 0,\r\n            waitTime: waitTime,\r\n            loop: {\r\n                loopIdx: loop.loopIdx,\r\n                sequenceIndexToLoopTo: sequenceIndexToLoopTo,\r\n                repeatTimes: repeatTimes\r\n            }\r\n        };\r\n    }\r\n\r\n    update(dT) {\r\n        if(this.type === \"WAIT\") {\r\n            this.time += dT;\r\n            if(this.time >= this.waitTime) {\r\n                endOperation();\r\n            }\r\n        } else if (this.type === \"LOOP\") {\r\n            if(this.loop.loopIdx >= this.loop.repeatTimes) { // 3: 0, 1, 2\r\n                endOperation();\r\n            } else {\r\n                gameSequence.sequenceIndex = this.loop.sequenceIndexToLoopTo;\r\n                \r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    resetStartingValues() {\r\n        this.type = this.startingValues.type;\r\n        this.time = 0,\r\n        this.waitTime = this.startingValues.waitTime,\r\n        this.loop =  {\r\n            loopIdx: this.startingValues.loop.loopIdx,\r\n            sequenceIndexToLoopTo: this.startingValues.sequenceIndexToLoopTo,\r\n            repeatTimes: this.startingValues.repeatTimes\r\n        };\r\n    }\r\n\r\n    endOperation() {\r\n        this.resetStartingValues();\r\n        this.gameSequence.nextSequence();\r\n    }\r\n}\r\n\r\n\r\nexport class Event {\r\n    constructor(gameSequence, spawns) {\r\n        this.gameSequence = gameSequence;\r\n        this.spawns = spawns; // this is different than the single spawn thing I have in the mock data\r\n    }\r\n\r\n    update(dT) {\r\n        spawnEverything();\r\n        endEvent();\r\n    }\r\n\r\n    spawnEverything() {\r\n        this.spawns.forEach((spawn) => {\r\n            spawn.spawnEvent();\r\n        });\r\n    }\r\n    endEvent() {\r\n        this.gameSequence.nextSequence();\r\n    }\r\n}\r\n\r\n// a single enemy, and location\r\nexport class Spawn { \r\n    constructor(gameEngine, spawn) { // spawn: {type, location: [x,y]} \r\n        this.spawn = spawn;\r\n        this.gameEngine = gameEngine;\r\n    }\r\n\r\n    randomPosition() {\r\n        return [\r\n            this.DIM_X * 0.70 * Math.random(),\r\n            this.DIM_Y * 0.70 * Math.random(),\r\n            // 500,300\r\n        ];\r\n    }\r\n\r\n    randomMob(possibleSpawns) {\r\n        return possibleSpawns[Math.floor(Math.random() * possibleSpawns.length) % possibleSpawns.length];\r\n    }\r\n\r\n    spawnEvent() {\r\n        for(let i = 0; i < this.spawn.numberToGenerate; i++) {\r\n            let mobToSpawn = this.spawn.type;\r\n            let location = this.spawn.location;\r\n            if(this.spawn.type === 'RANDOM') {\r\n                mobToSpawn = randomMob(this.spawn.possibleSpawns);\r\n            } \r\n            if(this.spawn.location === 'RANDOM') {\r\n                location = randomPosition();\r\n            }\r\n            this.gameEngine.enemyCreatorList[mobToSpawn](location);\r\n        }\r\n    }\r\n\r\n    serialize() {\r\n\r\n    }\r\n}\r\n\r\n\r\n\r\n// MOB randomly picked from chosen list\r\n// location randomly picked","// engine takes in collider with gameobject type as string\r\n// this way subscriptions can be done via string names\r\n// enemy is subscribed to bullets..\r\n// each enemy will check every bullet\r\n// convert gameobject type to string\r\n// colliders can be added without subscriptions\r\n// subscriptions are an array of strings stored with the collider\r\n\r\n// collider: object absolute transform\r\n// collider { gameObject gameObject, \"subscriptions\" [\"name\", \"name\"] }\r\n// colliders {\"BoxBox\" [collider, collider]}\r\n\r\nimport { Util } from \"./util\";\r\n\r\nexport class Collider {\r\n    constructor(\r\n        type,\r\n        gameObject,\r\n        radius = 5,\r\n        subscriptions,\r\n        subscribedColliderTypes\r\n    ) {\r\n        this.objectType = gameObject.constructor.name;\r\n        this.type = type;\r\n        this.subscriptions = subscriptions;\r\n        this.subscribedColliderTypes = subscribedColliderTypes;\r\n        this.radius = radius;\r\n        this.gameObject = gameObject;\r\n    }\r\n    // wondering if collision should cascade up the parent objects\r\n    // nope not yet anyway\r\n\r\n    collisionCheck(otherCollider) {\r\n        const centerDist = Util.dist(\r\n            this.gameObject.transform.pos,\r\n            otherCollider.gameObject.transform.pos\r\n        );\r\n        if (centerDist < this.radius + otherCollider.radius) {\r\n            this.gameObject.onCollision(otherCollider, this.type);\r\n        }\r\n    }\r\n}\r\n\r\n// on\r\n\r\n// When you add new things that effect other things\r\n// like a new type of bullet, singularity effect, etc\r\n// you just have to add that functionality to the bullet\r\n// add the things it effects as things\r\n// the collider subscribes to\r\n// this way you don't have to edit every object type\r\n// that is effected\r\n\r\n// singularity has two colliders\r\n// outer one for gravity effects\r\n// inner one for actual hits\r\n// it's subscribed to everything\r\n// on collision it changes that object properties either\r\n// directly or with a object method... preferably\r\n","\r\nexport class Color {\r\n    constructor(colorSpec){\r\n        this.colorType = Object.keys(colorSpec)[0];\r\n        this.creationErrorCheck(colorSpec);\r\n        this.extractColorInfo(colorSpec);\r\n    }\r\n\r\n    creationErrorCheck(colorSpec){\r\n        if (Object.keys(colorSpec).length !== 1) {\r\n            new Error(\"Color object accepts one color type\");\r\n        }\r\n        if (!Color.COLOR_TYPES.includes(this.colorType)) {\r\n            new Error(\"Color Object given unsupported color type\");\r\n        }\r\n    }\r\n\r\n    dup(){\r\n        const dupSpec = {};\r\n        if (this.colorType === \"rgb\") {\r\n            dupSpec[\"rgb\"]  = [this.r, this.g, this.b];\r\n        } else if (this.colorType === \"rgba\") {\r\n            dupSpec[\"rgba\"] = [this.r, this.g, this.b, this.a];\r\n        } else if (this.colorType === \"hsl\") {\r\n            dupSpec[\"hsl\"]  = [this.h, this.s, this.l];\r\n        } else if (this.colorType === \"hsla\") {\r\n            dupSpec[\"hsla\"] = [this.h, this.s, this.l, this.a];\r\n        }\r\n        const newColor = new Color(dupSpec);\r\n        return newColor;\r\n    }\r\n\r\n    extractColorInfo(colorSpec){\r\n        if (this.colorType === \"rgb\"){\r\n            this.r = colorSpec[this.colorType][0];\r\n            this.g = colorSpec[this.colorType][1];\r\n            this.b = colorSpec[this.colorType][2];\r\n        } else if (this.colorType === \"rgba\"){\r\n            this.r = colorSpec[this.colorType][0];\r\n            this.g = colorSpec[this.colorType][1];\r\n            this.b = colorSpec[this.colorType][2];\r\n            this.a = colorSpec[this.colorType][3];\r\n        } else if (this.colorType === \"hsl\"){\r\n            this.h = colorSpec[this.colorType][0];\r\n            this.s = colorSpec[this.colorType][1];\r\n            this.l = colorSpec[this.colorType][2];\r\n        } else if (this.colorType === \"hsla\"){\r\n            this.h = colorSpec[this.colorType][0];\r\n            this.s = colorSpec[this.colorType][1];\r\n            this.l = colorSpec[this.colorType][2];\r\n            this.a = colorSpec[this.colorType][3];\r\n        } \r\n        colorSpec[this.colorType];\r\n    }\r\n\r\n    evaluateColor(){\r\n        if (this.colorType === \"rgb\"){\r\n            return `rbg(${this.r},${this.g},${this.b},)`;\r\n        } else if (this.colorType === \"rgba\"){\r\n            return `rbg(${this.r},${this.g},${this.b},${this.a})`;\r\n        } else if (this.colorType === \"hsl\"){\r\n            return `hsl(${this.h},${this.s}%,${this.l}%`;\r\n        } else if (this.colorType === \"hsla\") {\r\n            return `hsla(${this.h}, ${this.s}%, ${this.l}%, ${this.a}`;\r\n        }\r\n    }\r\n}\r\nColor.COLOR_TYPES = [\"rgb\", \"rgba\", \"hsl\", \"hsla\"];","import { GameScript } from \"../game_script\";\r\n\r\nexport class GameEngine {\r\n    constructor(ctx) {\r\n        this.ctx = ctx;\r\n        this.gameObjects = [];\r\n        this.physicsComponents = [];\r\n        this.lineSprites = [];\r\n        this.soundsToPlay = {};\r\n        this.colliders = {};\r\n        this.subscribers = [];\r\n        this.muted = true;\r\n        this.mouseListeners = [];\r\n        this.clickListeners = [];\r\n        this.leftControlStickListeners = [];\r\n        this.rightControlStickListeners = [];\r\n        this.xButtonListeners = [];\r\n        this.startButtonListeners = [];\r\n        this.gameScript = new GameScript(this);\r\n        this.toRemoveQueue = [];\r\n        this.paused = false;\r\n        this.currentCamera = null;\r\n        this.defaultZoomScale = 1.3;\r\n        this.zoomScale = 1.3;\r\n        this.graphicQuality = 1;\r\n        this.setupController();\r\n        this.setupPerformance();\r\n        window.engine = this;\r\n        this.gameEditorOpened = false;\r\n    }\r\n\r\n    setupPerformance() {\r\n        this.collisionTime = 0;\r\n        this.physicsCalcTime = 0;\r\n        this.updateTime = 0;\r\n        this.renderTime = 0;\r\n        this.scriptTime = 0;\r\n        this.timePassed = 0;\r\n    }\r\n\r\n    setupController() {\r\n        window.addEventListener(\"gamepadconnected\", function (e) {\r\n            window.controller = e.gamepad;\r\n            window.engine.controller = e.gamepad;\r\n            // Gamepad connected\r\n            console.log(\"Gamepad connected\", e.gamepad);\r\n        });\r\n\r\n        window.addEventListener(\"gamepaddisconnected\", function (e) {\r\n            // Gamepad disconnected\r\n            window.engine.controller = null;\r\n            console.log(\"Gamepad disconnected\", e.gamepad);\r\n        });\r\n    }\r\n\r\n    updateGraphicSetting(delta) {\r\n        if (delta > 50) {\r\n            // console.log(\"worst\")\r\n            this.graphicQuality = 3;\r\n        } else if (delta > 25) {\r\n            this.graphicQuality = 2;\r\n        } else {\r\n            this.graphicQuality = 1;\r\n        }\r\n    }\r\n\r\n    tick(delta) {\r\n    // debugger\r\n        this.updateGraphicSetting(delta);\r\n        if (this.paused) {\r\n            this.updateControlListeners();\r\n            return;\r\n        }\r\n        // console.log(delta)\r\n        // if(delta > 125){\r\n        //   delta = 125\r\n        // }\r\n        const beforeCollisionTime = performance.now();\r\n        this.checkCollisions();\r\n        const beforePhysicsCalcs = performance.now();\r\n        const collisionTime = beforeCollisionTime - beforePhysicsCalcs;\r\n        this.movePhysicsComponents(delta);\r\n        const beforeUpdate = performance.now();\r\n        const physicsCalcTime = beforePhysicsCalcs - beforeUpdate;\r\n        this.updateGameObjects(delta);\r\n        const beforeRender = performance.now();\r\n        const updateTime = beforeUpdate - beforeRender;\r\n        this.clearCanvas();\r\n        this.renderLineSprites(this.ctx);\r\n        const beforeScriptUpdate = performance.now();\r\n        const renderTime = beforeRender - beforeScriptUpdate;\r\n        this.updateControlListeners();\r\n        if (!this.gameEditorOpened) {\r\n            this.updateGameScript(delta);\r\n        }\r\n        const scriptTime = beforeScriptUpdate - performance.now();\r\n        this.playSounds();\r\n\r\n        this.collectPerformanceData(\r\n            delta,\r\n            collisionTime,\r\n            physicsCalcTime,\r\n            updateTime,\r\n            renderTime,\r\n            scriptTime\r\n        );\r\n    }\r\n\r\n    collectPerformanceData(\r\n        delta,\r\n        collisionTime,\r\n        physicsCalcTime,\r\n        updateTime,\r\n        renderTime,\r\n        scriptTime\r\n    ) {\r\n        this.collisionTime += collisionTime;\r\n        this.physicsCalcTime += physicsCalcTime;\r\n        this.updateTime += updateTime;\r\n        this.renderTime += renderTime;\r\n        this.scriptTime += scriptTime;\r\n\r\n        this.timePassed += delta;\r\n        if (this.timePassed > 1000 * 60) {\r\n            const totalTime =\r\n        this.collisionTime +\r\n        this.physicsCalcTime +\r\n        this.updateTime +\r\n        this.renderTime +\r\n        this.scriptTime;\r\n            const timeData = {\r\n                collisionTime: (100 * this.collisionTime) / totalTime,\r\n                physicsCalcTime: (100 * this.physicsCalcTime) / totalTime,\r\n                updateTime: (100 * this.updateTime) / totalTime,\r\n                renderTime: (100 * this.renderTime) / totalTime,\r\n                scriptTime: (100 * this.scriptTime) / totalTime,\r\n            };\r\n            console.log(timeData);\r\n\r\n            this.setupPerformance();\r\n        }\r\n    }\r\n\r\n    pause() {\r\n        this.paused = true;\r\n        this.gameScript.onPause();\r\n    }\r\n\r\n    unPause() {\r\n        this.paused = false;\r\n        this.gameScript.onUnPause();\r\n    }\r\n\r\n    togglePause() {\r\n    // console.log(\"pausetoggle\")\r\n        this.paused ? this.unPause() : this.pause();\r\n    }\r\n\r\n    clearCanvas() {\r\n        this.ctx.clearRect(\r\n            -this.gameScript.DIM_X,\r\n            -this.gameScript.DIM_Y,\r\n            this.gameScript.DIM_X * this.zoomScale * 4,\r\n            this.gameScript.DIM_Y * this.zoomScale * 4\r\n        );\r\n        this.ctx.fillStyle = this.gameScript.BG_COLOR;\r\n        this.ctx.fillRect(\r\n            -this.gameScript.DIM_X,\r\n            -this.gameScript.DIM_Y,\r\n            this.gameScript.DIM_X * this.zoomScale * 4,\r\n            this.gameScript.DIM_Y * this.zoomScale * 4\r\n        );\r\n    }\r\n\r\n    addLeftControlStickListener(object) {\r\n        this.leftControlStickListeners.push(object);\r\n    }\r\n\r\n    addRightControlStickListener(object) {\r\n        this.rightControlStickListeners.push(object);\r\n    }\r\n\r\n    addxButtonListener(object) {\r\n        this.xButtonListeners.push(object);\r\n    }\r\n\r\n    addStartButtonListener(object) {\r\n        this.startButtonListeners.push(object);\r\n    }\r\n\r\n    addClickListener(object) {\r\n        this.clickListeners.push(object);\r\n    }\r\n\r\n    mouseClicked(position) {\r\n        this.clickListeners.forEach((object) => {\r\n            object.mouseClicked(position);\r\n        });\r\n    }\r\n\r\n    removeClickListener(object) {\r\n        this.clickListeners.splice(this.clickListeners.indexOf(object), 1);\r\n    }\r\n\r\n    updateLeftControlStickListeners(unitVector) {\r\n        this.leftControlStickListeners.forEach((listener) => {\r\n            listener.updateLeftControlStickInput(unitVector);\r\n        });\r\n    }\r\n\r\n    updateRightControlStickListeners(unitVector) {\r\n        this.rightControlStickListeners.forEach((listener) => {\r\n            listener.updateRightControlStickInput(unitVector);\r\n        });\r\n    }\r\n\r\n    updatexButtonListeners(xButton) {\r\n        this.xButtonListeners.forEach((listener) => {\r\n            listener.updatexButtonListener(xButton);\r\n        });\r\n    }\r\n\r\n    updateStartButtonListeners(startButton, down) {\r\n    // console.log([startButton, down])\r\n        this.startButtonListeners.forEach((listener) => {\r\n            listener.updateStartButtonListener(startButton, down);\r\n        });\r\n    }\r\n\r\n    updateMousePos(mousePos) {\r\n        this.mouseListeners.forEach((object) => {\r\n            object.updateMousePos(mousePos);\r\n        });\r\n    }\r\n\r\n    removeMouseListener(object) {\r\n        this.mouseListeners.splice(this.mouseListeners.indexOf(object), 1);\r\n    }\r\n\r\n    updateControlListeners() {\r\n        navigator.getGamepads();\r\n        if (this.controller) {\r\n            const leftAxis = [window.controller.axes[0], window.controller.axes[1]];\r\n            const rightAxis = [window.controller.axes[2], window.controller.axes[3]];\r\n            const xButton = [window.controller.buttons[0].pressed];\r\n            const startButton = [window.controller.buttons[9].pressed];\r\n            this.updatexButtonListeners(xButton);\r\n            this.updateLeftControlStickListeners(leftAxis);\r\n            this.updateRightControlStickListeners(rightAxis);\r\n            this.updateStartButtonListeners(startButton);\r\n        }\r\n    }\r\n\r\n    movePhysicsComponents(delta) {\r\n        this.physicsComponents.forEach((component) => {\r\n            component.move(delta);\r\n        });\r\n    }\r\n\r\n    addCollider(collider) {\r\n        if (collider.subscriptions) {\r\n            this.subscribers.push(collider);\r\n        }\r\n        const colliders = this.colliders;\r\n        // collider: object absolute transform\r\n        // collider {\"objectType\": \"Bullet\", \"type\": \"general\", \"subscriptions\": [\"BoxBox\", \"Arrow\"], \"subscribedColliderTypes\": [\"General\"]}\r\n        // colliders {\"Singularity\": {\"General\": [collider, collider], \"GravityWell\": [collider, collider]}}\r\n        if (!colliders[collider.objectType]) {\r\n            const collidersSameTypeAndObject = {};\r\n            collidersSameTypeAndObject[collider.type] = [collider];\r\n            colliders[collider.objectType] = collidersSameTypeAndObject;\r\n        } else {\r\n            if (!colliders[collider.objectType][collider.type]) {\r\n                colliders[collider.objectType][collider.type] = [collider];\r\n            } else {\r\n                colliders[collider.objectType][collider.type].push(collider);\r\n            }\r\n        }\r\n    }\r\n\r\n    // must be a way to only retrieve\r\n    // the data for subscribed colliders once\r\n\r\n    checkCollisions() {\r\n    // colliders{\r\n    // \"Arrow\": [collider, collider]\r\n    // }\r\n\r\n        // collider {\r\n        //   \"objectType\": \"Bullet\",\r\n        //   \"type\": \"general\",\r\n        //   \"subscriptions\": [\"BoxBox\", \"Arrow\"],\r\n        //   \"subscribedColliderTypes\": [\"general\"]\r\n        // }\r\n        const subscribers = this.subscribers;\r\n        const colliders = this.colliders;\r\n        this.stillCanDie = false;\r\n        // console.log(this.subscribers)\r\n        subscribers.forEach((subscriber) => {\r\n            if (subscriber.type === \"ShipDeath\") {\r\n                this.stillCanDie = true;\r\n                // console.log(\"CAN DIE\")\r\n            }\r\n            subscriber.subscriptions.forEach((subscription) => {\r\n                colliders[subscription] = colliders[subscription] || {};\r\n                subscriber.subscribedColliderTypes.forEach((colliderType) => {\r\n                    colliders[subscription][colliderType] =\r\n            colliders[subscription][colliderType] || [];\r\n                    colliders[subscription][colliderType].forEach(\r\n                        (subscribedCollider) => {\r\n                            subscriber.collisionCheck(subscribedCollider);\r\n                        }\r\n                    );\r\n                });\r\n            });\r\n        });\r\n        if (!this.stillCanDie) {\r\n            // console.log(this.gameScript.ship.collider)\r\n            this.gameScript.ship.addCollider(\r\n                \"General\",\r\n                this.gameScript.ship,\r\n                this.gameScript.ship.radius\r\n            );\r\n            this.gameScript.ship.addCollider(\r\n                \"ShipDeath\",\r\n                this.gameScript.ship,\r\n                this.gameScript.ship.radius,\r\n                [\"BoxBox\", \"Singularity\", \"Weaver\", \"Grunt\", \"Arrow\", \"Pinwheel\"],\r\n                [\"General\"]\r\n            );\r\n        }\r\n    }\r\n\r\n    updateGameObjects(delta) {\r\n        this.gameObjects.forEach((object) => {\r\n            object.update(delta);\r\n        });\r\n    }\r\n\r\n    toggleMute() {\r\n        this.muted = !this.muted;\r\n    }\r\n\r\n    playSounds() {\r\n        Object.values(this.soundsToPlay).forEach((sound) => {\r\n            sound.play();\r\n        });\r\n        this.soundsToPlay = {};\r\n    }\r\n\r\n    renderLineSprites(ctx) {\r\n        // ctx.scale = gameEngine.currentCamera.zoomScale\r\n        this.ctx.save();\r\n\r\n        // this belongs in the camera #camera\r\n        this.ctx.scale(this.zoomScale, this.zoomScale);\r\n        this.lineSprites.forEach((sprite) => {\r\n            sprite.draw(ctx);\r\n        });\r\n        this.ctx.restore();\r\n    // ctx.scale(1,1)\r\n    }\r\n\r\n    addMouseListener(object) {\r\n        console.log(\"hello, game engine\");\r\n        this.mouseListeners.push(object);\r\n    }\r\n\r\n    updateGameScript(delta) {\r\n        this.gameScript.update(delta);\r\n    }\r\n\r\n    addGameObject(object) {\r\n        this.gameObjects.push(object);\r\n    }\r\n\r\n    addPhysicsComponent(physicsComponent) {\r\n        this.physicsComponents.push(physicsComponent);\r\n    }\r\n\r\n    addLineSprite(lineSprite) {\r\n        this.lineSprites.push(lineSprite);\r\n    }\r\n\r\n    queueSound(sound) {\r\n        if (!this.muted) {\r\n            this.soundsToPlay[sound.url] = sound;\r\n        }\r\n    }\r\n\r\n    // remove(gameObject){\r\n    //   this.toRemoveQueue.push(gameObject)\r\n    // }\r\n\r\n    // emptyRemoveQueue(){\r\n    //   this.toRemoveQueue.forEach((gameObject) => {\r\n    //     this.removeAction(gameObject)\r\n    //   })\r\n    // }\r\n\r\n    remove(gameObject) {\r\n        if (gameObject.physicsComponent) {\r\n            this.physicsComponents.splice(\r\n                this.physicsComponents.indexOf(gameObject.physicsComponent),\r\n                1\r\n            );\r\n        }\r\n        if (gameObject.lineSprite) {\r\n            this.lineSprites.splice(\r\n                this.lineSprites.indexOf(gameObject.lineSprite),\r\n                1\r\n            );\r\n        }\r\n        this.removeColliders(gameObject.colliders);\r\n\r\n        this.gameObjects.splice(this.gameObjects.indexOf(gameObject), 1);\r\n    }\r\n\r\n    removeColliders(colliders) {\r\n        colliders.forEach((collider) => {\r\n            if (collider.subscriptions) {\r\n                this.subscribers.splice(this.subscribers.indexOf(collider), 1);\r\n            }\r\n\r\n            const objectAndColliderTypeList =\r\n        this.colliders[collider.objectType][collider.type];\r\n            objectAndColliderTypeList.splice(\r\n                objectAndColliderTypeList.indexOf(collider),\r\n                1\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\n// the idea:\r\n// engine takes in collider with gameobject type as string\r\n// this way subscriptions can be done via string names\r\n// enemy is subscribed to bullets..\r\n// each enemy will check every bullet\r\n// convert gameobject type to string\r\n// colliders can be added without subscriptions\r\n// subscriptions are an array of strings stored with the collider\r\n","import { Util } from \"./util\";\r\nimport { Sound } from \"./sound\";\r\n\r\nimport { Transform } from \"./transform\";\r\nimport { PhysicsComponent } from \"./physics_component\";\r\nimport { LineSprite } from \"./line_sprite\";\r\nimport { Collider } from \"./collider\";\r\n\r\nexport class GameObject {\r\n    constructor(engine) {\r\n        this.gameEngine = engine;\r\n        this.gameEngine.addGameObject(this);\r\n        this.transform = new Transform();\r\n        this.childObjects = [];\r\n        this.physicsComponent = null;\r\n        this.lineSprite = null;\r\n        this.parentObject = null;\r\n        this.colliders = [];\r\n    }\r\n\r\n    animate() {\r\n    // put animation stuffs here\r\n    }\r\n\r\n    addPhysicsComponent() {\r\n        this.physicsComponent = new PhysicsComponent(this.transform);\r\n        this.gameEngine.addPhysicsComponent(this.physicsComponent);\r\n    }\r\n\r\n    addLineSprite(lineSprite) {\r\n        this.lineSprite = lineSprite;\r\n        this.gameEngine.addLineSprite(this.lineSprite);\r\n    }\r\n\r\n    addMousePosListener() {\r\n        this.gameEngine.addMouseListener(this);\r\n    }\r\n\r\n    removeMousePosListener() {\r\n        this.gameEngine.removeMouseListener(this);\r\n    }\r\n\r\n    addLeftControlStickListener() {\r\n        this.gameEngine.addLeftControlStickListener(this);\r\n    }\r\n\r\n    addRightControlStickListener() {\r\n        this.gameEngine.addRightControlStickListener(this);\r\n    }\r\n\r\n    addxButtonListener() {\r\n        this.gameEngine.addxButtonListener(this);\r\n    }\r\n\r\n    addStartButtonListener() {\r\n        this.gameEngine.addStartButtonListener(this);\r\n    }\r\n\r\n    updateRightControlStickInput(direction) {}\r\n\r\n    updateLeftControlStickInput(direction) {}\r\n\r\n    updatexButtonListener() {}\r\n\r\n    updateStartButtonListener() {}\r\n\r\n    updateMousePos(mousePos) {}\r\n\r\n    addClickListener() {\r\n        this.gameEngine.addClickListener(this);\r\n    }\r\n\r\n    removeClickListener() {\r\n        this.gameEngine.removeClickListener(this);\r\n    }\r\n\r\n    mouseClicked(mousePos) {}\r\n\r\n    addCollider(type, gameObject, radius, subscriptionTypes, subscriptions) {\r\n    // game engine checks every collider with it's subscription types\r\n        const newCollider = new Collider(\r\n            type,\r\n            gameObject,\r\n            radius,\r\n            subscriptionTypes,\r\n            subscriptions\r\n        );\r\n        this.colliders.push(newCollider);\r\n        this.gameEngine.addCollider(newCollider);\r\n    }\r\n\r\n    playSound(sound) {\r\n        this.gameEngine.queueSound(sound);\r\n    }\r\n\r\n    // relative motion needs to be fixed... FOR ANOTHER TIME\r\n    addChildGameObject(obj, relative) {\r\n        this.childObjects.push(obj);\r\n        if (relative) {\r\n            obj.transform.parentTransform = this.transform;\r\n        }\r\n        obj.parentObject = this;\r\n    }\r\n\r\n    update(deltaTime) {\r\n    // overwritten by child class for update scripts\r\n    }\r\n\r\n    onCollision(collider, type) {\r\n    // overwritten by child class for handler\r\n    }\r\n\r\n    // remove is the issue\r\n    // i need a remove queue!!!\r\n    // ... I think\r\n    remove() {\r\n        this.childObjects.forEach((obj) => {\r\n            obj.remove();\r\n        });\r\n        if (this.parentObject) {\r\n            this.parentObject.childObjects.splice(\r\n                this.parentObject.childObjects.indexOf(this),\r\n                1\r\n            );\r\n        }\r\n        this.gameEngine.remove(this);\r\n    }\r\n}\r\n\r\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\r\n","export class LineSprite {\r\n    constructor(transform) {\r\n        this.transform = transform;\r\n        // this.drawFunction = draw\r\n        this.zoomScaling = 1;\r\n    }\r\n    // abstract functions\r\n    draw(ctx) {\r\n        const pos = this.transform.absolutePosition();\r\n        const angle = this.transform.abosluteAngle();\r\n        this.drawFunction(ctx, pos, angle);\r\n    }\r\n    drawFunction(ctx, pos, angle) {\r\n\r\n    }\r\n}\r\n","export class PhysicsComponent {\r\n    constructor(transform) {\r\n        this.transform = transform;\r\n    }\r\n\r\n    move(timeDelta) {\r\n    // timeDelta is number of milliseconds since last move\r\n    // if the computer is busy the time delta will be larger\r\n    // in this case the PhysicsObject should move farther in this frame\r\n        const timeScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\r\n        this.transform.pos[0] += this.transform.vel[0] * timeScale + (this.transform.acc[0] * (timeScale * timeScale)) / 2;\r\n        this.transform.pos[1] += this.transform.vel[1] * timeScale + (this.transform.acc[1] * (timeScale * timeScale)) / 2;\r\n        this.transform.pos[2] += this.transform.vel[2] * timeScale + (this.transform.acc[2] * (timeScale * timeScale)) / 2;\r\n        \r\n        this.transform.vel[0] += this.transform.acc[0] * timeScale;\r\n        this.transform.vel[1] += this.transform.acc[1] * timeScale;\r\n        this.transform.vel[2] += this.transform.acc[2] * timeScale;\r\n\r\n        this.transform.angle += this.transform.aVel;\r\n        this.transform.aVel += this.transform.aAcc;\r\n\r\n        this.transform.acc = [0, 0, 0];\r\n        this.transform.aAcc = 0;\r\n    }\r\n}\r\n\r\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\r\n","\r\nexport class Sound {\r\n    constructor(url, volume = 1, muted = false){\r\n        this.url = url;\r\n        this.volume = volume;\r\n        this.muted = muted;\r\n    }\r\n\r\n    play() {\r\n    // if (this.sound) {\r\n    //   this.sound.play()\r\n    // } else {\r\n        this.sound = new Audio(this.url);\r\n        this.sound.volume = this.volume;\r\n        this.sound.play();\r\n    // }\r\n    }\r\n    toggleMute(){\r\n        if(this.sound){\r\n            this.muted ? this.unmute() : this.mute();\r\n        }\r\n    }\r\n\r\n    unmute(){\r\n        if(this.sound){\r\n            this.muted = false; \r\n            this.sound.volume = this.volume;\r\n        }\r\n    }\r\n\r\n    mute(){\r\n        if(this.sound){\r\n            this.muted = true;\r\n            this.sound.volume = 0;\r\n        }\r\n    }\r\n\r\n    pause(){\r\n        if(this.sound){\r\n            this.sound.pause();\r\n        } \r\n    }\r\n    unPause(){\r\n        if (this.sound) {\r\n            this.sound.play();\r\n        }\r\n    }\r\n}\r\n","import { GameObject } from \"./game_object\";\r\n\r\nexport class StateMachine extends GameObject {\r\n    constructor(engine, {}) {\r\n        super(engine);\r\n        this.stateIndex = options.stateIndex || { i: 0 };\r\n        (this.parentState = options.parentState),\r\n        (waitTime = 0),\r\n        (stateQueue = []),\r\n        event,\r\n        (timesDo = 1),\r\n        (endCondition = true);\r\n        this.stateIndex = stateIndex;\r\n        this.parentIndex = parentIndex;\r\n        this.stateTime = 0;\r\n\r\n        this.waitTime = waitTime;\r\n        this.stateQueue = stateQueue;\r\n        this.event = event;\r\n        this.timesDo = timesDo;\r\n        this.endCondition = endCondition;\r\n        // if not null, it will repeat until the condition is met\\\r\n        // but it will meet the repeatcondition first.\r\n        // end condition returns a bool. default true\r\n\r\n        // there is no \"break\" condition yet\r\n\r\n        this.repeatCount = 1; // do something 3 times. 1 index not 0 index\r\n\r\n        // first it waits,\r\n        // then it runs through state queue\r\n        // then it runs the event\r\n        //      state queue and event can be empty,\r\n        //        which means the state was just for waiting\r\n        // then it checks the repeat condition\r\n\r\n    // event is something that runs in one frame\r\n    }\r\n\r\n    addChilState(state) {\r\n        state.parentIndex = this;\r\n    }\r\n\r\n    // state queue is now done\r\n    onCompletion() {\r\n        this.event();\r\n        // 1 index not 0\r\n        if (this.repeatCount <= this.timesDo) {\r\n            this.stateIndex.i = 0;\r\n            this.currentTime = 0;\r\n        } else if (!this.endCondition) {\r\n            this.stateIndex.i = 0;\r\n            this.currentTime = 0;\r\n        } else {\r\n            this.parentIndex += 1;\r\n            this.remove();\r\n        }\r\n    }\r\n\r\n    // instances vs inheritance\r\n    // instance is built from the ground up,\r\n    // starting with the lowest level of the sequence\r\n    // inheritance is built from the top down,\r\n    // allowing each custom class to build thier individual statequeues\r\n    // inheritance gives access to all of the gameobject functions\r\n    // instances are simpler, everything is fed through the constuctor\r\n    // User gets to choose?\r\n\r\n    // singularity\r\n    // EasyGroups <-- childState\r\n    // wait: 2500 * timeScale (user can provide timescale functionality)\r\n    // event: spawnEasyGroups\r\n    // endCondition: x4 // repeats until end condition met\r\n    // parentIndex\r\n    // waitState <--childState\r\n    // EasyGroupsArrows\r\n    // wait: 2500 * timeScale (user can provide timescale functionality)\r\n    // event: spawnEasyGroupsArrows\r\n    // endCondition: x4 // repeats until end condition met\r\n    // event\r\n    // wait\r\n    // event\r\n    //\r\n\r\n    event() {\r\n        this.eventCondition();\r\n    }\r\n    //spawner\r\n    //easy wave\r\n    //\r\n\r\n    updateState(intervalTime) {\r\n        if (this.stateIndex > this.stateQueue.length) {\r\n            this.onCompletion();\r\n        } else {\r\n            this.stateTime += intervalTime;\r\n            if (intervalTime > this.waitTime) {\r\n                this.stateQueue[this.stateIndex.i].updateState(intervalTime);\r\n            }\r\n        }\r\n    }\r\n\r\n    remove() {\r\n        this.childObjects.forEach((obj) => {\r\n            obj.remove();\r\n        });\r\n        if (this.parentObject) {\r\n            this.parentObject.childObjects.splice(\r\n                this.parentObject.childObjects.indexOf(this),\r\n                1\r\n            );\r\n        }\r\n        this.stateQueue.forEach((obj) => {\r\n            obj.remove();\r\n        });\r\n\r\n        this.gameEngine.remove(this);\r\n    }\r\n}","export class Transform {\r\n    constructor(\r\n        cameraTransform = null,\r\n        pos = [0, 0, 0],\r\n        vel = [0, 0, 0],\r\n        acc = [0, 0, 0],\r\n        angle = 0,\r\n        aVel = 0,\r\n        aAcc = 0,\r\n        parentTransform = null\r\n    ) {\r\n        this.cameraTransform = cameraTransform;\r\n        this.parentTransform = parentTransform;\r\n        this.angle = angle;\r\n        this.aVel = aVel;\r\n        this.aAcc = aAcc;\r\n        this.pos = pos;\r\n        this.vel = vel;\r\n        this.acc = acc;\r\n    }\r\n\r\n    // object will have a render position projected on to the field based on where the camera is and the object's position (z)\r\n\r\n    getRenderPosition() {\r\n        // takes in the camera position and the object's position\r\n        // returns the render position (position projected on to the field)\r\n        \r\n        //Yp = -Zc(Ys - Yc)/(-Zc + Zs)\r\n        //Xp = -Zc(Xs - Xc)/(-Zc + Zs)\r\n\r\n\r\n    }\r\n\r\n    // call up the tree of parent transforms until null\r\n    // performing the transformation each step for the absolute\r\n    absoluteAngle() {\r\n        if (this.parentTransform == null) {\r\n            return this.angle;\r\n        } else {\r\n            return this.angleAdd(this.angle, this.parentTransform.absoluteAngle());\r\n        }\r\n    }\r\n\r\n    absolutePosition() {\r\n        let absPos = [];\r\n       \r\n        if (this.parentTransform == null) {\r\n            if (this.cameraTransform) {\r\n                const Xc = this.cameraTransform.pos[0];\r\n                const Yc = this.cameraTransform.pos[1];\r\n                const Zc = this.cameraTransform.pos[2];\r\n                const Xs = this.pos[0];\r\n                const Ys = this.pos[1];\r\n                const Zs = this.pos[2];\r\n                // this only works for things behind, not in front of the field\r\n                // const Xp = (-Zc * (Xs - Xc)) / (-Zc + Zs);\r\n                // const Yp = (-Zc * (Ys - Yc)) / (-Zc + Zs);'\r\n                const Yp = Yc + (Ys-Yc)/(Zs-Zc) * (0 - Zc);\r\n                const Xp = Xc + (Xs-Xc)/(Zs-Zc) * (0 - Zc);\r\n                absPos = [Xp, Yp];\r\n            } else {\r\n                absPos = [this.pos[0], this.pos[1]];\r\n            }\r\n            \r\n\r\n            return absPos;\r\n        } else {\r\n            return this.vectorAdd(this.pos, this.parentTransform.absolutePosition());\r\n        }\r\n    }\r\n\r\n    absoluteLength(length, relativePosition = [0,0,0]) {\r\n        // doesn't care about line orientation\r\n        // center of the line is current position, or adjusted by relative position\r\n        // assuming camera is on top of the line\r\n        const linePosition = this.vectorAdd(relativePosition, this.pos);\r\n        const Zc = this.cameraTransform.pos[2];\r\n        const pointOne = length / 2;\r\n        const pointTwo = -length / 2;\r\n        const Zs = linePosition[2];\r\n        const absPointOne = (pointOne)/(Zs-Zc) * (0 - Zc);\r\n        const absPointTwo = (pointTwo)/(Zs-Zc) * (0 - Zc);\r\n        return absPointOne - absPointTwo;\r\n    }\r\n\r\n    absoluteVelocity() {\r\n        let absVel = [];\r\n        if (this.parentTransform == null) {\r\n            absVel = this.vel;\r\n            return absVel;\r\n        } else {\r\n            return this.vectorAdd(this.vel, this.parentTransform.absoluteVelocity());\r\n        }\r\n    }\r\n\r\n    absoluteAcceleration() {\r\n        let absAcc = [];\r\n        if (this.parentTransform == null) {\r\n            absAcc = this.acc;\r\n            return absAcc;\r\n        } else {\r\n            return this.vectorAdd(\r\n                this.acc,\r\n                this.parentTransform.absoluteAcceleration()\r\n            );\r\n        }\r\n    }\r\n\r\n    vectorAdd(vector1, vector2) {\r\n        return vector1.length === 3 && vector2.length === 3 ? \r\n            [vector1[0] + vector1[0], vector1[1] + vector2[1], vector1[2] + vector2[2]] : \r\n            [vector1[0] + vector1[0], vector1[1] + vector2[1]];\r\n    }\r\n\r\n    angleAdd(angle1, angle2) {\r\n        return (angle1 + angle2) % (2 * Math.PI);\r\n    }\r\n}\r\n","export const Util = {\r\n    // Normalize the length of the vector to 1, maintaining direction.\r\n    dir(vec) {\r\n        const norm = Util.norm(vec);\r\n        return Util.scale(vec, 1 / norm);\r\n    },\r\n    vectorCartesian(angle,scale){\r\n        let vector = [];\r\n        vector = [scale * Math.cos(angle), scale * Math.sin(angle)];\r\n        return vector;\r\n    },\r\n    vector3Cartesian(angle,scale){ // angle is [plane, out of plane]\r\n        return [scale * Math.cos(angle[0]) * Math.cos(angle[1]), scale * Math.sin(angle[0]) * Math.cos(angle[1]), scale * Math.sin(angle[1])];\r\n    },\r\n    // Find distance between two points.\r\n    dist(pos1, pos2) {\r\n        return Math.sqrt(\r\n            Math.pow(pos1[0] - pos2[0], 2) + Math.pow(pos1[1] - pos2[1], 2)\r\n        );\r\n    },\r\n    // Find the length of the vector.\r\n    norm(vec) {\r\n        return Util.dist([0, 0], vec);\r\n    },\r\n    // Return a randomly oriented vector with the given length.\r\n    randomVec(length) {\r\n        const deg = 2 * Math.PI * Math.random();\r\n        return Util.scale([Math.sin(deg), Math.cos(deg)], length);\r\n    },\r\n    // Scale the length of a vector by the given amount.\r\n    scale(vec, m) {\r\n        return [vec[0] * m, vec[1] * m];\r\n    },\r\n\r\n  \r\n \r\n};\r\n","import {GameObject} from \"../../game_engine/game_object\";\r\nimport {Sound} from \"../../game_engine/sound\";\r\nimport {BulletWallExplosion} from \"../particles/bullet_wall_explosion\";\r\nimport {BulletSprite} from \"./bullet_sprite\";\r\nimport {ParticleExplosion} from \"../particles/particle_explosion\";\r\nexport class Bullet extends GameObject {\r\n    constructor(engine, pos, vel, bulletNumber) {\r\n        super(engine);\r\n        this.ID = bulletNumber;\r\n        this.transform.pos[0] = pos[0];\r\n        this.transform.pos[1] = pos[1];\r\n        this.transform.vel[0] = vel[0];\r\n        this.transform.vel[1] = vel[1];\r\n        this.length = 12;\r\n        this.radius = this.length / 4;\r\n        this.wrap = false;\r\n        this.wallhit = new Sound(\"GEOWars/sounds/bullet_hitwall.wav\", 1);\r\n        this.addExplosionCollider();\r\n        this.addPhysicsComponent();\r\n        this.addLineSprite(new BulletSprite(this.transform));\r\n        this.exploded = false;\r\n        this.lifeTime = 4000;\r\n        this.aliveTime = 0;\r\n    }\r\n\r\n    addExplosionCollider() {\r\n        const subscribers = [\r\n            \"Grunt\",\r\n            \"Pinwheel\",\r\n            \"BoxBox\",\r\n            \"Arrow\",\r\n            \"Singularity\",\r\n            \"Weaver\",\r\n            \"AlienShip\",\r\n        ];\r\n        this.addCollider(\"bulletHit\", this, this.radius, subscribers, [\"General\"]);\r\n        this.addCollider(\"General\", this, this.radius);\r\n    }\r\n\r\n    update(deltaTime) {\r\n        this.aliveTime += deltaTime;\r\n        if (this.aliveTime > this.lifeTime) {\r\n            this.remove();\r\n        }\r\n        if (\r\n            this.gameEngine.gameScript.isOutOfBounds(\r\n                this.transform.absolutePosition()\r\n            ) &&\r\n      !this.exploded\r\n        ) {\r\n            this.exploded = true;\r\n            new BulletWallExplosion(this.gameEngine, this.transform.pos);\r\n\r\n            this.gameEngine.queueSound(this.wallhit);\r\n            this.remove();\r\n        }\r\n    }\r\n\r\n    onCollision(collider, type) {\r\n        if (type === \"bulletHit\") {\r\n            if (collider.objectType === \"Singularity\") {\r\n                collider.gameObject.bulletHit();\r\n                this.remove();\r\n            } else {\r\n                const hitObjectTransform = collider.gameObject.transform;\r\n                const pos = hitObjectTransform.absolutePosition();\r\n                const vel = hitObjectTransform.absoluteVelocity();\r\n                const explosion = new ParticleExplosion(this.gameEngine, pos, vel);\r\n                this.gameEngine.gameScript.tallyScore(collider.gameObject);\r\n                collider.gameObject.remove();\r\n                this.remove();\r\n            }\r\n        }\r\n    }\r\n\r\n    // move(timeDelta) {\r\n\r\n    // }\r\n}\r\n\r\nBullet.RADIUS = 3;\r\nBullet.SPEED = 7;\r\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\r\n","import { LineSprite } from \"../../game_engine/line_sprite\";\r\n\r\nexport class BulletSprite extends LineSprite {\r\n    constructor(transform, spawningScale = 1) {\r\n        super(transform);\r\n        this.spawningScale = spawningScale;\r\n        this.length = 12;\r\n    }\r\n\r\n    draw(ctx) {\r\n        const l = this.length;\r\n        const pos = this.transform.absolutePosition();\r\n        const vel = this.transform.absoluteVelocity();\r\n\r\n        const w = this.length / 2;\r\n        const movementDirection = Math.atan2(vel[0], -vel[1]);\r\n\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.translate(pos[0], pos[1]);\r\n        ctx.rotate(movementDirection + 2 * Math.PI);\r\n\r\n        ctx.beginPath();\r\n        ctx.strokeStyle = \"#FBFBC2\";\r\n        ctx.lineWidth = 1;\r\n\r\n        ctx.moveTo(-l / 4, l / 2); //1\r\n        ctx.lineTo(0, -l / 2); //2\r\n        ctx.lineTo(l / 4, l / 2); //3\r\n\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n}\r\n","\r\n\r\nimport { OverlaySprite } from \"./overlay_sprite\";\r\nimport { GameObject } from \"../../game_engine/game_object\";\r\n\r\nexport class Overlay extends GameObject {\r\n    constructor(engine, gameScript, shipTransform) {\r\n        super(engine);\r\n        this.gameScript = gameScript;\r\n        this.shipTransform = shipTransform;\r\n        this.transform.pos = [0, 0];\r\n        this.addLineSprite(new OverlaySprite(this.shipTransform, this.gameScript.DIM_X, this.gameScript.DIM_Y, this.gameEngine));\r\n    }\r\n\r\n    update(deltaTime) {\r\n        this.lineSprite.score = this.gameScript.score;\r\n        this.lineSprite.lives = this.gameScript.lives;\r\n    }\r\n}\r\n","import { LineSprite } from \"../../game_engine/line_sprite\";\r\nimport { Color } from \"../../game_engine/color\";\r\nexport class OverlaySprite extends LineSprite {\r\n    constructor(transform, DIM_X, DIM_Y, gameEngine) {\r\n        super(transform);\r\n        this.gameEngine = gameEngine;\r\n        this.transform = transform;\r\n        this.width = DIM_X;\r\n        this.height = DIM_Y;\r\n        this.score = 0;\r\n        this.lives = 0;\r\n        this.fontSize = 20;\r\n        this.fontStyle = \"Arial\";\r\n        this.shadowColor = new Color({\r\n            \"hsla\": [202, 100, 70, 1]\r\n        });\r\n        this.color = new Color({\r\n            \"hsla\": [202, 100, 70, 0.5]\r\n        });\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.save();\r\n        ctx.scale(1 / this.gameEngine.zoomScale, 1 / this.gameEngine.zoomScale);\r\n        const zoomFactor = this.gameEngine.zoomScale / this.gameEngine.defaultZoomScale;\r\n        ctx.font = this.fontSize * 1.3 + \"px \" + this.fontStyle;\r\n        ctx.fillStyle = this.color.evaluateColor();\r\n\r\n        ctx.fillText(\"Score: \" + this.score + \"      \" + \"Lives: \" + this.lives, (this.transform.pos[0] - 350 / zoomFactor) * this.gameEngine.zoomScale, (this.transform.pos[1] - 150 / zoomFactor )* this.gameEngine.zoomScale);\r\n        ctx.restore();\r\n    }\r\n}","import { WallsSprite } from \"./walls_sprite\";\r\nimport { GameObject } from \"../../game_engine/game_object\";\r\n\r\nexport class Walls extends GameObject {\r\n    constructor(engine, gameScript) {\r\n        super(engine);\r\n        this.gameScript = gameScript;\r\n        this.transform.pos = [0,0];\r\n        this.addLineSprite(new WallsSprite(this.transform, this.gameScript.DIM_X, this.gameScript.DIM_Y));\r\n    }\r\n\r\n    update(deltaTime) {\r\n        \r\n    }\r\n}","import { LineSprite } from \"../../game_engine/line_sprite\";\r\nimport { Color } from \"../../game_engine/color\";\r\nexport class WallsSprite extends LineSprite {\r\n    constructor(transform, DIM_X, DIM_Y) {\r\n        super(transform);\r\n        this.width = DIM_X;\r\n        this.height = DIM_Y;\r\n        this.shadowColor = new Color({\r\n            \"hsla\": [202, 100, 70, 1]\r\n        });\r\n        this.color = new Color({\r\n            \"hsla\": [202, 100, 70, 0.2]\r\n        });\r\n    }\r\n\r\n    draw(ctx) {\r\n        const w = this.width;\r\n        const h = this.height;\r\n        const pos = this.transform.absolutePosition();\r\n\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.translate(pos[0], pos[1]);\r\n\r\n        const blurFactor = 0.5;\r\n        ctx.shadowColor = this.shadowColor.evaluateColor();\r\n        ctx.shadowBlur = 10;\r\n        ctx.strokeStyle = this.color.evaluateColor();\r\n        ctx.lineWidth = 7.5 * blurFactor * 2;\r\n        this.drawWalls(ctx, w, h);\r\n        ctx.lineWidth = 6 * 2;// * blurFactor;\r\n        this.drawWalls(ctx, w, h);\r\n        ctx.lineWidth = 4.5 * 2; // * blurFactor;\r\n        this.drawWalls(ctx, w, h);\r\n        ctx.lineWidth = 3 * 2;// * blurFactor;\r\n        this.drawWalls(ctx, w, h);\r\n        ctx.strokeStyle = 'rgb(255, 255, 255)';\r\n        ctx.lineWidth = 1.5 * 2;// * blurFactor;\r\n        this.drawWalls(ctx, w, h);\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    drawWalls(ctx,w,h){\r\n        const offset = 6;\r\n        ctx.beginPath;\r\n        ctx.moveTo(-offset, -offset);\r\n        ctx.lineTo(w + offset, -offset);\r\n        ctx.lineTo(w + offset, h + offset); //3\r\n        ctx.lineTo(0 - offset, h + offset);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n    }\r\n}","import { GameObject } from \"../../../game_engine/game_object\";\r\nimport { Util } from \"../../../game_engine/util\";\r\nimport { Sound } from \"../../../game_engine/sound\";\r\nimport { EnemySpawn } from \"../../particles/enemy_spawn\";\r\nimport { ArrowSprite } from \"./arrow_sprite\";\r\n\r\nexport class Arrow extends GameObject {\r\n    constructor(engine, pos, angle = Math.PI / 3) {\r\n        super(engine);\r\n        this.transform.pos = pos;\r\n        this.transform.angle = angle;\r\n        this.speed = 3;\r\n        this.points = 50;\r\n        this.transform.vel = Util.vectorCartesian(this.transform.angle, this.speed);\r\n        this.radius = 6;\r\n        this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_purple.wav\", 0.5);\r\n        this.playSound(this.spawnSound);\r\n        this.addLineSprite(new ArrowSprite(this.transform));\r\n        this.addChildGameObject(new EnemySpawn(this.gameEngine));\r\n        this.exists = false;\r\n        this.time = 0;\r\n    }\r\n\r\n    exist() {\r\n    // leaving off subscriptions means that things will subscribe to it\r\n        this.addCollider(\"General\", this, this.radius);\r\n        // now it will move\r\n        this.addPhysicsComponent();\r\n        this.exists = true;\r\n    }\r\n\r\n    animate(delta) {\r\n        this.time += delta;\r\n        const cycleSpeedScale = delta / NORMAL_FRAME_TIME_DELTA;\r\n        const cycleSpeed = 0.004;\r\n        const widthRotate = Math.sin(this.time * cycleSpeedScale * cycleSpeed);\r\n        const twoFullRotationCheck = this.time * cycleSpeedScale * cycleSpeed;\r\n\r\n        if (twoFullRotationCheck >= Math.PI * 2 * 4) {\r\n            this.time = 0;\r\n        }\r\n        this.lineSprite.yRotation = this.time * cycleSpeedScale * cycleSpeed;\r\n        this.lineSprite.widthScaleForRotation = Math.sin(\r\n            this.time * cycleSpeedScale * cycleSpeed\r\n        );\r\n        this.lineSprite.zScaleForRotation = Math.sin(\r\n            this.time * cycleSpeedScale * cycleSpeed + Math.PI / 2\r\n        );\r\n    }\r\n\r\n    update(delta) {\r\n    // ADD TO UPDATE FOR THE OBJECTS\r\n        this.animate(delta);\r\n\r\n        const pos = this.transform.absolutePosition();\r\n        if (this.gameEngine.gameScript.isOutOfBounds(pos)) {\r\n            this.gameEngine.gameScript.redirect(this.transform);\r\n        }\r\n    }\r\n}\r\n\r\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\r\n","import { LineSprite } from \"../../../game_engine/line_sprite\";\r\nexport class ArrowSprite extends LineSprite {\r\n    constructor(transform, spawningScale = 1) {\r\n        super(transform);\r\n        this.spawningScale = spawningScale;\r\n        this.widthScaleForRotation = 1;\r\n        this.zScaleForRotation = 0;\r\n        this.yRotation = 0;\r\n    }\r\n\r\n    draw(ctx) {\r\n        const pos = this.transform.absolutePosition();\r\n        const spawningScale = this.spawningScale || 1;\r\n        const shipLength = 10.5 * 2.2 * spawningScale;\r\n        const shipWidth = 9 * 2.2 * spawningScale;\r\n        const l = shipLength;\r\n        const w = shipWidth * this.widthScaleForRotation;\r\n        const z = shipWidth * this.zScaleForRotation;\r\n        const movementDirection = Math.atan2(\r\n            this.transform.vel[0],\r\n            -this.transform.vel[1]\r\n        );\r\n\r\n        const r = 255;\r\n        const g = 255;\r\n        const b = 50;\r\n\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.translate(pos[0], pos[1]);\r\n        ctx.rotate(movementDirection + 1 * Math.PI);\r\n\r\n        // ctx.strokeStyle = \"#f2ff00\"; // look up rgb and put here\r\n        // ctx.lineWidth = 2 / 2;\r\n\r\n        ctx.shadowColor = \"rgb(255,255,255)\";\r\n        ctx.shadowBlur = 1.5;\r\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\r\n        const lineWidth = 2;\r\n\r\n        const rightLineWidth =\r\n      lineWidth + 2.5 * Math.sin(this.yRotation + Math.PI / 2);\r\n        const leftLineWidth =\r\n      lineWidth - 2.5 * Math.sin(this.yRotation + Math.PI / 2);\r\n        const topLineWidth = lineWidth + 2.5 * Math.sin(this.yRotation);\r\n        const bottomLineWidth = lineWidth - 2.5 * Math.sin(this.yRotation);\r\n\r\n        // this.drawArrow(\r\n        //   ctx,\r\n        //   l,\r\n        //   w,\r\n        //   z,\r\n        //   rightLineWidth,\r\n        //   leftLineWidth,\r\n        //   topLineWidth,\r\n        //   bottomLineWidth\r\n        // );\r\n\r\n        this.drawArrow(\r\n            ctx,\r\n            l,\r\n            w,\r\n            z,\r\n            rightLineWidth * 0.75,\r\n            leftLineWidth * 0.75,\r\n            topLineWidth * 0.75,\r\n            bottomLineWidth * 0.75\r\n        );\r\n\r\n        this.drawArrow(\r\n            ctx,\r\n            l,\r\n            w,\r\n            z,\r\n            rightLineWidth * 0.6,\r\n            leftLineWidth * 0.6,\r\n            topLineWidth * 0.6,\r\n            bottomLineWidth * 0.6\r\n        );\r\n\r\n        this.drawArrow(\r\n            ctx,\r\n            l,\r\n            w,\r\n            z,\r\n            rightLineWidth * 0.45,\r\n            leftLineWidth * 0.45,\r\n            topLineWidth * 0.45,\r\n            bottomLineWidth * 0.45\r\n        );\r\n\r\n        this.drawArrow(\r\n            ctx,\r\n            l,\r\n            w,\r\n            z,\r\n            rightLineWidth * 0.3,\r\n            leftLineWidth * 0.3,\r\n            topLineWidth * 0.3,\r\n            bottomLineWidth * 0.3\r\n        );\r\n\r\n        ctx.strokeStyle = \"rgb(255, 255, 255)\";\r\n        // this should be half the other line width for the effect, even after adding sin\r\n        this.drawArrow(\r\n            ctx,\r\n            l,\r\n            w,\r\n            z,\r\n            rightLineWidth * 0.15,\r\n            leftLineWidth * 0.15,\r\n            topLineWidth * 0.15,\r\n            bottomLineWidth * 0.15\r\n        );\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    drawArrow(\r\n        ctx,\r\n        l,\r\n        w,\r\n        z,\r\n        rightLineWidth,\r\n        leftLineWidth,\r\n        topLineWidth,\r\n        bottomLineWidth\r\n    ) {\r\n        ctx.lineWidth = rightLineWidth;\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, 0.4762 * l); //1\r\n        ctx.lineTo(0.5 * w, -0.2381 * l); //2\r\n        ctx.lineTo(0.25 * w, -0.5238 * l); //3\r\n        ctx.lineTo(0.1666 * w, -0.2381 * l); //4\r\n        ctx.lineTo(0, -0.2381 * l); //4.5\r\n        ctx.stroke();\r\n\r\n        ctx.lineWidth = leftLineWidth;\r\n        ctx.beginPath();\r\n        ctx.lineTo(0, -0.2381 * l); //4.5\r\n        ctx.lineTo(-0.1666 * w, -0.2381 * l); //5\r\n        ctx.lineTo(-0.25 * w, -0.5238 * l); //6\r\n        ctx.lineTo(-0.5 * w, -0.2381 * l); //7\r\n        ctx.lineTo(0, 0.4762 * l); //1\r\n        ctx.stroke();\r\n\r\n        ctx.lineWidth = topLineWidth;\r\n        ctx.beginPath();\r\n        ctx.moveTo(-0.1666 * z, -0.0952 * l); //1\r\n        ctx.lineTo(-0.3333 * z, -0.2381 * l); //2\r\n        ctx.lineTo(-0.25 * z, -0.381 * l); //3\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n\r\n        ctx.lineWidth = bottomLineWidth;\r\n        ctx.beginPath();\r\n        ctx.moveTo(0.1666 * z, -0.0952 * l); //1\r\n        ctx.lineTo(0.3333 * z, -0.2381 * l); //2\r\n        ctx.lineTo(0.25 * z, -0.381 * l); //3\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n\r\n    // ctx.lineWidth = lineWidth / 2;\r\n    // ctx.beginPath();\r\n    // ctx.moveTo(0.2083 * z, -0.2381 * l); //1\r\n    // ctx.lineTo(-0.2083 * z, -0.2381 * l); //2\r\n    // ctx.stroke();\r\n    }\r\n}\r\n/*\r\n// OG\r\nlet blurFactor = 0.5\r\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\r\n    ctx.shadowBlur = 10 * blurFactor;\r\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\r\n\r\n    ctx.lineWidth = 7.5 * blurFactor;\r\n    this.drawArrow(ctx, l, w);\r\n\r\n    ctx.lineWidth = 6 * blurFactor;\r\n    this.drawArrow(ctx, l, w);\r\n\r\n    ctx.lineWidth = 4.5;\r\n    this.drawArrow(ctx, l, w);\r\n\r\n    ctx.lineWidth = 3;\r\n    this.drawArrow(ctx, l, w);\r\n\r\n    ctx.strokeStyle = 'rgb(255, 255, 255)';\r\n    \r\n    ctx.lineWidth = 1.5;\r\n    this.drawArrow(ctx, l, w);\r\n*/\r\n","import {GameObject} from \"../../../game_engine/game_object\";\r\nimport {Sound} from \"../../../game_engine/sound\";\r\nimport {EnemySpawn} from \"../../particles/enemy_spawn\";\r\nimport {BoxBoxSprite} from \"./boxbox_sprite\";\r\n\r\nexport class BoxBox extends GameObject {\r\n    constructor(engine, pos) {\r\n        super(engine);\r\n        this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_blue.wav\", 0.5);\r\n        this.transform.pos = pos;\r\n        this.radius = 10;\r\n        this.points = 20;\r\n        // this.addPhysicsComponent()\r\n        this.addLineSprite(new BoxBoxSprite(this.transform));\r\n        this.addChildGameObject(new EnemySpawn(this.gameEngine));\r\n        this.playSound(this.spawnSound);\r\n    }\r\n\r\n    exist() {\r\n    // leaving off subscriptions means that things will subscribe to it\r\n        this.addCollider(\"General\", this, this.radius);\r\n        // now it will move\r\n        this.addPhysicsComponent();\r\n    }\r\n \r\n    wallGraze(){\r\n        this.gameEngine.gameScript.wallGraze(this.transform, this.radius);\r\n    }\r\n\r\n    update(delta){\r\n        if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius * 2)) {\r\n            this.wallGraze(); \r\n        }\r\n    }\r\n}\r\n","import { LineSprite } from \"../../../game_engine/line_sprite\";\r\n\r\nexport class BoxBoxSprite extends LineSprite {\r\n    constructor(transform, spawningScale = 1) {\r\n        super(transform);\r\n        this.spawningScale = spawningScale;\r\n    }\r\n\r\n    draw(ctx) {\r\n        const spawningScale = this.spawningScale || 1;\r\n        const pos = this.transform.absolutePosition();\r\n        const boxSize = 10 * spawningScale;\r\n\r\n        // ctx.strokeStyle = \"#F173BA\";\r\n\r\n        const r = 210;\r\n        const g = 75;\r\n        const b = 75;\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.translate(pos[0], pos[1]);\r\n        const blurFactor = 0.5;\r\n        ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\r\n        ctx.shadowBlur = 10 * blurFactor;\r\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\r\n        ctx.lineWidth = 7.5 * blurFactor;\r\n        this.drawBox1(ctx, boxSize);\r\n        this.drawBox2(ctx, boxSize);\r\n        ctx.lineWidth = 6 * blurFactor;\r\n        this.drawBox1(ctx, boxSize);\r\n        this.drawBox2(ctx, boxSize);\r\n        ctx.lineWidth = 4.5;\r\n        this.drawBox1(ctx, boxSize);\r\n        this.drawBox2(ctx, boxSize);\r\n        ctx.lineWidth = 3;\r\n        this.drawBox1(ctx, boxSize);\r\n        this.drawBox2(ctx, boxSize);\r\n        ctx.strokeStyle = \"rgb(255, 255, 255)\";\r\n        ctx.lineWidth = 1.5;\r\n        this.drawBox1(ctx, boxSize);\r\n        this.drawBox2(ctx, boxSize);\r\n        ctx.restore();\r\n    }\r\n\r\n    drawBox1(ctx, boxSize) {\r\n        const w = boxSize;\r\n        const slideFactor = 1.125;\r\n        ctx.beginPath();\r\n        ctx.moveTo(w / 4, -w / 4);\r\n        ctx.lineTo(w / 4, (3 * w) / 4);\r\n        ctx.lineTo((-3 * w) / 4, (3 * w) / 4);\r\n        ctx.lineTo((-3 * w) / 4, -w / 4);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n    }\r\n\r\n    drawBox2(ctx, boxSize) {\r\n        const w = boxSize;\r\n        const slideFactor = 1.5;\r\n        ctx.beginPath();\r\n        ctx.moveTo(-w / 4, w / 4);\r\n        ctx.lineTo(-w / 4, (-3 * w) / 4);\r\n        ctx.lineTo((3 * w) / 4, (-3 * w) / 4);\r\n        ctx.lineTo((3 * w) / 4, w / 4);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n    }\r\n}\r\n","import {GameObject} from \"../../../game_engine/game_object\";\r\nimport {Sound} from \"../../../game_engine/sound\";\r\nimport {EnemySpawn} from \"../../particles/enemy_spawn\";\r\nimport {GruntSprite} from \"./grunt_sprite\";\r\nexport class Grunt extends GameObject {\r\n    constructor(engine, pos, shipTransform) {\r\n        super(engine);\r\n        this.transform.pos = pos;\r\n        this.exists = false;\r\n        this.stretchDirection = -1;\r\n        this.shipTransform = shipTransform;\r\n        this.radius = 5;\r\n        this.points = 70;\r\n        this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_blue.wav\", 0.5);\r\n        this.playSound(this.spawnSound);\r\n        this.addLineSprite(new GruntSprite(this.transform));\r\n        this.addChildGameObject(new EnemySpawn(this.gameEngine));\r\n    }\r\n\r\n    exist() {\r\n        this.exists = true;\r\n        // leaving off subscriptions means that things will subscribe to it\r\n        this.addCollider(\"General\", this, this.radius);\r\n        // now it will move\r\n        this.addPhysicsComponent();\r\n    }\r\n\r\n    // ADDING MOVEMENT MECHANICS FOR GRUNT\r\n\r\n    chase(timeDelta) {\r\n        const speed = 1.5;\r\n        const shipPos = this.shipTransform.pos;\r\n        const pos = this.transform.pos;\r\n        const dy = shipPos[1] - pos[1];\r\n        const dx = shipPos[0] - pos[0];\r\n\r\n        const velocityScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\r\n        const direction = Math.atan2(dy, dx);\r\n\r\n        this.transform.pos[0] += speed * Math.cos(direction) * velocityScale;\r\n        this.transform.pos[1] += speed * Math.sin(direction) * velocityScale;\r\n    }\r\n\r\n    animate(timeDelta) {\r\n        const cycleSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\r\n        const cycleSpeed = 0.01;\r\n        if (this.lineSprite.stretchScale_W < 0.7 || this.lineSprite.stretchScale_W > 1) {\r\n            this.stretchDirection *= -1;\r\n        }\r\n\r\n        this.lineSprite.stretchScale_W = this.lineSprite.stretchScale_W + -this.stretchDirection * cycleSpeed * cycleSpeedScale;\r\n        this.lineSprite.stretchScale_L = this.lineSprite.stretchScale_L + this.stretchDirection * cycleSpeed * cycleSpeedScale;\r\n\r\n    }\r\n\r\n    update(timeDelta) {\r\n        if (this.exists) {\r\n            this.chase(timeDelta);\r\n            this.animate(timeDelta);\r\n      \r\n            if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\r\n                this.wallGraze();\r\n            }\r\n        }\r\n    }\r\n\r\n    wallGraze() {\r\n        this.gameEngine.gameScript.wallGraze(this.transform, this.radius);\r\n    }\r\n\r\n  \r\n}\r\n\r\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","import {LineSprite} from \"../../../game_engine/line_sprite\";\r\nexport class GruntSprite extends LineSprite {\r\n    constructor(transform, spawningScale = 1) {\r\n        super(transform)\r\n        this.spawningScale = spawningScale\r\n        this.stretchScale_L = 1\r\n        this.stretchScale_W = 0.7\r\n    }\r\n\r\n    draw(ctx) {\r\n        const pos = this.transform.absolutePosition();\r\n    \r\n        const spawningScale = this.spawningScale;\r\n        const shipLength = 10 * 2.2 * spawningScale * this.stretchScale_L;\r\n        const shipWidth = 10 * 2.2 * spawningScale * this.stretchScale_W;\r\n        const l = shipLength;\r\n        const w = shipWidth;\r\n\r\n        const r = 0;\r\n        const g = 57;\r\n        const b = 230;\r\n\r\n        ctx.save();\r\n        ctx.translate(pos[0], pos[1]);\r\n\r\n        const blurFactor = 0.5\r\n\r\n        ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\r\n        ctx.shadowBlur = 10\r\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\r\n        ctx.lineWidth = 7.5 * blurFactor;\r\n        this.drawDiamond(ctx, l, w);\r\n        ctx.lineWidth = 6 // * blurFactor;\r\n        this.drawDiamond(ctx, l, w);\r\n        ctx.lineWidth = 4.5 // * blurFactor;\r\n        this.drawDiamond(ctx, l, w);\r\n        ctx.lineWidth = 3 // * blurFactor;\r\n        this.drawDiamond(ctx, l, w);\r\n        ctx.strokeStyle = 'rgb(255, 255, 255)';\r\n        ctx.lineWidth = 1.5 // * blurFactor;\r\n        this.drawDiamond(ctx, l, w);\r\n    \r\n        ctx.restore();\r\n    }\r\n\r\n    drawDiamond(ctx, l, w) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, -l / 2); //1\r\n        ctx.lineTo(w / 2, 0); //2\r\n        ctx.lineTo(0, l / 2); //3\r\n        ctx.lineTo(-w / 2, -0); //4\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n    }\r\n\r\n\r\n\r\n\r\n}\r\n","import {Sound} from \"../../../game_engine/sound\";\r\nimport {Util} from \"../../../game_engine/util\";\r\nimport {GameObject} from \"../../../game_engine/game_object\";\r\nimport {EnemySpawn} from \"../../particles/enemy_spawn\";\r\nimport {PinwheelSprite} from \"./pinwheel_sprite\";\r\n\r\nexport class Pinwheel extends GameObject {\r\n    constructor(engine, pos) {\r\n        super(engine);\r\n        this.rotation_speed = 0.05;\r\n        const speed = 1;\r\n        this.points = 20;\r\n        this.transform.pos = pos;\r\n        this.transform.vel = Util.randomVec(speed);\r\n        this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_blue.wav\", 0.5);\r\n        this.playSound(this.spawnSound);\r\n        this.addLineSprite(new PinwheelSprite(this.transform));\r\n        this.addChildGameObject(new EnemySpawn(this.gameEngine));\r\n        this.radius = 5;\r\n    }\r\n  \r\n    exist() {\r\n    // leaving off subscriptions means that things will subscribe to it\r\n        this.addCollider(\"General\", this, this.radius);\r\n        // now it will move\r\n        this.addPhysicsComponent();\r\n    }\r\n\r\n    animate(deltaTime) {\r\n        const rotationSpeedScale = deltaTime / NORMAL_FRAME_TIME_DELTA;\r\n        this.transform.angle = (this.transform.angle + this.rotation_speed * rotationSpeedScale) % (Math.PI * 2);\r\n    }\r\n\r\n    update(deltaTime){\r\n        this.animate(deltaTime);\r\n        if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\r\n            this.gameEngine.gameScript.bounce(this.transform, this.radius); // HARD CODED\r\n        }\r\n    }\r\n\r\n}\r\n\r\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","import { LineSprite } from \"../../../game_engine/line_sprite\";\r\nexport class PinwheelSprite extends LineSprite {\r\n    constructor(transform, spawningScale = 1) {\r\n        super(transform);\r\n        this.spawningScale = spawningScale;\r\n    }\r\n\r\n    draw(ctx) {\r\n        const spawningScale = this.spawningScale || 1;\r\n        const pos = this.transform.absolutePosition();\r\n        const angle = this.transform.absoluteAngle();\r\n\r\n        const shipWidth = 12 * spawningScale;\r\n        const s = shipWidth / 2;\r\n\r\n        const r = 59;\r\n        const g = 10;\r\n        const b = 87;\r\n\r\n        ctx.save();\r\n        ctx.translate(pos[0], pos[1]);\r\n        ctx.rotate(angle);\r\n\r\n        const blurFactor = 0.5;\r\n        ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\r\n        ctx.shadowBlur = 10 * blurFactor * blurFactor;\r\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\r\n        ctx.lineWidth = 7.5 * blurFactor * blurFactor;\r\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\r\n        this.drawPinwheel(ctx, s);\r\n        ctx.lineWidth = 6 * blurFactor;\r\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.6)\";\r\n        this.drawPinwheel(ctx, s);\r\n        ctx.lineWidth = 4.5;\r\n        this.drawPinwheel(ctx, s);\r\n        ctx.lineWidth = 3;\r\n        this.drawPinwheel(ctx, s);\r\n        ctx.strokeStyle = 'rgb(200, 100, 255)';\r\n        ctx.lineWidth = 1.5;\r\n        this.drawPinwheel(ctx, s);\r\n\r\n        // ctx.strokeStyle = \"#971adf\";\r\n        // ctx.lineWidth = 1.8;\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    drawPinwheel(ctx, s) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, 0);\r\n        ctx.lineTo(0, 0); //1\r\n        ctx.lineTo(-s, -s); //2\r\n        ctx.lineTo(0, -s); //3\r\n        ctx.lineTo(0, 0); //1\r\n        ctx.lineTo(s, -s); //4\r\n        ctx.lineTo(s, 0); //5\r\n        ctx.lineTo(0, 0); //1\r\n        ctx.lineTo(s, s); //6\r\n        ctx.lineTo(0, s); //7\r\n        ctx.lineTo(0, 0); //1\r\n        ctx.lineTo(-s, s); //8\r\n        ctx.lineTo(-s, 0); //9\r\n        // ctx.lineTo(); //1\r\n\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n    }\r\n\r\n\r\n\r\n\r\n}\r\n","import { GameObject } from \"../../../game_engine/game_object\";\r\nimport { Sound } from \"../../../game_engine/sound\";\r\nimport { Util } from \"../../../game_engine/util\";\r\nimport { AlienShipSprite } from \"./alien_ship_sprite\";\r\n\r\nexport class AlienShip extends GameObject {\r\n    constructor(engine, pos, velocity, shipTransform) {\r\n        super(engine);\r\n        this.transform.pos[0] = pos[0];\r\n        this.transform.pos[1] = pos[1];\r\n        this.transform.vel[0] = velocity[0];\r\n        this.transform.vel[1] = velocity[1];\r\n\r\n        this.shipTransform = shipTransform;\r\n        this.radius = 4;\r\n        this.points = 120;\r\n        this.chaseSpeed = 3.5;\r\n        this.chaseAcceleration = 0.125 / 3;\r\n        this.addLineSprite(new AlienShipSprite(this.transform));\r\n        this.addCollider(\"General\", this, this.radius);\r\n        this.addPhysicsComponent();\r\n    }\r\n\r\n    // change to acceleration\r\n   \r\n\r\n    update(timeDelta) {\r\n        // console.log(this.transform.pos)\r\n        this.chase();\r\n\r\n        if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\r\n            this.bounce();\r\n        }\r\n    }\r\n\r\n    bounce() {\r\n        this.gameEngine.gameScript.bounce(this.transform, this.radius);\r\n    }\r\n\r\n    chase() {\r\n        // take current velocity\r\n        // find ideal velocity using max speed, current position, and ship position\r\n        // get unit vector of current position - ship position\r\n        // take difference\r\n        // apply acceleration in that direction\r\n\r\n        // get dV\r\n        //    mV => max speed in the direction it should be moving\r\n        //    Vo => current velocity\r\n        //    dV =  mV - Vo\r\n        //    alpha = dV angle\r\n\r\n        const speed = this.chaseSpeed;\r\n\r\n        const shipPos = this.shipTransform.absolutePosition();\r\n        const pos = this.transform.absolutePosition();\r\n        const deltaPosition = [shipPos[0] - pos[0], shipPos[1] - pos[1]];\r\n        let chaseDirection = Math.atan2(deltaPosition[1], deltaPosition[0]);\r\n\r\n        // Math.atan2 was giving me negative numbers.... when it shouldn't\r\n        if (chaseDirection < 0) {\r\n            chaseDirection = 2 * Math.PI + chaseDirection;\r\n        }\r\n        // console.log(chaseDirection / (2 * Math.PI) * 360)\r\n        const Vm = [speed * Math.cos(chaseDirection), speed * Math.sin(chaseDirection)];\r\n        const Vo = this.transform.vel;\r\n\r\n        const dV = [Vm[0] - Vo[0], Vm[1] - Vo[1]];\r\n        const accelerationDirection = Math.atan2(dV[1], dV[0]);\r\n        this.transform.acc[0] += this.chaseAcceleration * Math.cos(accelerationDirection);\r\n        this.transform.acc[1] += this.chaseAcceleration * Math.sin(accelerationDirection);\r\n        // console.log(this.transform.acc)\r\n    }\r\n\r\n}\r\n\r\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","import { LineSprite } from \"../../../game_engine/line_sprite\";\r\n\r\nexport class AlienShipSprite extends LineSprite {\r\n    constructor(transform) {\r\n        super(transform);\r\n        this.radius = 4;\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.strokeStyle = 'rgb(255, 255, 255)';\r\n        const r = 180;\r\n        const g = 180;\r\n        const b = 255;\r\n\r\n        ctx.save();\r\n\r\n        // ctx.strokeStyle = \"#4286f4\";\r\n        // ctx.lineWidth = 4;\r\n        const blurFactor = 0.5;\r\n\r\n        ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\r\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\r\n        ctx.lineWidth = 4;\r\n        this.drawAlienShip(ctx, this.radius);\r\n        ctx.lineWidth = 3;\r\n        this.drawAlienShip(ctx, this.radius);\r\n        ctx.lineWidth = 2;\r\n        this.drawAlienShip(ctx, this.radius);\r\n        ctx.lineWidth = 1;\r\n        this.drawAlienShip(ctx, this.radius);\r\n        ctx.strokeStyle = 'rgb(255, 255, 255)';\r\n        ctx.lineWidth = 0.75;\r\n        this.drawAlienShip(ctx, this.radius);\r\n        ctx.restore();\r\n    }\r\n\r\n    drawAlienShip(ctx, radius) {\r\n        ctx.beginPath();\r\n        const pos = this.transform.absolutePosition();\r\n        ctx.arc(pos[0], pos[1], radius, 0, 2 * Math.PI, true);\r\n        ctx.stroke();\r\n    }\r\n}","import { GameObject } from \"../../../game_engine/game_object\";\r\nimport { Sound } from \"../../../game_engine/sound\";\r\nimport { Util } from \"../../../game_engine/util\";\r\nimport { ParticleExplosion } from \"../../particles/particle_explosion\";\r\nimport { SingularityHitExplosion } from \"../../particles/singularity_hit_explosion\";\r\nimport { EnemySpawn } from \"../../particles/enemy_spawn\";\r\nimport { SingularitySprite } from \"./singularity_sprite\";\r\nimport { SingularityParticles } from \"../../particles/singularity_particles\";\r\nimport { AlienShip } from \"./alien_ship\";\r\nexport class Singularity extends GameObject {\r\n    constructor(engine, pos) {\r\n        super(engine);\r\n        this.transform.pos = pos;\r\n        this.gravityWellSize = 500;\r\n        this.gravityConstant = 1000 * 0.5;\r\n        this.radius = 15;\r\n        this.points = 100;\r\n        this.throbbingCycleSpeed = 0.025;\r\n        this.numberAbsorbed = 0;\r\n        this.alienSpawnAmount = 10;\r\n        this.alienSpawnSpeed = 1.5;\r\n        this.deathSound = new Sound(\"GEOWars/sounds/Gravity_well_die.wav\");\r\n        this.gravityWellHitSound = new Sound(\"GEOWars/sounds/Gravity_well_hit.wav\", 0.5);\r\n        this.openGateSound = new Sound(\"GEOWars/sounds/Gravity_well_explode.wav\");\r\n        // this.id = options.id\r\n        this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_red.wav\", 1);\r\n        this.playSound(this.spawnSound);\r\n\r\n        this.increasing = true;\r\n        this.addLineSprite(new SingularitySprite(this.transform));\r\n        this.addChildGameObject(new EnemySpawn(this.gameEngine));\r\n        this.lineSprite.throbbingScale = 1;\r\n        this.lives = 5;\r\n    }\r\n\r\n    exist() {\r\n    // leaving off subscriptions means that things will subscribe to it\r\n        this.addCollider(\"General\", this, this.radius);\r\n        this.addCollider(\"GravityWell\", this, this.gravityWellSize, [\"Grunt\", \"Pinwheel\", \"Bullet\", \"Ship\", \"BoxBox\", \"Arrow\", \"Singularity\", \"Weaver\", \"Particle\", \"SingularityParticle\", \"GridPoint\"],  [\"General\"]);\r\n        this.addCollider(\"Absorb\", this, this.radius, [\"Grunt\", \"Pinwheel\", \"BoxBox\", \"Arrow\", \"Weaver\"],  [\"General\"]);\r\n        // now it will move\r\n        this.addPhysicsComponent();\r\n        this.lineSprite.spawned = true;\r\n        this.addChildGameObject(new SingularityParticles(this.gameEngine, this.transform));\r\n    }\r\n\r\n    onCollision(collider, type){\r\n        if (type === \"GravityWell\"){\r\n            this.influenceAcceleration(collider.gameObject);\r\n        } else if (type === \"Absorb\") {\r\n            const hitObjectTransform = collider.gameObject.transform;\r\n            const pos = hitObjectTransform.absolutePosition();\r\n            const vel = hitObjectTransform.absoluteVelocity();\r\n            const explosion = new ParticleExplosion(this.gameEngine, pos, vel);\r\n            collider.gameObject.remove();\r\n\r\n            this.throbbingCycleSpeed *= 1.2;\r\n            this.numberAbsorbed += 1;\r\n        }\r\n    }\r\n\r\n    bulletHit(){\r\n        this.lives -= 1;\r\n        const pos = this.transform.absolutePosition();\r\n        const vel = this.transform.absoluteVelocity();\r\n        if (this.lives <= 0) {\r\n            const explosion = new ParticleExplosion(this.gameEngine, pos, vel);\r\n            this.gameEngine.gameScript.tallyScore(this);\r\n            this.playSound(this.deathSound);\r\n            this.remove();\r\n        } else {\r\n            const explosion = new SingularityHitExplosion(this.gameEngine, pos, vel);\r\n            this.playSound(this.gravityWellHitSound);\r\n            this.throbbingCycleSpeed /= 1.2;\r\n            this.numberAbsorbed -= 1;\r\n        }\r\n    }\r\n\r\n    wallGraze() {\r\n        this.gameEngine.gameScript.wallGraze(this.transform, this.radius);\r\n    }\r\n  \r\n\r\n    update(deltaTime) {\r\n\r\n        if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\r\n            this.wallGraze();\r\n        }\r\n        if (this.numberAbsorbed === 3) {\r\n            this.soundAlarm(deltaTime);\r\n        }\r\n\r\n        this.animate(deltaTime);\r\n        if (this.numberAbsorbed >= 4) {\r\n            this.openGate();\r\n        }\r\n    }\r\n\r\n    soundAlarm(deltaTime){\r\n\r\n    }\r\n\r\n    animate(timeDelta) {\r\n\r\n        const cycleSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\r\n        const cycleSpeed = this.throbbingCycleSpeed;\r\n        // increase scale until 1.2, decrease until 0.8\r\n\r\n        if (this.increasing) {\r\n            this.lineSprite.throbbingScale += cycleSpeed * cycleSpeedScale;\r\n            if (this.lineSprite.throbbingScale > 1.2) {\r\n                this.increasing = !this.increasing;\r\n            }\r\n        } else {\r\n            this.lineSprite.throbbingScale -= cycleSpeed * cycleSpeedScale;\r\n            if (this.lineSprite.throbbingScale < 0.8) {\r\n                this.increasing = !this.increasing;\r\n            }\r\n        }\r\n    }\r\n\r\n    influenceAcceleration(object) {\r\n        const pos = this.transform.absolutePosition();\r\n        const objectPos = object.transform.absolutePosition();\r\n        const dy = pos[1] - objectPos[1];\r\n        const dx = pos[0] - objectPos[0];\r\n        const unitVector = Util.dir([dx, dy]);\r\n        const r = Math.sqrt(dy * dy + dx * dx);\r\n        if (r > this.gravityWellSize * 7 / 8 || r < this.radius * 2){\r\n            // object.transform.acc = [0,0];\r\n        } else {\r\n            const accContribution= [\r\n                unitVector[0] * this.gravityConstant / (r * r),\r\n                unitVector[1] * this.gravityConstant / (r * r)\r\n            ];\r\n            object.transform.acc[0] += accContribution[0];\r\n            object.transform.acc[1] += accContribution[1];\r\n        }\r\n    }\r\n\r\n    openGate(){\r\n        this.playSound(this.openGateSound);\r\n        for (let i = 0; i < this.alienSpawnAmount; i++) {\r\n            const angle = Math.random() * Math.PI * 2;\r\n            const velocity = [this.alienSpawnSpeed * Math.cos(angle), this.alienSpawnSpeed * Math.sin(angle)];\r\n            new AlienShip(this.gameEngine, this.transform.pos, velocity, this.gameEngine.gameScript.ship.transform);\r\n        }\r\n        this.remove();\r\n\r\n    }\r\n\r\n}\r\n\r\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","\r\nimport { LineSprite } from \"../../../game_engine/line_sprite\";\r\nexport class SingularitySprite extends LineSprite {\r\n    constructor(transform, spawningScale = 1) {\r\n        super(transform);\r\n        this.spawningScale = spawningScale;\r\n        this.throbbingScale = 1;\r\n        this.radius = 15;\r\n        this.spawned = false;\r\n    }\r\n\r\n    draw(ctx) {\r\n        let spawningScale = this.spawningScale;\r\n        if (this.spawned) {\r\n            spawningScale = this.throbbingScale;\r\n        }\r\n\r\n        ctx.strokeStyle = \"#F173BA\";\r\n\r\n        const r = 95;\r\n        const g = 45;\r\n        const b = 73;\r\n\r\n        ctx.save();\r\n        // ctx.translate(pos[0], pos[1]);\r\n\r\n        // ctx.strokeStyle = \"#4286f4\";\r\n        // ctx.lineWidth = 4;\r\n        const blurFactor = 0.5;\r\n\r\n        ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\r\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\r\n        ctx.lineWidth = 7.5;\r\n        this.drawSingularity(ctx, this.radius * spawningScale);\r\n        ctx.lineWidth = 6;\r\n        this.drawSingularity(ctx, this.radius * spawningScale);\r\n        ctx.lineWidth = 4.5;\r\n        this.drawSingularity(ctx, this.radius * spawningScale);\r\n        ctx.lineWidth = 3;\r\n        this.drawSingularity(ctx, this.radius * spawningScale);\r\n        ctx.strokeStyle = 'rgb(255, 255, 255)';\r\n        ctx.lineWidth = 1.5;\r\n        this.drawSingularity(ctx, this.radius * spawningScale);\r\n        ctx.restore();\r\n    // ctx.lineWidth = 2;\r\n    // drawSingularity(ctx, this.radius * spawningScale);\r\n    }\r\n\r\n    drawSingularity(ctx, radius) {\r\n        ctx.beginPath();\r\n        const pos = this.transform.absolutePosition();\r\n        ctx.arc(pos[0], pos[1], radius, 0, 2 * Math.PI, true);\r\n        ctx.stroke();\r\n    }\r\n}","\r\nimport { GameObject } from \"../../../game_engine/game_object\";\r\nimport { Sound } from \"../../../game_engine/sound\";\r\nimport { Util } from \"../../../game_engine/util\";\r\nimport { EnemySpawn } from \"../../particles/enemy_spawn\";\r\nimport { WeaverSprite } from \"./weaver_sprite\";\r\n\r\n\r\nexport class Weaver extends GameObject {\r\n    constructor(engine, pos, shipTransform) {\r\n        super(engine);\r\n        this.rotation_speed = 0.075;\r\n        this.transform.pos[0] = pos[0];\r\n        this.transform.pos[1] = pos[1];\r\n        this.speed = 3;\r\n        this.points = 80;\r\n        this.radius = 5;\r\n        this.weaverCloseHitBox = 20;\r\n        this.shipTransform = shipTransform;\r\n        this.directionInfluenced = false;\r\n        this.influencers = [];\r\n        this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_green.wav\", 0.5);\r\n        this.playSound(this.spawnSound);\r\n        this.addLineSprite(new WeaverSprite(this.transform));\r\n        this.addChildGameObject(new EnemySpawn(this.gameEngine));\r\n        this.exists = false;\r\n    \r\n    }\r\n\r\n    exist() {\r\n    // leaving off subscriptions means that things will subscribe to it\r\n        this.addCollider(\"General\", this, this.radius);\r\n        this.addCollider(\"BulletDodge\", this, this.weaverCloseHitBox, [\"Bullet\"], [\"General\"]);\r\n        // now it will move\r\n        this.addPhysicsComponent();\r\n        this.exists = true;\r\n    }\r\n\r\n    onCollision(collider, type){\r\n        if (type === \"BulletDodge\") {\r\n            this.acceptBulletDirection(collider.gameObject.transform.pos);\r\n        }\r\n    }\r\n\r\n    influenceDirection() {\r\n        let directionVector = [0, 0];\r\n\r\n        this.influencers.forEach((influencer) => {\r\n            const dx = directionVector[0] + influencer[0];\r\n            const dy = directionVector[1] + influencer[1];\r\n            const newVector = [dx, dy];\r\n            directionVector = Util.dir(newVector);\r\n        });\r\n        const influencedDirection = Math.atan2(directionVector[1], directionVector[0]);\r\n        return influencedDirection;\r\n    }\r\n\r\n    acceptBulletDirection(source) {\r\n        this.directionInfluenced = true;\r\n        const dy = this.transform.pos[1] - source[1];\r\n        const dx = this.transform.pos[0] - source[0];\r\n        const unitVector = Util.dir([dx, dy]);\r\n        this.influencers.push(unitVector);\r\n    // first \r\n    }\r\n\r\n    animate(timeDelta) {\r\n        const rotationSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\r\n        this.transform.angle = (this.transform.angle + this.rotation_speed * rotationSpeedScale) % (Math.PI * 2);\r\n    }\r\n\r\n    update(timeDelta){\r\n        if(this.exists){\r\n            const speed = this.speed;\r\n            const velocityScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\r\n\r\n            this.animate(timeDelta);\r\n      \r\n      \r\n            if (!this.directionInfluenced) {\r\n                this.chase(timeDelta);\r\n            } else {\r\n                const direction = this.influenceDirection();\r\n                this.transform.pos[0] += speed * Math.cos(direction) * velocityScale;\r\n                this.transform.pos[1] += speed * Math.sin(direction) * velocityScale;\r\n            }\r\n  \r\n            this.directionInfluenced = false;\r\n  \r\n            if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\r\n                this.wallGraze();\r\n            }\r\n        }\r\n    \r\n    }\r\n\r\n    wallGraze() {\r\n        this.gameEngine.gameScript.wallGraze(this.transform, this.radius);\r\n    }\r\n\r\n    chase(timeDelta) {\r\n        const speed = 2;\r\n        const shipPos = this.shipTransform.pos;\r\n        const dy = shipPos[1] - this.transform.pos[1];\r\n        const dx = shipPos[0] - this.transform.pos[0];\r\n\r\n        const velocityScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\r\n        const direction = Math.atan2(dy, dx);\r\n\r\n        this.transform.pos[0] += speed * Math.cos(direction) * velocityScale;\r\n        this.transform.pos[1] += speed * Math.sin(direction) * velocityScale;\r\n    }\r\n\r\n}\r\n\r\nWeaver.BOX_SIZE = 10;\r\nWeaver.COLOR = \"#3cff0b\";\r\n\r\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","import { LineSprite } from \"../../../game_engine/line_sprite\";\r\n\r\nexport class WeaverSprite extends LineSprite {\r\n    constructor(transform, spawningScale = 1) {\r\n        super(transform);\r\n        this.spawningScale = spawningScale;\r\n    }\r\n\r\n    draw(ctx) {\r\n    // drawing this guy is taking waaay too much time.\r\n    // I took out the blurr factor and it's way better.\r\n    // doesn't look as nice, but it's a starting point\r\n        const pos = this.transform.absolutePosition();\r\n        const angle = this.transform.absoluteAngle();\r\n        const spawningScale = this.spawningScale;\r\n        const shipLength = 10 * 2.2 * spawningScale;\r\n        const shipWidth = 10 * 2.2 * spawningScale;\r\n        const s = shipWidth / 2;\r\n\r\n        const r = 24;\r\n        const g = 255;\r\n        const b = 4;\r\n\r\n        ctx.save();\r\n        ctx.translate(pos[0], pos[1]);\r\n        ctx.rotate(angle);\r\n    \r\n        const blurFactor = 0.5;\r\n        ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\r\n        // ctx.shadowBlur = 10 * blurFactor\r\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\r\n        ctx.lineWidth = 7.5;\r\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\r\n        this.drawWeaver(ctx, s);\r\n        ctx.lineWidth = 6;\r\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.6)\";\r\n        this.drawWeaver(ctx, s);\r\n        // ctx.lineWidth = 4.5;\r\n        // this.drawWeaver(ctx, s)\r\n        // ctx.lineWidth = 3;\r\n        // this.drawWeaver(ctx, s)\r\n        ctx.strokeStyle = 'rgb(255, 255, 255)';\r\n        ctx.lineWidth = 1.5;\r\n        this.drawWeaver(ctx, s);\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    drawWeaver(ctx, s) {\r\n\r\n        ctx.beginPath();\r\n        // ctx.strokeStyle = \"#3cff0b\";\r\n        ctx.lineWidth = 2;\r\n        ctx.moveTo(0, -s); //1\r\n        ctx.lineTo(s, 0); //2\r\n        ctx.lineTo(0, s); //3\r\n        ctx.lineTo(-s, 0); //4\r\n        ctx.lineTo(0, -s); //1\r\n        ctx.lineTo(-s / 2, -s / 2); //5\r\n        ctx.lineTo(s / 2, -s / 2); //6\r\n        ctx.lineTo(s / 2, s / 2); //7\r\n        ctx.lineTo(-s / 2, s / 2); //8\r\n        ctx.lineTo(-s / 2, -s / 2); //5\r\n        // ctx.closePath();\r\n        ctx.stroke();\r\n    }\r\n}","\r\nimport { GameObject } from \"../../../game_engine/game_object\";\r\nimport { GridPoint } from \"./grid_point\";\r\nimport { GridSprite } from \"./grid_sprite\";\r\nimport { Util } from \"../../../game_engine/util\";\r\nexport class Grid extends GameObject {\r\n    constructor(engine, gameScript) {\r\n        super(engine);\r\n\r\n        this.transform.pos = [0,0];\r\n\r\n        this.arenaDimensions = [gameScript.DIM_X, gameScript.DIM_Y];\r\n        this.elasticity = 0.1; // force provided to pull particle back into place\r\n        this.dampening = 0.1; // force produced from velocity (allows things to eventuall fall to rest)\r\n\r\n        this.gridPoints = this.createGridPoints();\r\n\r\n        this.addLineSprite(new GridSprite(this.transform, this.gridPoints));\r\n        // this.addPhysicsComponent()\r\n        // this.addCollider(\"General\", this, this.radius)\r\n    }\r\n\r\n    Playerdies(location) {\r\n        this.gridPoints.forEach((row) => {\r\n            row.forEach((gridPoint) => {\r\n                this.deathPerterb(gridPoint, location);\r\n            });\r\n        });\r\n    }\r\n\r\n    deathPerterb(gridPoint, location){\r\n        // pulls inward upon death. 1/r^2\r\n        const pullConstant = 1250;\r\n\r\n        const pos = location;\r\n        const objectPos = gridPoint.transform.absolutePosition();\r\n        const dy = pos[1] - objectPos[1];\r\n        const dx = pos[0] - objectPos[0];\r\n        const unitVector = Util.dir([dx, dy]);\r\n        const r = Math.sqrt(dy * dy + dx * dx);\r\n        if ( r >= 20 ) {\r\n            const velContribution = [\r\n                unitVector[0] * pullConstant / (r ),\r\n                unitVector[1] * pullConstant / (r )\r\n            ];\r\n            gridPoint.transform.vel[0] = velContribution[0];\r\n            gridPoint.transform.vel[1] = velContribution[1];\r\n        }\r\n    }\r\n\r\n    createGridPoints(){\r\n        const columnCount = 20;\r\n        const rowCount = 12;\r\n        const gridPoints = [];\r\n        let gridRow = [];\r\n        for (let yPosition = 0; yPosition <= this.arenaDimensions[1]; yPosition += this.arenaDimensions[1] / rowCount) {\r\n            for (let xPosition = 0; xPosition <= this.arenaDimensions[0]; xPosition += this.arenaDimensions[0] / columnCount) {\r\n                if(\r\n                    (xPosition === 0 && (yPosition === 0 || yPosition === this.arenaDimensions[1])) || \r\n                   (xPosition == this.arenaDimensions[0] && (yPosition === 0 || yPosition === this.arenaDimensions[1])) \r\n                ){\r\n                    continue;\r\n                }\r\n                const position = [xPosition, yPosition];\r\n                gridRow.push(new GridPoint(this.gameEngine, position));\r\n            }\r\n            \r\n            gridPoints.push(gridRow.slice());\r\n            gridRow = [];\r\n        }\r\n        return gridPoints;\r\n    }\r\n\r\n    update(deltaTime) {\r\n\r\n    }\r\n\r\n}","import {GameObject} from \"../../../game_engine/game_object\";\r\n\r\n\r\nexport class GridPoint extends GameObject {\r\n    constructor(engine, pos) {\r\n        super(engine);\r\n        this.origionalPosition = [];\r\n        this.origionalPosition[0] = pos[0];\r\n        this.origionalPosition[1] = pos[1];\r\n        this.transform.pos = pos;\r\n        this.radius = 2;\r\n        this.elasticity = -0.0035; // force provided to pull particle back into place\r\n        this.dampening = -0.04; // force produced from velocity (allows things to eventuall fall to rest)\r\n\r\n        this.addPhysicsComponent();\r\n        this.addCollider(\"General\", this, this.radius);\r\n    }\r\n\r\n    update(deltaTime) {\r\n        this.transform.acc[0] += this.transform.vel[0] * this.dampening + (this.transform.pos[0] - this.origionalPosition[0]) * this.elasticity;\r\n        this.transform.acc[1] += this.transform.vel[1] * this.dampening + (this.transform.pos[1] - this.origionalPosition[1]) * this.elasticity;\r\n    }\r\n\r\n}\r\n","import { LineSprite } from \"../../../game_engine/line_sprite\";\r\nimport { Color } from \"../../../game_engine/color\";\r\n\r\nexport class GridSprite extends LineSprite {\r\n    constructor(transform, gridPoints) {\r\n        super(transform);\r\n        this.gridPoints = gridPoints;\r\n\r\n        this.color = new Color({\r\n            \"hsla\": [202, 100, 70, 0.2]\r\n        });\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.color.evaluateColor();\r\n        ctx.lineWidth = 3;\r\n        this.drawRows(ctx);\r\n        this.drawColumns(ctx);\r\n        ctx.restore();\r\n    }\r\n\r\n    drawRows(ctx) {\r\n        const gridPoints = this.gridPoints;\r\n\r\n        for (let i = 1; i < gridPoints.length - 1; i++) {\r\n            ctx.beginPath();\r\n            const firstPosition = gridPoints[i][0].transform.pos;\r\n            ctx.moveTo(firstPosition[0], firstPosition[1]);\r\n            for (let j = 1; j < gridPoints[i].length; j++) {\r\n                const nextPosition = gridPoints[i][j].transform.pos;\r\n                ctx.lineTo(nextPosition[0], nextPosition[1]);\r\n            }\r\n\r\n            ctx.stroke();\r\n        }\r\n    }\r\n\r\n    drawColumns(ctx) {\r\n        const gridPoints = this.gridPoints;\r\n        ctx.beginPath();\r\n\r\n        for (let j = 1; j < gridPoints[1].length - 1; j++) {\r\n            ctx.beginPath();\r\n            for (let i = 0; i < gridPoints.length; i++) {\r\n                let nextPosition = [];\r\n                if( i === 0 || i === 0) {\r\n                    nextPosition = gridPoints[i][j - 1].transform.pos;\r\n                    ctx.moveTo(nextPosition[0], nextPosition[1]);\r\n                } else {\r\n                    if ( i === gridPoints.length - 1) {\r\n                        nextPosition = gridPoints[i][j - 1].transform.pos;\r\n                    } else {\r\n                        nextPosition = gridPoints[i][j].transform.pos;\r\n                    }\r\n                    ctx.lineTo(nextPosition[0], nextPosition[1]);\r\n                }\r\n\r\n            }\r\n            ctx.stroke();\r\n        }\r\n    }\r\n}","// direction of the particle is the direction of the velocity vector\r\n// the direction of the \r\n// the particle dies when the hue reaches 0 \r\n\r\n// random movement angle created\r\n// initial speed (scale)\r\n// vel = Util.vectorCartesian(angle, scale)\r\n//\r\n// \r\n\r\n// because the particle is drawn the correct way now, \r\n// from position out, the particle's center is located \r\n// far from the center of the particle\r\n\r\nimport {ParticleSprite} from \"./particle_sprite\";\r\nimport { Util } from \"../../../game_engine/util\";\r\nimport { GameObject } from \"../../../game_engine/game_object\";\r\n\r\n\r\n\r\nexport class Particle extends GameObject{\r\n    constructor(engine, pos, initialSpeed, color, wallHit) {\r\n        super(engine);\r\n        this.transform.pos[0] = pos[0];\r\n        this.transform.pos[1] = pos[1];\r\n        this.transform.pos[2] = pos[2];\r\n        this.color = color;\r\n        this.movementAngle = this.createMovementAngle(wallHit); // [plane, out of plane]\r\n        this.transform.vel = Util.vector3Cartesian(this.movementAngle, initialSpeed);\r\n        this.radius = 3;\r\n        this.explosionDeceleration = 0.1; // in the direction the particle is moving\r\n        this.transform.acc = Util.vector3Cartesian(this.movementAngle, -this.explosionDeceleration);\r\n        this.addLineSprite(new ParticleSprite(this.transform, this.color));\r\n        this.addPhysicsComponent();\r\n        // this.addCollider(\"General\", this, this.radius)\r\n    }\r\n\r\n    createMovementAngle(wallHit) {\r\n        if (!wallHit){ \r\n            return [(Math.random() * Math.PI * 2), Math.random() * Math.PI * 2];\r\n        } else {\r\n            if (wallHit === \"BOTTOM\") {\r\n                // need to give second angle still\r\n                return [Math.random() * Math.PI + Math.PI, 0];\r\n            } else if (wallHit === \"RIGHT\") {\r\n                return [Math.random() * Math.PI + Math.PI / 2, 0];\r\n            } else if (wallHit === \"TOP\") {\r\n                return [Math.random() * Math.PI, 0];\r\n            } else if (wallHit === \"LEFT\") {\r\n                return [Math.random() * Math.PI + 3 * Math.PI / 2, 0];\r\n            }\r\n        }\r\n    }\r\n  \r\n\r\n    update(deltaTime){\r\n        this.lineSprite.rectLength -= 0.01 * deltaTime;\r\n        this.lineSprite.color.a -= 0.001 * deltaTime;\r\n        if (this.lineSprite.hue < 0.06 || this.lineSprite.rectLength < 0.25 || ((Math.abs(this.transform.vel[0]) + Math.abs(this.transform.vel[1])) < 0.15)) {\r\n      \r\n            this.remove();\r\n        }\r\n        this.checkBounds();\r\n        // acc is influenced by singularities, then changed to usual acc\r\n        this.movementAngle = Math.atan2(this.transform.vel[1], this.transform.vel[0]);\r\n        this.transform.acc = [-this.explosionDeceleration * Math.cos(this.movementAngle), -this.explosionDeceleration * Math.sin(this.movementAngle)];\r\n    }\r\n\r\n    checkBounds() {\r\n        if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), -0.5)) {\r\n            this.remove();\r\n        }\r\n    }\r\n\r\n}","import { LineSprite } from \"../../../game_engine/line_sprite\";\r\n\r\nexport class ParticleSprite extends LineSprite {\r\n    constructor(transform, color) {\r\n        super(transform);\r\n        this.rectLength = 15;\r\n        this.rectWidth = 2;\r\n        this.color = color;\r\n    }\r\n\r\n    draw(ctx) {\r\n        const pos = this.transform.absolutePosition();\r\n        const vel = this.transform.absoluteVelocity();\r\n        const l = this.rectLength;\r\n        const w = this.rectWidth;\r\n        const movementDirection = Math.atan2(vel[0], -vel[1]);\r\n\r\n        ctx.save();\r\n        ctx.translate(pos[0], pos[1]);\r\n        ctx.rotate(movementDirection - Math.PI);\r\n\r\n        ctx.beginPath();\r\n        ctx.strokeStyle = this.color.evaluateColor();\r\n        ctx.lineWidth = w;\r\n\r\n        ctx.moveTo(0, 0); //1\r\n        ctx.lineTo(0, l); //2\r\n\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n}\r\n","// direction of the particle is the direction of the velocity vector\r\n// the direction of the \r\n// the particle dies when the hue reaches 0 \r\n\r\n// random movement angle created\r\n// initial speed (scale)\r\n// vel = Util.vectorCartesian(angle, scale)\r\n//\r\n\r\nimport {Particle} from \"../Particle/particle\";\r\n\r\nexport class SingularityParticle extends Particle {\r\n    constructor(engine, pos, vel, color) {\r\n        super(engine, pos, 0, color);\r\n\r\n        this.transform.vel[0] = vel[0];\r\n        this.transform.vel[1] = vel[1];\r\n\r\n        this.color = color;\r\n        this.addCollider(\"General\", this, this.radius);\r\n        this.checkBounds();\r\n    }\r\n\r\n    update(deltaTime) {\r\n    \r\n        this.lineSprite.rectLength -= 0.25;\r\n        this.lineSprite.color.a -= 0.01;\r\n        if (this.lineSprite.color.a < 0.06 || this.lineSprite.rectLength < 0.25) {\r\n            this.parentObject.currentParticleCount -= 1;\r\n            this.remove();\r\n        }\r\n        // acc is influenced by singularities, then changed to usual acc\r\n        this.movementAngle = Math.atan2(this.transform.vel[1], this.transform.vel[0]);\r\n        this.transform.acc = [0,0];\r\n        this.checkBounds();\r\n    }\r\n    checkBounds() {\r\n        if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), -0.5)) {\r\n            this.remove();\r\n        }\r\n    }\r\n\r\n}\r\n","\r\n\r\nimport {Particle} from \"./Particle/particle\";\r\nimport {GameObject} from \"../../game_engine/game_object\";\r\nimport {Sound} from \"../../game_engine/sound\";\r\nimport {Color} from \"../../game_engine/color\";\r\nexport class BulletWallExplosion extends GameObject{\r\n    constructor(engine, pos) {\r\n        super(engine);\r\n        this.transform.pos[0] = pos[0];\r\n        this.transform.pos[1] = pos[1];\r\n        const startingH = (this.gameEngine.gameScript.explosionColorWheel + 180 + Math.random() * 60) % 360;\r\n        const opacity = Math.random() * 0.35 + 0.6;\r\n        this.currentColor = new Color({\r\n            \"hsla\": [startingH, 100, 50, opacity]\r\n        });\r\n        this.particleNum = 20;\r\n        const bulletWallHit = new Sound(\"GEOWars/sounds/bullet_hitwall.wav\", 0.1);\r\n        this.wallHit = this.whichWall();\r\n        this.playSound(bulletWallHit);\r\n        this.createParticles();\r\n    }\r\n\r\n    whichWall() {\r\n        const pos = this.transform.pos;\r\n\r\n        const max = [this.gameEngine.gameScript.DIM_X, this.gameEngine.gameScript.DIM_Y];\r\n        if (pos[0] <= 0) {\r\n            return \"LEFT\";\r\n        } else if (pos[0] >= max[0]) {\r\n            return \"RIGHT\";\r\n        } else if (pos[1] <= 0) {\r\n            return \"TOP\";\r\n        } else if (pos[1] >= max[1]) {\r\n            return \"BOTTOM\";\r\n        }\r\n\r\n    }\r\n\r\n    createParticles(){\r\n        for (var i = 0; i < this.particleNum; i++) {\r\n            const colorVarienceDelta = 30;\r\n            const speed = 1 + Math.random() * 3;\r\n            const colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2;\r\n            const color = this.currentColor.dup();\r\n            color.a = Math.random() * 0.35 + 0.6;\r\n            color.h = (color.h + colorVarience) % 360;\r\n\r\n            const x = this.transform.absolutePosition()[0];\r\n            const y = this.transform.absolutePosition()[1];\r\n            const z = 0;\r\n      \r\n            this.addChildGameObject(new Particle(this.gameEngine, [x,y,z], speed, color, this.wallHit));\r\n        }\r\n    }\r\n\r\n    update() {\r\n    \r\n        if (this.childObjects.length === 0) {\r\n            this.remove();\r\n        }\r\n    }\r\n}\r\n","import { GameObject } from \"../../game_engine/game_object\";\r\n\r\nexport class EnemySpawn extends GameObject{\r\n    constructor(engine){\r\n        super(engine);\r\n        this.initialSpawningScale = 1.5;\r\n        // this.spawningScale = 1.5;\r\n        this.lifeTime = 1000;\r\n        this.existTime = 0;\r\n    // this.gameEngine.queueSound(this.parentObject.spawnSound)\r\n    }\r\n\r\n    update(timeDelta) {\r\n        this.existTime += timeDelta;\r\n        if (this.existTime >= this.lifeTime){\r\n      \r\n            this.parentObject.exist();\r\n            this.parentObject.lineSprite.spawningScale = 1;\r\n            this.remove();\r\n        }\r\n\r\n        const cycleSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\r\n        const cycleSpeed = 0.1;\r\n    \r\n        if (this.parentObject.lineSprite.spawningScale < 0.7){\r\n            this.parentObject.lineSprite.spawningScale = this.initialSpawningScale;\r\n        } else {\r\n            this.parentObject.lineSprite.spawningScale -= cycleSpeed * cycleSpeedScale;\r\n        }\r\n    }\r\n}\r\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","import {Particle} from \"./Particle/particle\";\r\nimport {GameObject} from \"../../game_engine/game_object\";\r\nimport {Sound} from \"../../game_engine/sound\";\r\nimport {Color} from \"../../game_engine/color\";\r\n\r\nexport class ParticleExplosion extends GameObject{\r\n    constructor(engine, pos){\r\n        super(engine);\r\n        this.transform.pos[0] = pos[0];\r\n        this.transform.pos[1] = pos[1];\r\n        const startingH = (this.gameEngine.gameScript.explosionColorWheel + Math.random() * 60)% 360;\r\n        const opacity = Math.random() * 0.35 + 0.6;\r\n        this.currentColor = new Color({\r\n            \"hsla\": [startingH, 100, 50, opacity]\r\n        });\r\n        if (engine.graphicQuality === 1) {\r\n            // console.log(\"best\")\r\n            this.particleNum = 80;\r\n        } else if (engine.graphicQuality === 2){\r\n            // console.log(\"medium\")\r\n            this.particleNum = 40;\r\n        } else {\r\n            // console.log(\"potato\")\r\n            this.particleNum = 20;\r\n        }\r\n\r\n        const explosionSound = new Sound(\"GEOWars/sounds/Enemy_explode.wav\", 0.2);\r\n        this.playSound(explosionSound);\r\n        this.createExplosionParticles();\r\n    }\r\n\r\n    createExplosionParticles(){\r\n        for (var i = 0; i < this.particleNum; i++) {\r\n            const speed = Math.random() * 3 + 4;\r\n      \r\n            const colorVarienceDelta = 30;\r\n            const colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2;\r\n            const color = this.currentColor.dup();\r\n            color.a = Math.random() * 0.35 + 0.6;\r\n            color.h = (color.h + colorVarience) % 360;\r\n            \r\n            const x = this.transform.absolutePosition()[0];\r\n            const y = this.transform.absolutePosition()[1];\r\n            const z = 0;\r\n            this.addChildGameObject(new Particle(this.gameEngine, [x,y,z], speed, color));\r\n        }\r\n    }\r\n\r\n    update(){\r\n        if (this.childObjects.length === 0){\r\n            this.remove();\r\n        }\r\n    }\r\n    // ANIMATION = requestAnimationFrame(drawScene);\r\n}\r\n","import { Particle } from \"./Particle/particle\";\r\nimport { GameObject } from \"../../game_engine/game_object\";\r\nimport { Sound } from \"../../game_engine/sound\";\r\nimport { Color } from \"../../game_engine/color\";\r\nexport class ShipExplosion extends GameObject {\r\n    constructor(engine, pos) {\r\n        super(engine);\r\n        this.transform.pos[0] = pos[0];\r\n        this.transform.pos[1] = pos[1];\r\n        const startingH = (this.gameEngine.gameScript.explosionColorWheel + Math.random() * 60) % 360;\r\n        const opacity = Math.random() * 0.35 + 0.6;\r\n        this.currentColor = new Color({\r\n            \"hsla\": [startingH, 100, 50, opacity]\r\n        });\r\n        this.particleNum = 400;\r\n        const explosionSound = new Sound(\"GEOWars/sounds/Enemy_explode.wav\", 0.2);\r\n        this.playSound(explosionSound);\r\n        this.createExplosionParticles();\r\n    }\r\n\r\n    createExplosionParticles() {\r\n        for (var i = 0; i < this.particleNum; i++) {\r\n            const speed = Math.random() * 10 + 4;\r\n\r\n            const colorVarienceDelta = 30;\r\n            const colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2;\r\n            const color = this.currentColor.dup();\r\n            // color.a = Math.random() * 0.35 + 0.6\r\n            // color.h = (color.h + colorVarience) % 360\r\n\r\n            this.addChildGameObject(new Particle(this.gameEngine, this.transform.absolutePosition(), speed, color));\r\n        }\r\n    }\r\n\r\n    update() {\r\n        if (this.childObjects.length === 0) {\r\n            this.remove();\r\n        }\r\n    }\r\n    // ANIMATION = requestAnimationFrame(drawScene);\r\n}\r\n","import { Particle } from \"./Particle/particle\";\r\nimport { GameObject } from \"../../game_engine/game_object\";\r\nimport { Sound } from \"../../game_engine/sound\";\r\nimport { Color } from \"../../game_engine/color\";\r\nexport class SingularityHitExplosion extends GameObject {\r\n    constructor(engine, pos) {\r\n        super(engine);\r\n        this.transform.pos[0] = pos[0];\r\n        this.transform.pos[1] = pos[1];\r\n        const startingH = (this.gameEngine.gameScript.explosionColorWheel + Math.random() * 60 + 180) % 360;\r\n        const opacity = Math.random() * 0.35 + 0.3;\r\n        this.currentColor = new Color({\r\n            \"hsla\": [startingH, 100, 50, opacity]\r\n        });\r\n        if (engine.graphicQuality === 1) {\r\n            // console.log(\"best\")\r\n            this.particleNum = 50;\r\n        } else if (engine.graphicQuality === 2) {\r\n            // console.log(\"medium\")\r\n            this.particleNum = 30;\r\n        } else {\r\n            // console.log(\"potato\")\r\n            this.particleNum = 15;\r\n        }\r\n        // find singularity hit sound\r\n        const explosionSound = new Sound(\"GEOWars/sounds/Enemy_explode.wav\", 0.2);\r\n        this.playSound(explosionSound);\r\n        this.createExplosionParticles();\r\n    }\r\n\r\n    createExplosionParticles() {\r\n        for (var i = 0; i < this.particleNum; i++) {\r\n            // adjust speed\r\n            const speed = Math.random() * 3 + 2.5;\r\n\r\n            const colorVarienceDelta = 30;\r\n            const colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2;\r\n            const color = this.currentColor.dup();\r\n            color.a = Math.random() * 0.35 + 0.6;\r\n            color.h = (color.h + colorVarience) % 360;\r\n\r\n            this.addChildGameObject(new Particle(this.gameEngine, this.transform.absolutePosition(), speed, color));\r\n        }\r\n    }\r\n\r\n    update() {\r\n        if (this.childObjects.length === 0) {\r\n            this.remove();\r\n        }\r\n    }\r\n    // ANIMATION = requestAnimationFrame(drawScene);\r\n}\r\n","import { GameObject } from \"../../game_engine/game_object\";\r\nimport { Util } from \"../../game_engine/util\";\r\nimport { SingularityParticle } from \"./Singularity_Particle/singularity_particle\";\r\nimport { Color } from \"../../game_engine/color\";\r\n\r\nexport class SingularityParticles extends GameObject {\r\n    constructor(engine, transform) {\r\n        super(engine);\r\n        this.transform = transform;\r\n        const startingH = Math.random() * 360;\r\n        const opacity = Math.random() * 0.35 + 0.6;\r\n        this.frequencyParticleCreation = 10;\r\n        this.particleCreationTime = 0;\r\n        this.currentColor = new Color({\r\n            \"hsla\": [startingH, 100, 50, opacity]\r\n        });\r\n\r\n        this.particleNum = 80;\r\n        this.currentParticleCount = 0;\r\n        // let explosionSound = new Sound(\"GEOWars/sounds/Enemy_explode.wav\", 0.2)\r\n        this.createSingularityParticles();\r\n    \r\n    }\r\n\r\n    createSingularityParticles() {\r\n    \r\n        for (var i = 0; i < this.particleNum; i++) {\r\n            this.addSingularityParticle();\r\n            this.currentParticleCount++;\r\n        }\r\n    }\r\n\r\n    addSingularityParticle(){\r\n        const L = 70;\r\n        const length = 0;\r\n        const baseSpeed = 3;\r\n\r\n        const distanceVarienceDelta = 15;\r\n        const colorVarienceDelta = 10;\r\n        const angleVarienceDelta = Math.PI / 4;\r\n        const speedVarienceDelta = 2;\r\n\r\n        const distanceVarience = distanceVarienceDelta * Math.random() - distanceVarienceDelta / 2;\r\n        const colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2;\r\n        const angleVarience = angleVarienceDelta * Math.random() - angleVarienceDelta / 2;\r\n        const speedVarience = speedVarienceDelta * Math.random() - speedVarienceDelta / 2;\r\n\r\n        const r = L + distanceVarience;\r\n        const theta = Math.random() * 2 * Math.PI;\r\n        const alpha = theta + Math.PI / 2 +  angleVarience;\r\n        const speed = baseSpeed + speedVarience;\r\n\r\n        const pos = [r * Math.cos(theta) + this.transform.pos[0], r * Math.sin(theta) + this.transform.pos[1]];\r\n        const vel = [speed * Math.cos(alpha) + this.transform.vel[0], speed * Math.sin(alpha) + this.transform.vel[1]];\r\n        const color = this.currentColor.dup();\r\n\r\n        color.a = Math.random() * 0.19 + 0.8;\r\n        color.h = (color.h + colorVarience) % 360;\r\n\r\n        this.addChildGameObject(new SingularityParticle(this.gameEngine, pos, vel, color));\r\n    }\r\n\r\n    changeCurrentColor(){\r\n        this.currentColor.h += 1 / 2;\r\n        this.currentColor.h = this.currentColor.h % 360;\r\n    }\r\n\r\n    update(timeDelta) {\r\n        this.particleCreationTime += timeDelta;\r\n        if (this.particleCreationTime > this.frequencyParticleCreation){\r\n            this.particleCreationTime = 0;\r\n            if (this.currentParticleCount < 60){\r\n                this.addSingularityParticle();\r\n            }\r\n        }\r\n        this.changeCurrentColor();\r\n    }\r\n    // ANIMATION = requestAnimationFrame(drawScene);\r\n}\r\n","import { GameObject } from \"../../game_engine/game_object\";\r\nimport { LineSprite } from \"../../game_engine/line_sprite\";\r\n\r\nexport class Star extends GameObject {\r\n    constructor(engine, pos = [0,0,0], cameraTransform) {\r\n        super(engine);\r\n        this.transform.pos[0] = pos[0];\r\n        this.transform.pos[1] = pos[1];\r\n        this.transform.pos[2] = pos[2];\r\n        this.transform.cameraTransform = cameraTransform;\r\n        this.addLineSprite(new StarSprite(this.transform));\r\n        // add random good colors\r\n    }\r\n}\r\n\r\nexport class StarSprite extends LineSprite {\r\n    constructor(transform) {\r\n        super(transform);\r\n        this.radius = Math.random() * 2 + 0.25; // 1 - 3\r\n    }\r\n    draw(ctx) {\r\n        const pos = this.transform.absolutePosition();\r\n        const radius = this.transform.absoluteLength(this.radius);\r\n        const r = 255;\r\n        const g = 255;\r\n        const b = 255;\r\n        ctx.save();\r\n        ctx.translate(pos[0], pos[1]);\r\n        ctx.strokeStyle = \"rgb(255, 255, 255)\";\r\n        ctx.fillStyle = \"rgb(255, 255, 255)\";\r\n        this.drawStar(ctx, radius, pos);\r\n        ctx.restore();\r\n    }\r\n    drawStar(ctx, radius, pos) {\r\n        const r = radius;\r\n        ctx.lineWidth = 1;\r\n        ctx.beginPath();\r\n        ctx.arc(pos[0], pos[1], r, 0, 2 * Math.PI, true);\r\n        ctx.fill();\r\n    }\r\n}","import { GameObject } from \"../../game_engine/game_object\";\r\nimport { Sound } from \"../../game_engine/sound\";\r\nimport { ShipSprite } from \"./ship_sprite\";\r\nimport { Bullet } from \"../Bullet/bullet\";\r\nimport { Transform } from \"../../game_engine/transform\";\r\n\r\nexport class Ship extends GameObject {\r\n    constructor(engine, pos, initialCameraZPos) { \r\n        super(engine);\r\n        this.transform.pos = pos;\r\n        this.cameraTransform = new Transform();\r\n        this.cameraTransform.pos = [pos[0], pos[1], initialCameraZPos];\r\n        this.addPhysicsComponent();\r\n        this.addMousePosListener();\r\n        this.addLeftControlStickListener();\r\n        this.addRightControlStickListener();\r\n        this.addStartButtonListener();\r\n        this.radius = 10;\r\n        this.addCollider(\"General\", this, this.radius);\r\n        this.addCollider(\"ShipDeath\", this, this.radius, [\"BoxBox\", \"Singularity\", \"Weaver\", \"Grunt\", \"Arrow\", \"Pinwheel\", \"AlienShip\"], [\"General\"]);\r\n        this.addLineSprite(new ShipSprite(this.transform));\r\n        this.maxSpeed = 2.5;\r\n        this.mousePos = [0,0];\r\n        this.fireAngle = 0;\r\n        this.bulletSound = new Sound(\"GEOWars/sounds/Fire_normal.wav\", 0.2);\r\n        this.upgradeBulletsSound = new Sound(\"GEOWars/sounds/Hi_Score_achieved.wav\");\r\n        this.bulletTimeCheck = 0;\r\n        this.bulletInterval = 120;\r\n        this.controlsDirection = [0,0];\r\n        this.powerLevel = 1;\r\n        this.bulletNumber = 0;\r\n        this.controlsPointing = true;\r\n        this.speed;\r\n        this.shipEngineAcceleration = 0.125;\r\n        this.dontShoot = false;\r\n\r\n        this.keysPressed = [];\r\n        this.pauseKeyedUp = true;\r\n        this.zooming = true;\r\n\r\n        this.spawning = true;\r\n        this.spawningTime = 0;\r\n        this.flashingTime = 0;\r\n        this.flashTime = 1000 / 8;\r\n        this.flashing = true;\r\n        this.flashIntervalTime = 0;\r\n        this.flashInterval = 250 - 1000 / 8;\r\n        this.spawnTime = 2500;\r\n        this.lineSprite.flashHide = true;\r\n        this.controllerInUse = false;\r\n        this.gameEditorHasBeenOpened = false;\r\n    // 1/8 of a second flash every half second\r\n    }\r\n\r\n  \r\n    update(deltaTime){\r\n        if(this.gameEngine.gameEditorOpened) {\r\n            if(!this.gameEditorHasBeenOpened) {\r\n                const _width = this.gameEngine.gameScript.DIM_X;\r\n                const _height = this.gameEngine.gameScript.DIM_Y;\r\n                const _zoomScale = this.gameEngine.zoomScale;\r\n                const _yPosition = this.transform.pos[1];\r\n                const _xPosition = this.transform.pos[0];\r\n                console.log({_width, _height, _zoomScale, _xPosition, _yPosition});\r\n                this.gameEngine.ctx.translate(\r\n                    ((_xPosition*_zoomScale - _width/(2))) ,\r\n                    ((_yPosition*_zoomScale - _height/(2)))\r\n                );\r\n                this.gameEngine.zoomScale = 1;\r\n            }\r\n            this.gameEditorHasBeenOpened = true;\r\n            return;\r\n        } else {\r\n            this.gameEditorHasBeenOpened = false;\r\n        }\r\n        this.bulletTimeCheck += deltaTime;\r\n\r\n        // game state stuff that doesn't belong in the ship #gamestate\r\n        if (this.bulletTimeCheck >= this.bulletInterval && !this.spawning && this.controlsPointing && !this.dontShoot) {\r\n            this.bulletNumber += 1;\r\n            this.bulletTimeCheck = 0;\r\n            this.fireBullet();\r\n        } \r\n\r\n        if (this.spawning){\r\n\r\n            this.spawningTime += deltaTime;\r\n            if (this.flashing) {\r\n                this.flashingTime += deltaTime;\r\n                if (this.flashingTime > this.flashTime) {\r\n                    this.flashingTime = 0;\r\n                    this.flashing = false;\r\n                    this.lineSprite.flashHide = false;\r\n                } \r\n            } else {\r\n                this.flashIntervalTime += deltaTime;\r\n                if (this.flashIntervalTime > this.flashInterval) {\r\n                    this.flashIntervalTime = 0;\r\n                    this.flashing = true;\r\n                    this.lineSprite.flashHide = true;\r\n                } \r\n            }\r\n\r\n            if (this.spawningTime > this.spawnTime) {\r\n                this.spawning = false;\r\n                this.flashing = false;\r\n                this.lineSprite.flashHide = false;\r\n                this.spawningTime = 0;\r\n                this.flashIntervalTime = 0;\r\n                this.flashingTime = 0;\r\n            }\r\n      \r\n        }\r\n\r\n        // this.moveInControllerDirection(deltaTime)\r\n\r\n        if (this.isOutOfBounds()) {\r\n            this.wallGraze();\r\n        } else {\r\n            this.movementMechanics(deltaTime);\r\n      \r\n        }\r\n        // if ship is out of x bounds, maintain y speed, keep x at edge value\r\n\r\n        this.updateZoomScale();\r\n\r\n        // stuff that belongs in camera #camera\r\n        this.gameEngine.ctx.restore();\r\n        this.gameEngine.ctx.save();\r\n        const shipXPos = this.transform.pos[0];\r\n        const shipYPos = this.transform.pos[1];\r\n        const zoomScale = this.gameEngine.zoomScale;\r\n        const width = this.gameEngine.gameScript.DIM_X;\r\n        const height = this.gameEngine.gameScript.DIM_Y;\r\n\r\n        this.cameraTransform.pos[0] = shipXPos;\r\n        this.cameraTransform.pos[1] = shipYPos;\r\n        // this.cameraTransform.pos[2] = based on zoomScale\r\n\r\n        this.gameEngine.ctx.translate(\r\n            -shipXPos * zoomScale + width / 2,\r\n            -shipYPos * zoomScale + height / 2\r\n        );\r\n    }\r\n\r\n    upgradeBullets() {\r\n        if (this.powerLevel != 2) {\r\n            this.powerLevel = 2;\r\n            this.playSound(this.upgradeBulletsSound);\r\n        }\r\n    }\r\n  \r\n    findSmallestDistanceToAWall(){\r\n        const pos = this.transform.pos;\r\n        const leftDistance = pos[0] - 0;\r\n        const rightDistance = this.gameEngine.gameScript.DIM_X - pos[0];\r\n        const upDistance = pos[1] - 0;\r\n        const downDistance = this.gameEngine.gameScript.DIM_Y - pos[1];\r\n        const distances = [leftDistance, rightDistance, upDistance, downDistance];\r\n        return Math.min.apply(null, distances); \r\n    }\r\n\r\n    updateZoomScale(){\r\n        const distanceToZoomChange = 100;\r\n        const smallestZoomScale = 0.75; // of the origional zoomscale\r\n        const smallest = this.findSmallestDistanceToAWall();\r\n        if (smallest < distanceToZoomChange) {\r\n            this.gameEngine.zoomScale = this.gameEngine.defaultZoomScale * (smallest / distanceToZoomChange * (1 - smallestZoomScale) + smallestZoomScale);\r\n        } else {\r\n            this.gameEngine.zoomScale = this.gameEngine.defaultZoomScale;\r\n        }\r\n\r\n        // this should also update the camera's Z position\r\n    }\r\n\r\n    // \r\n    calcControlsDirection(){\r\n    \r\n        this.controlsDirection = [0,0];\r\n        this.keysPressed.forEach((key) => {\r\n            this.controlsDirection[0] += Ship.MOVES[key][0];\r\n            this.controlsDirection[1] += Ship.MOVES[key][1];\r\n        });\r\n    }\r\n\r\n    movementMechanics(deltaTime) {\r\n    // get dV\r\n    //    mV => max speed in the direction of the controller\r\n    //    Vo => current velocity\r\n    //    dV~ =  mV - Vo\r\n    // if dv~ > 0.2 (or something)\r\n    //    a = ma~ \r\n        if (!this.controllerInUse) {\r\n            this.calcControlsDirection();\r\n        }\r\n\r\n        const movementAngle = Math.atan2(this.controlsDirection[1], this.controlsDirection[0]);\r\n        const Vo = this.transform.absoluteVelocity();\r\n        let mV = [];\r\n\r\n        if(this.controlsDirection[0] == 0 && this.controlsDirection[1] == 0){\r\n            mV = [0, 0];\r\n        } else {\r\n            mV = [this.maxSpeed * Math.cos(movementAngle), this.maxSpeed * Math.sin(movementAngle)];\r\n            this.transform.angle = movementAngle;\r\n        }\r\n\r\n        const dV = [mV[0] - Vo[0], mV[1] - Vo[1]];\r\n        const alpha = Math.atan2(dV[1], dV[0]);\r\n\r\n        this.transform.acc[0] += this.shipEngineAcceleration * Math.cos(alpha);\r\n        this.transform.acc[1] += this.shipEngineAcceleration * Math.sin(alpha);\r\n    }\r\n\r\n    isOutOfBounds(){\r\n        return this.gameEngine.gameScript.isOutOfBounds(this.transform.pos, this.radius);\r\n    }\r\n\r\n    updateMousePos(mousePos){\r\n        this.setFireAngle(mousePos);\r\n    }\r\n\r\n    updateRightControlStickInput(vector) {\r\n        if (Math.abs(vector[0]) + Math.abs(vector[1]) > 0.10) {\r\n            this.dontShoot = false;\r\n            this.fireAngle = Math.atan2(vector[1], vector[0]);\r\n        } else {\r\n            this.dontShoot = true;\r\n        }\r\n    }\r\n\r\n    updateLeftControlStickInput(key, down = true) {\r\n        if(typeof key === \"string\"){\r\n            // accelerates to V = [0,0] when not pressed\r\n            if (down) {\r\n                if (!this.keysPressed.includes(key)) {\r\n                    this.keysPressed.push(key);\r\n                }\r\n\r\n                // this.controlsDirection[0] += unitVector[0]\r\n                // this.controlsDirection[1] += unitVector[1]\r\n            } else {\r\n                if (this.keysPressed.includes(key)) {\r\n                    this.keysPressed.splice(this.keysPressed.indexOf(key), 1);\r\n                }\r\n\r\n                // this.controlsDirection[0] -= unitVector[0]\r\n                // this.controlsDirection[1] -= initVector[1]\r\n            }\r\n        } else {\r\n            this.controllerInUse = true;\r\n            if (Math.abs(key[0]) + Math.abs(key[1]) > 0.10) {\r\n                this.controlsDirection = key;\r\n            } else {\r\n                this.controlsDirection = [0,0];\r\n            }\r\n        }\r\n    } \r\n    // Refactor into game engine and game script\r\n    updateStartButtonListener(key, down){\r\n        if (typeof key === \"string\"){\r\n            if(down){\r\n                if(this.pauseKeyedUp){\r\n                    this.pauseKeyedUp = false;\r\n                    if (this.gameEngine.paused && !this.gameEngine.muted) {\r\n                        this.gameEngine.gameScript.theme.play();\r\n                    }\r\n                    this.gameEngine.togglePause();\r\n                }\r\n            } else {\r\n                this.pauseKeyedUp = true;\r\n            }\r\n        } else if(key[0]) {\r\n            if (this.pauseKeyedUp){\r\n                this.pauseKeyedUp = false;\r\n                if (this.gameEngine.paused && !this.gameEngine.muted) {\r\n                    this.gameEngine.gameScript.theme.play();\r\n                }\r\n                this.gameEngine.togglePause();\r\n            }\r\n        } else {\r\n            this.pauseKeyedUp = true;\r\n        }\r\n    }\r\n\r\n    wallGraze() {\r\n        this.gameEngine.gameScript.wallGraze(this.transform, this.radius * 2);\r\n    }\r\n\r\n    onCollision(collider, type) {\r\n        if (type === \"ShipDeath\") {\r\n  \r\n            this.gameEngine.gameScript.death();\r\n            this.deathflash();\r\n        }\r\n    }\r\n\r\n    deathflash() {\r\n        this.spawning = true;\r\n        this.flashing = true;\r\n    }\r\n\r\n    setFireAngle(mousePos) {\r\n    \r\n        if (mousePos === undefined){\r\n            mousePos = this.mousePos;\r\n        } else {\r\n            this.mousePos = mousePos;\r\n        }\r\n        const shipXPos = this.transform.pos[0];\r\n        const shipYPos = this.transform.pos[1];\r\n        const zoomScale = this.gameEngine.zoomScale;\r\n        const width = this.gameEngine.gameScript.DIM_X;\r\n        const height = this.gameEngine.gameScript.DIM_Y;\r\n\r\n        const mouseX = mousePos[0] / zoomScale + shipXPos  - width / (2 * zoomScale);\r\n        const mouseY = mousePos[1] / zoomScale + shipYPos  - height / (2 * zoomScale);\r\n        // SCALE NUMBER\r\n        const dy =  mouseY - this.transform.pos[1];\r\n        const dx =  mouseX - this.transform.pos[0];\r\n        this.fireAngle =  Math.atan2(dy, dx);\r\n    }\r\n\r\n    fireBullet() {\r\n    \r\n        this.gameEngine.queueSound(this.bulletSound);\r\n        const shipvx = this.transform.vel[0];\r\n        const shipvy = this.transform.vel[1];\r\n\r\n        const relBulletVelX1 = Bullet.SPEED * Math.cos(this.fireAngle);\r\n        const relBulletVelY1 = Bullet.SPEED * Math.sin(this.fireAngle);\r\n\r\n        const bulletVel1 = [shipvx + relBulletVelX1, shipvy + relBulletVelY1];\r\n        this.addChildGameObject(new Bullet(this.gameEngine, this.transform.pos, bulletVel1, this.bulletNumber));\r\n\r\n        if (this.powerLevel === 2) {\r\n\r\n            const relBulletVelX2 = (Bullet.SPEED - 0.5) * Math.cos(this.fireAngle + Math.PI / 32);\r\n            const relBulletVelY2 = (Bullet.SPEED - 0.5) * Math.sin(this.fireAngle + Math.PI / 32);\r\n            const relBulletVelX3 = (Bullet.SPEED - 0.5) * Math.cos(this.fireAngle - Math.PI / 32);\r\n            const relBulletVelY3 = (Bullet.SPEED - 0.5) * Math.sin(this.fireAngle - Math.PI / 32);\r\n\r\n            const bulletVel2 = [shipvx + relBulletVelX2, shipvy + relBulletVelY2];\r\n            const bulletVel3 = [shipvx + relBulletVelX3, shipvy + relBulletVelY3];\r\n            // doesn't support parent transformations... yet\r\n            this.addChildGameObject(new Bullet(this.gameEngine, this.transform.pos, bulletVel2));\r\n            this.addChildGameObject(new Bullet(this.gameEngine, this.transform.pos, bulletVel3));\r\n        }\r\n    }\r\n\r\n\r\n    // implement threshold so it's not too sensitive\r\n\r\n  \r\n\r\n    relocate() {\r\n    // this.GameScript.die();\r\n    // this.transform.pos = this.game.randomPosition();\r\n    // this.vel = [0, 0];\r\n    // this.acc = [0, 0];\r\n    }\r\n}\r\n\r\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\r\n\r\nShip.MOVES = {\r\n    s: [0, 1],\r\n    a: [-1, 0],\r\n    w: [0, -1],\r\n    d: [1, 0],\r\n};\r\n\r\n","import { LineSprite } from \"../../game_engine/line_sprite\";\r\n\r\nexport class ShipSprite extends LineSprite {\r\n    constructor(transform, spawningScale = 1) {\r\n        super(transform);\r\n        this.spawningScale = spawningScale;\r\n        this.flashHide = false;\r\n    }\r\n\r\n    draw(ctx) {\r\n        if (!this.flashHide) {\r\n            const pos = this.transform.absolutePosition();\r\n            const shipWidth = 10;\r\n            const vel = this.transform.absoluteVelocity();\r\n            // let movementDirection = Math.atan2(vel[0], -vel[1])\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            ctx.translate(pos[0], pos[1]);\r\n            ctx.rotate(this.transform.angle + Math.PI / 4);\r\n            ctx.translate(-shipWidth / 2, shipWidth / 2);\r\n\r\n            ctx.strokeStyle = \"#ffffff\";\r\n            const r = 255;\r\n            const g = 255;\r\n            const b = 255;\r\n\r\n            const blurFactor = 0.5;\r\n            ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\r\n            ctx.shadowBlur = 10 * blurFactor * blurFactor;\r\n            ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.1)\";\r\n            ctx.lineWidth = 7.5 * blurFactor * blurFactor;\r\n            ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.1)\";\r\n            this.drawShip(ctx, shipWidth);\r\n            ctx.lineWidth = 6 * blurFactor;\r\n            ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.1)\";\r\n            this.drawShip(ctx, shipWidth);\r\n            ctx.lineWidth = 4.5;\r\n            this.drawShip(ctx, shipWidth);\r\n            ctx.lineWidth = 3;\r\n            this.drawShip(ctx, shipWidth);\r\n            ctx.strokeStyle = 'rgb(255, 255, 255)';\r\n            ctx.lineWidth = 1.5;\r\n            this.drawShip(ctx, shipWidth);\r\n\r\n            ctx.restore();\r\n        }\r\n    \r\n    }\r\n\r\n    drawShip(ctx, shipWidth) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, 0);\r\n        ctx.lineTo(0, -shipWidth);\r\n        ctx.lineTo(2 / 3 * shipWidth, -(1 + 1 / 6) * shipWidth); //1\r\n        ctx.lineTo(1 / 3 * shipWidth, -5 / 6 * shipWidth); // 2\r\n        ctx.lineTo(1 / 3 * shipWidth, -1 / 3 * shipWidth); // 2.5\r\n        ctx.lineTo(5 / 6 * shipWidth, -1 / 3 * shipWidth); // 3\r\n        ctx.lineTo((1 + 1 / 6) * shipWidth, -2 / 3 * shipWidth); // 4\r\n        ctx.lineTo(shipWidth, 0); // 5\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n    }\r\n}","import { Ship } from \"./game_objects/ship/ship\";\r\nimport { Walls } from \"./game_objects/Walls/walls\";\r\nimport { Overlay } from \"./game_objects/Overlay/overlay\";\r\nimport { Grid } from \"./game_objects/particles/Grid/grid\";\r\nimport { BoxBox } from \"./game_objects/enemies/BoxBox/boxbox\";\r\nimport { Pinwheel } from \"./game_objects/enemies/Pinwheel/pinwheel\";\r\nimport { Arrow } from \"./game_objects/enemies/Arrow/arrow\";\r\nimport { Grunt } from \"./game_objects/enemies/Grunt/grunt\";\r\nimport { Weaver } from \"./game_objects/enemies/Weaver/weaver\";\r\nimport { Singularity } from \"./game_objects/enemies/Singularity/singularity\";\r\nimport { AlienShip } from \"./game_objects/enemies/Singularity/alien_ship\";\r\nimport { ParticleExplosion } from \"./game_objects/particles/particle_explosion\";\r\nimport { ShipExplosion } from \"./game_objects/particles/ship_explosion\";\r\nimport {Star} from \"./game_objects/particles/star\";\r\n\r\nimport { Util } from \"./game_engine/util\";\r\nimport { Sound } from \"./game_engine/sound\";\r\nimport { StateMachine } from \"./game_engine/state_machine\";\r\n\r\nexport class GameScript {\r\n    constructor(engine) {\r\n        this.theme = new Sound(\"GEOWars/sounds/Geometry_OST.mp3\", 1);\r\n        this.gameOverSound = new Sound(\"GEOWars/sounds/Game_over.wav\");\r\n        this.gameStartSound = new Sound(\"GEOWars/sounds/Game_start.wav\");\r\n        this.shipDeathSound = new Sound(\"GEOWars/sounds/Ship_explode.wav\");\r\n        this.DIM_X = 1000;\r\n        this.DIM_Y = 600;\r\n        this.BG_COLOR = \"#000000\";\r\n        this.gameTime = 0;\r\n        this.score = 0;\r\n        this.engine = engine;\r\n        this.arrowAdded = false;\r\n        this.startPosition = [500, 300, 0];\r\n        this.initialCameraZPos = -1000;\r\n        this.ship = this.createShip();\r\n        this.createStars();\r\n        this.walls = this.createWalls();\r\n        this.grid = this.createGrid();\r\n        this.overlay = this.createOverlay();\r\n        this.enemyCreatorList = this.createEnemyCreatorList();\r\n        this.engine.addxButtonListener(this);\r\n        this.aliveEnemies = [];\r\n        this.sequenceTypes = this.addSequenceTypes();\r\n        this.spawnStateMachine = this.createSpawnStateMachine();\r\n        this.deathPausedTime = 0;\r\n        this.deathPaused = true;\r\n        this.deathPauseTime = 2500;\r\n        // this.deathSound = new Audio(\"GEOWars/sounds/Enemy_explode.wav\")\r\n        // this.deathSound.volume = 0.5;\r\n\r\n        this.intervalTiming = 1;\r\n        this.intervalTime = 0;\r\n        this.hugeSequenceTime = 0;\r\n        this.sequenceCount = 0;\r\n        this.lives = 3;\r\n        this.soundsToPlay = {};\r\n        this.scoreMultiplier = 1;\r\n\r\n        this.spawnthing = false;\r\n        this.explosionColorWheel = 0;\r\n    }\r\n\r\n    createStars() {\r\n        console.log(this.ship);\r\n        const runoffFactor = 1.5;\r\n        for(let i = 0; i < 400; i++) {\r\n            const X = (runoffFactor * Math.random() - runoffFactor/2) * this.DIM_X; // based on zoom scale and eventually camera position\r\n            const Y = (runoffFactor * Math.random() - runoffFactor/2) * this.DIM_Y;\r\n            // const Z = -this.initialCameraZPos * 0.25 + -this.initialCameraZPos * 2 * Math.random();\r\n            const Z = -this.initialCameraZPos * (0.5 + 0.75 * Math.random());\r\n            new Star(this.engine, [X, Y, Z], this.ship.cameraTransform);\r\n        }\r\n    }\r\n\r\n    updatexButtonListener(xButton) {\r\n        if (xButton[0]) {\r\n            if (this.engine.paused) {\r\n                var modal = document.getElementById(\"endModal\");\r\n\r\n                modal.style.display = \"none\";\r\n                this.engine.paused = false;\r\n                if (!this.engine.muted) {\r\n                    this.engine.gameScript.theme.play();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    update(deltaTime) {\r\n        this.spawnSequence(deltaTime);\r\n        this.changeExplosionColor();\r\n    }\r\n\r\n    changeExplosionColor() {\r\n        this.explosionColorWheel += 1 / 2;\r\n        this.explosionColorWheel = this.explosionColorWheel % 360;\r\n    }\r\n\r\n    tallyScore(gameObject) {\r\n        this.score += gameObject.points * this.scoreMultiplier;\r\n        if (this.score) {\r\n        }\r\n    }\r\n\r\n    resetGame() {\r\n        this.deathPaused = true;\r\n        this.desplayEndScore = this.score;\r\n        this.score = 0;\r\n        this.lives = 3;\r\n        this.ship.transform.pos = this.startPosition;\r\n        this.sequenceCount = 0;\r\n        this.deathPauseTime = 2500;\r\n        this.ship.powerLevel = 1;\r\n        this.intervalTiming = 1;\r\n        this.intervalTime = 0;\r\n        this.hugeSequenceTime = 0;\r\n        this.lives = 3;\r\n        this.scoreMultiplier = 1;\r\n        this.spawnthing = false;\r\n        this.engine.paused = true;\r\n        var modal = document.getElementById(\"endModal\");\r\n        modal.style.display = \"block\";\r\n        var scoreDisplay = document.getElementById(\"score\");\r\n        scoreDisplay.innerHTML = `score: ${this.desplayEndScore}`;\r\n\r\n        // Get the button that opens the modal\r\n        // var btn = document.getElementById(\"myBtn\");\r\n\r\n        // Get the <span> element that closes the modal\r\n        var xclose = document.getElementsByClassName(\"endClose\")[0];\r\n\r\n        // When the user clicks on <span> (x), close the modal\r\n        xclose.onclick = (e) => {\r\n            e.stopPropagation();\r\n            modal.style.display = \"none\";\r\n            this.engine.paused = false;\r\n            window.removeEventListener(\"click\", closeModalWithClick, false);\r\n            if (!this.engine.muted) {\r\n                this.engine.gameScript.theme.play();\r\n                this.engine.gameScript.gameStartSound.play();\r\n            }\r\n        };\r\n\r\n        const closeModalWithClick = (e) => {\r\n            if (e.target == modal) {\r\n                this.engine.paused = false;\r\n                if (!this.engine.muted) {\r\n                    this.engine.gameScript.theme.play();\r\n                    this.engine.gameScript.gameStartSound.play();\r\n                }\r\n                modal.style.display = \"none\";\r\n                window.removeEventListener(\"click\", closeModalWithClick, false);\r\n            }\r\n        };\r\n\r\n        // When the user clicks anywhere outside of the modal, close it\r\n        window.addEventListener(\"click\", closeModalWithClick, false);\r\n    }\r\n\r\n    death() {\r\n        this.lives -= 1;\r\n        this.deathPaused = true;\r\n        this.explodeEverything();\r\n        this.deathPauseTime = 4000;\r\n        if (!this.engine.muted) {\r\n            this.engine.gameScript.shipDeathSound.play();\r\n        }\r\n        this.grid.Playerdies(this.ship.transform.absolutePosition());\r\n        if (this.lives === 0) {\r\n            try {\r\n                this.theme.pause();\r\n            } catch (err) {}\r\n            if (!this.engine.muted) {\r\n                this.engine.gameScript.gameOverSound.play();\r\n            }\r\n            // this.playSoundthis.gameOverSound\r\n            window.setTimeout(this.resetGame.bind(this), 2000);\r\n        }\r\n    }\r\n\r\n    gameOver() {\r\n    // end the game here\r\n    }\r\n\r\n    explodeEverything() {\r\n        const removeList = [];\r\n        const typesToRemove = [\r\n            \"Grunt\",\r\n            \"Pinwheel\",\r\n            \"BoxBox\",\r\n            \"Arrow\",\r\n            \"Singularity\",\r\n            \"Weaver\",\r\n            \"AlienShip\",\r\n        ];\r\n        this.engine.gameObjects.forEach((object) => {\r\n            if (object.constructor.name === \"Ship\") {\r\n                const objectTransform = object.transform;\r\n                const pos = objectTransform.absolutePosition();\r\n                new ShipExplosion(this.engine, pos, [0, 0]);\r\n            } else if (object.constructor.name === \"Bullet\") {\r\n                removeList.push(object);\r\n            } else if (typesToRemove.includes(object.constructor.name)) {\r\n                const objectTransform = object.transform;\r\n                const pos = objectTransform.absolutePosition();\r\n                const vel = objectTransform.absoluteVelocity();\r\n                new ParticleExplosion(this.engine, pos, vel);\r\n                removeList.push(object);\r\n            }\r\n        });\r\n        removeList.forEach((removeThis) => {\r\n            removeThis.remove();\r\n        });\r\n    }\r\n\r\n    levelDesigner() {\r\n        const modal = document.getElementById(\"levelDesignerModal\");\r\n    }\r\n\r\n    onPause() {\r\n        try {\r\n            this.theme.pause();\r\n        } catch (error) {}\r\n\r\n        var modal = document.getElementById(\"pauseModal\");\r\n        modal.style.display = \"block\";\r\n    }\r\n\r\n    onUnPause() {\r\n        try {\r\n            this.theme.unPause();\r\n        } catch (error) {}\r\n\r\n        var modal = document.getElementById(\"pauseModal\");\r\n        modal.style.display = \"none\";\r\n    }\r\n\r\n    randomArrowDirection() {\r\n        const angles = [0, Math.PI / 2, Math.PI, (Math.PI * 3) / 2];\r\n        return angles[Math.floor(Math.random() * angles.length) % angles.length];\r\n    }\r\n\r\n    createEnemyCreatorList() {\r\n        const engine = this.engine;\r\n        return {\r\n            BoxBox: (pos) => new BoxBox(engine, pos),\r\n            Pinwheel: (pos) => new Pinwheel(engine, pos),\r\n            Arrow: (pos, angle) => new Arrow(engine, pos, angle),\r\n            Grunt: (pos) => new Grunt(engine, pos, this.ship.transform),\r\n            Weaver: (pos) => new Weaver(engine, pos, this.ship.transform),\r\n            Singularity: (pos) => new Singularity(engine, pos),\r\n            AlienShip: (pos) =>\r\n                new AlienShip(engine, pos, [0, 0], this.ship.transform),\r\n        };\r\n    }\r\n\r\n    randomSpawnEnemy(enemy) {\r\n        const pos = this.randomPosition();\r\n        const enemyCreators = Object.values(this.enemyCreatorList);\r\n        enemyCreators[\r\n            Math.floor(Math.random() * enemyCreators.length) % enemyCreators.length\r\n        ](pos);\r\n    // this.enemyCreatorList[\"BoxBox\"](pos)\r\n    }\r\n\r\n    addSequenceTypes() {\r\n        return {\r\n            Singularity: () => {\r\n                this.enemyCreatorList[\"Singularity\"]([700, 300]);\r\n            },\r\n            EasyGroups: () => {\r\n                const randomPositions = [];\r\n                for (let i = 0; i < 5; i++) {\r\n                    const pos = this.randomPosition();\r\n                    randomPositions.push(pos);\r\n                }\r\n                randomPositions.forEach((pos) => {\r\n                    const possibleSpawns = [\"BoxBox\", \"Pinwheel\"]; //, \"Singularity\"]\r\n                    this.enemyCreatorList[\r\n                        possibleSpawns[\r\n                            Math.floor(Math.random() * possibleSpawns.length) %\r\n                possibleSpawns.length\r\n                        ]\r\n                    ](pos);\r\n                });\r\n            },\r\n            EasyGroupsArrows: () => {\r\n                const randomPositions = [];\r\n                for (let i = 0; i < 5; i++) {\r\n                    const pos = this.randomPosition();\r\n                    randomPositions.push(pos);\r\n                }\r\n                randomPositions.forEach((pos) => {\r\n                    const possibleSpawns = [\"BoxBox\", \"Pinwheel\", \"Arrow\", \"Singularity\"];\r\n                    this.enemyCreatorList[\r\n                        possibleSpawns[\r\n                            Math.floor(Math.random() * possibleSpawns.length) %\r\n                possibleSpawns.length\r\n                        ]\r\n                    ](pos);\r\n                });\r\n            },\r\n            ArrowsAttack: () => {\r\n                const somePositions = [\r\n                    [200, 300],\r\n                    [1000, 300],\r\n                    [600, 100],\r\n                ];\r\n                const pos =\r\n          somePositions[\r\n              Math.floor(Math.random() * somePositions.length) %\r\n              somePositions.length\r\n          ];\r\n                for (let i = 0; i < 5; i++) {\r\n                    pos[1] += i * 80;\r\n                    this.enemyCreatorList[\"Arrow\"](pos);\r\n                }\r\n            },\r\n            GruntGroups: () => {\r\n                const randomPos = this.randomPosition();\r\n                for (let i = 0; i < 3; i++) {\r\n                    for (let j = 0; j < 3; j++) {\r\n                        this.enemyCreatorList[\"Grunt\"]([\r\n                            i * 40 + randomPos[0],\r\n                            j * 40 + randomPos[1],\r\n                        ]);\r\n                    }\r\n                }\r\n            },\r\n            GreenGroups: () => {\r\n                const randomPos = this.randomPosition();\r\n                for (let i = 0; i < 3; i++) {\r\n                    for (let j = 0; j < 3; j++) {\r\n                        this.enemyCreatorList[\"Weaver\"]([\r\n                            i * 40 + randomPos[0],\r\n                            j * 40 + randomPos[1],\r\n                        ]);\r\n                    }\r\n                }\r\n            },\r\n        };\r\n    }\r\n\r\n    createSpawnStateMachine() {\r\n    // let events = this.sequenceTypes\r\n    // let stateIndex = {i: 0}\r\n    // // these are the events\r\n    // // times will be hard coded for each state in the queue\r\n    // let spawnQueue = []\r\n    // let singularityState = new StateMachine(this.engine, {stateIndex, event: events.Singularity})\r\n    // let easyGroupsState = new StateMachine(this.engine, undefined)\r\n    }\r\n\r\n    randomPosition() {\r\n        return [\r\n            this.DIM_X * 0.7 * Math.random(),\r\n            this.DIM_Y * 0.7 * Math.random(),\r\n            // 500,300\r\n        ];\r\n    }\r\n\r\n    spawnSequence(delta) {\r\n        if (this.deathPaused) {\r\n            this.deathPausedTime += delta;\r\n            if (this.deathPausedTime > this.deathPauseTime) {\r\n                this.deathPausedTime = 0;\r\n                this.deathPaused = false;\r\n            }\r\n        } else {\r\n            this.intervalTime += delta;\r\n        }\r\n\r\n        this.testing = false;\r\n        if (this.testing) {\r\n            if (this.sequenceCount === 0) {\r\n                this.enemyCreatorList[\"AlienShip\"]([500, 100]);\r\n                this.sequenceCount += 1;\r\n            }\r\n        } else {\r\n            this.gameTime += delta;\r\n            if (this.sequenceCount === 1) {\r\n                this.enemyCreatorList[\"Singularity\"]([700, 300]);\r\n                this.sequenceCount += 1;\r\n            }\r\n            // wait time              //parentIndex   // repeat count\r\n            if (\r\n                this.intervalTime > 2500 * this.intervalTiming &&\r\n        this.sequenceCount < 5\r\n            ) {\r\n                this.intervalTime = 0;\r\n                this.sequenceTypes[\"EasyGroups\"](); // event\r\n                // this.randomSpawnEnemy();\r\n                this.sequenceCount += 1;\r\n            } else if (this.sequenceCount === 5 && this.intervalTime > 5000) {\r\n                this.sequenceCount += 1;\r\n            } else if (\r\n                this.intervalTime > 2500 * this.intervalTiming &&\r\n        this.sequenceCount > 5 &&\r\n        this.sequenceCount < 10\r\n            ) {\r\n                this.sequenceCount += 1;\r\n                this.intervalTime = 0;\r\n                this.sequenceTypes[\"EasyGroupsArrows\"]();\r\n            } else if (this.sequenceCount === 10 && this.intervalTime > 5000) {\r\n                this.sequenceCount += 1;\r\n            } else if (\r\n                this.intervalTime > 1500 * this.intervalTiming &&\r\n        this.sequenceCount > 10 &&\r\n        this.sequenceCount < 15\r\n            ) {\r\n                this.sequenceCount += 1;\r\n                this.intervalTime = 0;\r\n                this.sequenceTypes[\"GruntGroups\"]();\r\n            } else if (this.sequenceCount === 15 && this.intervalTime > 2000) {\r\n                this.sequenceCount += 1;\r\n            } else if (\r\n                this.intervalTime > 2000 * this.intervalTiming &&\r\n        this.sequenceCount > 15 &&\r\n        this.sequenceCount < 20\r\n            ) {\r\n                this.sequenceCount += 1;\r\n                this.intervalTime = 0;\r\n                this.sequenceTypes[\"GreenGroups\"]();\r\n            } else if (this.sequenceCount === 20 && this.intervalTime > 3000) {\r\n                this.sequenceCount += 1;\r\n            }\r\n            // else if (this.intervalTime > (2500 * this.intervalTiming) && this.sequenceCount === 10 && this.hugeSequenceTime % 2 === 1) {\r\n            //   this.intervalTime = 0\r\n            //   this.sequenceCount += 1\r\n            //   let enemies_to_spawn = []\r\n            //   let randomPos = this.randomPosition();\r\n            //   for (let i = 0; i < 2; i++) {\r\n            //     for (let j = 0; j < 2; j++) {\r\n            //       this.enemyCreatorList[\"Weaver\"]([i * 40 + randomPos[0], j * 40 + randomPos[1]])\r\n            //     }\r\n            //   }\r\n\r\n            // } else if (this.intervalTime > (5000 * this.intervalTiming) && this.sequenceCount === 11) {\r\n            //   this.intervalTime = 0;\r\n            //   this.sequenceCount += 1;\r\n            //}\r\n            else if (\r\n                this.intervalTime > 375 &&\r\n        this.sequenceCount > 20 &&\r\n        this.sequenceCount < 30 &&\r\n        this.hugeSequenceTime % 2 === 0\r\n            ) {\r\n                this.ship.upgradeBullets();\r\n                this.intervalTime = 0;\r\n                this.sequenceCount += 1;\r\n\r\n                const fourCorners = [\r\n                    [40, 40],\r\n                    [GameScript.DIM_X - 40, 40],\r\n                    [40, GameScript.DIM_Y - 40],\r\n                    [GameScript.DIM_X - 40, GameScript.DIM_Y - 40],\r\n                ];\r\n                fourCorners.forEach((corner) => {\r\n                    this.enemyCreatorList[\"Grunt\"](corner);\r\n                });\r\n            } else if (\r\n                this.intervalTime > 375 &&\r\n        this.sequenceCount > 20 &&\r\n        this.sequenceCount < 30 &&\r\n        this.hugeSequenceTime % 2 === 1\r\n            ) {\r\n                this.intervalTime = 0;\r\n                this.sequenceCount += 10;\r\n                const arrowWallPositions = [];\r\n                const arrowDirection = (Math.PI * 3) / 2 + Math.PI;\r\n                for (let i = 40; i < GameScript.DIM_X; i += 40) {\r\n                    arrowWallPositions.push([i, 50]);\r\n                }\r\n\r\n                arrowWallPositions.forEach((position) => {\r\n                    this.enemyCreatorList[\"Arrow\"](position, arrowDirection);\r\n                });\r\n            }\r\n            // this is the spawner event.\r\n            // it runs through all the child states\r\n            // for the event to be triggered\r\n            else if (this.sequenceCount >= 30) {\r\n                this.sequenceCount = 0;\r\n                if (!(this.intervalTiming < 0.5)) {\r\n                    this.intervalTiming *= 0.9;\r\n                }\r\n                this.hugeSequenceTime += 1;\r\n            }\r\n        }\r\n\r\n    // if (this.gameTime % 2000 === 0){\r\n    //   this.spawned = false\r\n    // }\r\n    }\r\n\r\n    createShip() {\r\n        return new Ship(this.engine, this.startPosition, this.initialCameraZPos);\r\n    }\r\n\r\n    createWalls() {\r\n        return new Walls(this.engine, this);\r\n    }\r\n\r\n    createGrid() {\r\n        return new Grid(this.engine, this);\r\n    }\r\n\r\n    createOverlay() {\r\n        return new Overlay(this.engine, this, this.ship.transform);\r\n    }\r\n\r\n    isOutOfBounds(pos, radius) {\r\n        const max = [GameScript.DIM_X - radius, GameScript.DIM_Y - radius];\r\n        if (radius) {\r\n            return (\r\n                pos[0] <= radius ||\r\n        pos[0] >= max[0] ||\r\n        pos[1] <= radius ||\r\n        pos[1] >= max[1]\r\n            );\r\n        } else {\r\n            return (\r\n                pos[0] < 0 ||\r\n        pos[1] < 0 ||\r\n        pos[0] > GameScript.DIM_X ||\r\n        pos[1] > GameScript.DIM_Y\r\n            );\r\n        }\r\n    }\r\n\r\n    updateShipFireAngle() {\r\n        this.ships[0].setFireAngle();\r\n    }\r\n\r\n    // bounce(pos){\r\n    //   return [\r\n    //     Util.bounce(pos[0], GameScript.DIM_X), Util.bounce(pos[1], GameScript.DIM_Y)\r\n    //   ];\r\n    // }\r\n\r\n    bounce(transform, radius = 0) {\r\n        const max = [this.DIM_X - radius, this.DIM_Y - radius];\r\n        const pos = transform.absolutePosition();\r\n        if (pos[0] <= radius || pos[0] >= max[0]) {\r\n            transform.vel[0] = -transform.vel[0];\r\n        }\r\n        if (pos[1] <= radius || pos[1] >= max[1]) {\r\n            transform.vel[1] = -transform.vel[1];\r\n        }\r\n    }\r\n\r\n    wallGraze(transform, radius = 0) {\r\n        const max = [this.DIM_X - radius, this.DIM_Y - radius];\r\n        const pos = transform.absolutePosition();\r\n        const vel = transform.absoluteVelocity();\r\n\r\n        // X bounds, left right\r\n        if (pos[0] <= radius && vel[0] < 0) {\r\n            transform.vel[0] = 0.1;\r\n        } else if (pos[0] >= max[0] && vel[0] > 0) {\r\n            transform.vel[0] = -0.1;\r\n        }\r\n\r\n        // Y bounds, top bottom\r\n        if (pos[1] <= radius && vel[1] < 0) {\r\n            transform.vel[1] = 0.1;\r\n        } else if (pos[1] >= max[1] && vel[1] > 0) {\r\n            transform.vel[1] = -0.1;\r\n        }\r\n    }\r\n\r\n    redirect(transform) {\r\n        const max = [this.DIM_X, this.DIM_Y];\r\n        const pos = transform.absolutePosition();\r\n\r\n        if (pos[0] <= 0 || pos[0] >= max[0]) {\r\n            if (pos[0] <= 0) {\r\n                pos[0] = 1;\r\n            }\r\n            if (pos[0] >= max[0]) {\r\n                pos[0] = max[0] - 1;\r\n            }\r\n        }\r\n        if (pos[1] <= 0 || pos[1] >= max[1]) {\r\n            if (pos[1] <= 0) {\r\n                pos[1] = 1;\r\n            }\r\n            if (pos[1] >= max[1]) {\r\n                pos[1] = max[1] - 1;\r\n            }\r\n        }\r\n\r\n        transform.vel[0] = -transform.vel[0];\r\n        transform.vel[1] = -transform.vel[1];\r\n    }\r\n}\r\n\r\nGameScript.BG_COLOR = \"#000000\";\r\n\r\nGameScript.DIM_X = 1000;\r\nGameScript.DIM_Y = 600;\r\n// GameScript.FPS = 32;\r\n// GameScript.NUM_BOXES = 10;\r\n// GameScript.NUM_PINWHEELS = 0;\r\n// GameScript.NUM_ARROWS = 0;\r\n// GameScript.NUM_GRUNTS = 0;\r\n// GameScript.NUM_WEAVERS = 0;\r\n// GameScript.NUM_SINGULARITIES = 1;\r\n\r\nGameScript.Spawn1 = {\r\n    BoxBox: 50,\r\n};\r\n\r\nGameScript.spawnListList = [GameScript.Spawn1];\r\n","export class GameView {\r\n    constructor(engine, ctx, canvasEl) {\r\n        this.ctx = ctx;\r\n        this.engine = engine;\r\n        // this.ship = this.game.addShip(); belongs in game script\r\n        this.canvasEl = canvasEl;\r\n        this.initialUnmute = true;\r\n        this.gameStarted = false;\r\n        this.modelClosed = false;\r\n        this.bindKeyboardKeys = this.bindKeyboardKeys.bind(this);\r\n        this.animate = this.animate.bind(this);\r\n        this.gameEditorOpened = false;\r\n    }\r\n\r\n    bindKeyboardKeys() {\r\n        window.addEventListener(\"keydown\", this.doKeyEvent(true), true);\r\n        window.addEventListener(\"keyup\", this.doKeyEvent(false), true);\r\n    }\r\n\r\n    updateMovementDirection(move, down) {\r\n        if (!this.gameEditorOpened) {\r\n            this.engine.gameScript.ship.updateLeftControlStickInput(move, down);\r\n        }\r\n    }\r\n\r\n    /*\r\n    if true, change movement direction to the direction\r\n    if false, remove movement direction if it's the \r\n    same as the current movement direction\r\n  */\r\n\r\n    doKeyEvent(down) {\r\n        return (e) => {\r\n            // if (e.key === \"p\"){\r\n            //   this.engine.togglePause()\r\n            // }\r\n            if (e.key === \"m\" && this.initialUnmute) {\r\n                this.initialUnmute = false;\r\n                this.engine.gameScript.theme.play();\r\n            }\r\n\r\n            if (e.key === \"m\" && down) {\r\n                this.engine.toggleMute();\r\n                if (this.engine.muted) {\r\n                    this.engine.gameScript.theme.mute();\r\n                } else {\r\n                    this.engine.gameScript.theme.unmute();\r\n                }\r\n            }\r\n\r\n            const unitVector = GameView.MOVES[e.key];\r\n            if (unitVector) {\r\n                this.updateMovementDirection(e.key, down);\r\n            }\r\n            if (e.key === \"p\") {\r\n                this.engine.updateStartButtonListeners(e.key, down);\r\n            }\r\n        };\r\n    }\r\n\r\n    bindKeyHandlers() {\r\n        const engine = this.engine;\r\n        // Object.keys(GameView.MOVES).forEach((k) => {\r\n        //   const move = GameView.MOVES[k];\r\n        //   key(k, () => {\r\n        //     this.engine.gameScript.ship.updateLeftControlStickInput(move);\r\n        //   });\r\n        // });\r\n\r\n        // key(\"m\", () => {\r\n        //   engine.muted = !engine.muted;\r\n        //   if (engine.muted) {\r\n        //     this.theme.pause();\r\n        //   } else {\r\n        //     this.theme.play();\r\n        //   }\r\n        // })\r\n\r\n        window.addEventListener(\"mousemove\", (e) => {\r\n            const x = { x: e.layerX };\r\n            const y = { y: e.layerY };\r\n            const mousePos = [e.layerX, e.layerY];\r\n            this.engine.updateMousePos(mousePos);\r\n            // ship.setFireAngle(mousePos); add to game script event listener thing\r\n        });\r\n\r\n        window.addEventListener(\"click\", (e) => {\r\n            this.engine.mouseClicked([e.layerX, e.layerY]);\r\n        });\r\n\r\n        // function preventDefault(e) {\r\n        //   e = e || window.event;\r\n        //   if (e.preventDefault)\r\n        //     e.preventDefault();\r\n        //   e.returnValue = false;\r\n        // }\r\n\r\n        // function disableScroll() {\r\n        //   if (window.addEventListener) // older FF\r\n        //     window.addEventListener('DOMMouseScroll', preventDefault, false);\r\n        //   // window.onwheel = preventDefault; // modern standard\r\n        //   // window.onmousewheel = document.onmousewheel = preventDefault; // older browsers, IE\r\n        //   // window.ontouchmove = preventDefault; // mobile\r\n        //   // document.onkeydown = preventDefaultForScrollKeys;\r\n        // }\r\n\r\n    // if (window.addEventListener) // older FF\r\n    //   window.addEventListener('DOMMouseScroll', preventDefault, false);\r\n    // window.onwheel = preventDefault; // modern standard\r\n    // window.onmousewheel = document.onmousewheel = preventDefault; // older browsers, IE\r\n    // window.ontouchmove = preventDefault; // mobile\r\n    }\r\n\r\n    end() {\r\n        var endModal = document.getElementById(\"endModal\");\r\n    }\r\n\r\n    start() {\r\n        this.lastTime = 0;\r\n        this.bindKeyHandlers();\r\n\r\n        // Get the modal\r\n        const modal = document.getElementById(\"myModal\");\r\n\r\n        // Get the button that opens the modal\r\n        // var btn = document.getElementById(\"myBtn\");\r\n\r\n        // Get the <span> element that closes the modal\r\n        const xclose = document.getElementsByClassName(\"close\")[0];\r\n\r\n        // When the user clicks on <span> (x), close the modal\r\n        xclose.onclick = (e) => {\r\n            e.stopPropagation();\r\n            modal.style.display = \"none\";\r\n            this.modelClosed = true;\r\n        };\r\n\r\n        // When the user clicks anywhere outside of the modal, close it\r\n        //  window.addEventListener('click', (e) => {\r\n        window.onclick = (event) => {\r\n            if (this.modelClosed && !this.gameStarted) {\r\n                this.gameStarted = true;\r\n                this.bindKeyboardKeys();\r\n                requestAnimationFrame(this.animate);\r\n            }\r\n            if (event.target == modal) {\r\n                this.modelClosed = true;\r\n                modal.style.display = \"none\";\r\n            }\r\n        };\r\n    }\r\n\r\n    animate(time) {\r\n        const timeDelta = time - this.lastTime;\r\n        this.engine.tick(timeDelta);\r\n        this.lastTime = time;\r\n        // every call to animate requests causes another call to animate\r\n        requestAnimationFrame(this.animate.bind(this));\r\n    }\r\n}\r\n\r\nconst KEYMAP = {\r\n    87: \"W\",\r\n    82: \"R\",\r\n    90: \"Z\",\r\n    88: \"X\",\r\n    67: \"C\",\r\n    70: \"F\",\r\n    83: \"S\",\r\n    69: \"E\",\r\n    65: \"D\",\r\n    68: \"A\",\r\n};\r\n\r\nGameView.MOVES = {\r\n    s: [0, 1],\r\n    a: [-1, 0],\r\n    w: [0, -1],\r\n    d: [1, 0],\r\n};\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { GameScript } from \"./game_script\";\r\nimport { GameView } from \"./game_view\";\r\nimport { GameEngine } from \"./game_engine/game_engine\";\r\nimport { LevelDesigner } from \"./game_engine/Levels/levelDesigner\";\r\nimport { AnimationView } from \"./AnimationView\";\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {\r\n    const canvasEl = document.getElementsByTagName(\"canvas\")[0];\r\n    canvasEl.width = GameScript.DIM_X;\r\n    canvasEl.height = GameScript.DIM_Y;\r\n\r\n    const ctx = canvasEl.getContext(\"2d\");\r\n    const gameEngine = new GameEngine(ctx);\r\n    const animationWindow = document.getElementsByTagName(\"canvas\")[1];\r\n    const animationView = new AnimationView(animationWindow.getContext(\"2d\"));\r\n    new LevelDesigner(gameEngine, animationView);\r\n\r\n    animationView.start();\r\n    new GameView(gameEngine, ctx, canvasEl).start();\r\n});\r\n"],"names":[],"sourceRoot":""}