{"version":3,"file":"./bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAA8D;AACM;AACT;AACA;AACG;AACe;AACH;AACP;;AAE5D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,wDAAwD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAA6C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,uEAAM;AACvC,mCAAmC,6EAAQ;AAC3C,uCAAuC,oEAAK;AAC5C,gCAAgC,oEAAK;AACrC,iCAAiC,uEAAM;AACvC,sCAAsC,sFAAW;AACjD,oCAAoC,mFAAS;AAC7C,iCAAiC,4EAAY;AAC7C;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjL6C;AACO;AACR;;AAEsB;AAClC;;AAEhC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,yCAAK,sBAAsB;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACO,0BAA0B,kDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,MAAM;AACvE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,iDAAS;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,iEAAW;AAC/C;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,MAAM;AAC7D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,oCAAoC,iEAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEO,gCAAgC,yDAAY;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,+DAAS,eAAe,iDAAS;AACrD,mBAAmB,+DAAS,cAAc,iDAAS;AACnD,mBAAmB,+DAAS,cAAc,iDAAS;;AAEnD,sBAAsB,+DAAS,iBAAiB,iDAAS;AACzD,oBAAoB,+DAAS,eAAe,iDAAS;AACrD,yBAAyB,+DAAS,oBAAoB,iDAAS;AAC/D,oBAAoB,+DAAS,eAAe,iDAAS;AACrD;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC1S6C;AACO;AACR;;AAE5C;;AAEA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD;AACzD;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO,kCAAkC,kDAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,iDAAS;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEO,4BAA4B,kDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,iDAAS;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGO,wCAAwC,yDAAY;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGO,qCAAqC,yDAAY;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;AC1P6C;AACO;AACR;;AAErC;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO,8BAA8B,kDAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,iDAAS;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO,oCAAoC,yDAAY;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrJoD;AACP;AACD;;AAE5C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEO,0BAA0B,kDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,iDAAS;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;;AAEO,0BAA0B,yDAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5KA;AACO;AACP,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtE6C;AACO;AACR;;AAE5C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACO,yBAAyB,kDAAS;AACzC,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,iDAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGO,+BAA+B,yDAAY;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC3HA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AAC+C;;AAEO;AAC4B;AACH;AACA;AACS;AACN;AACe;AACjB;AAC9C;;AAElC;AACO;AACP;AACA,kCAAkC,oFAAY;AAC9C;AACA;AACA,KAAK;AACL,8BAA8B,iFAAW;AACzC,8BAA8B,iFAAW;AACzC,iCAAiC,0FAAc;AAC/C,+BAA+B,oFAAY;AAC3C,oCAAoC,mGAAiB;AACrD,+BAA+B,kFAAkB;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO,0BAA0B,oDAAU;AAC3C;AACA;AACA,eAAe,yDAAyD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,wCAAwC,+DAAgB;AACxD;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;;;AAGA;AACA,2BAA2B,uCAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;;;AAIA;;;;;;;;;;;;;;;;;AClI+C;;AAExC,+BAA+B,oDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3CuD;AACM;AACC;AACN;AACT;AACN;AACY;AACN;;AAEM;AACF;AACwB;AACd;;AAE7D;;;AAGA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA,4BAA4B;;AAE5B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iHAAiH,OAAO;AACxH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,4DAAU,QAAQ,eAAe;AAChE;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,uEAAe;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,oCAAoC,sEAAmB;AACvD,8BAA8B,gEAAa;AAC3C;AACA;AACA;;AAEA;AACA,kCAAkC,sEAAmB;AACrD;AACA;AACA;;AAEA;AACA,kCAAkC,gEAAa;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,8DAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAW;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,iEAAW,eAAe,KAAK;AACrE;;AAEA;AACA,sCAAsC,iEAAW,eAAe,KAAK;AACrE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0DAA0D,wDAAK;AAC/D;AACA;;AAEA;AACA;AACA,mDAAmD,wDAAK;AACxD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,mBAAmB,4DAAK;AACxB;;AAEA;AACA,mBAAmB,mEAAI,wBAAwB,iDAAS;AACxD;;AAEA;AACA,mBAAmB,kEAAO;AAC1B;;AAEA;AACA,qBAAqB,oDAAU,iBAAiB,oDAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,iBAAiB,oDAAU;AAC3B,iBAAiB,oDAAU;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;AC50BwC;AACV;;AAEvB;AACP;AACA;AACA,+BAA+B,iDAAS;AACxC,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uCAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uCAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uCAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;;;;;;;;;;;;;;AC/HA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd,cAAc;;AAEgB;;AAEvB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,uCAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzDO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,OAAO,GAAG,OAAO,GAAG,OAAO;AACrD,UAAU;AACV,0BAA0B,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,OAAO;AAC/D,UAAU;AACV,0BAA0B,OAAO,GAAG,OAAO,IAAI,OAAO;AACtD,UAAU;AACV,2BAA2B,OAAO,IAAI,OAAO,KAAK,OAAO,KAAK,OAAO;AACrE;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnE4C;;AAErC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;;;;AAIA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzgB8B;AACE;;AAEQ;AACe;AACZ;AACL;;AAE/B;AACP;AACA;AACA;AACA,6BAA6B,iDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,gEAAgB;AACpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,gCAAgC,+CAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACvIO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACvBO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;ACzBO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/CO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnHO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,mCAAmC;AACnC;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5DyD;AACX;AACyB;AAC1B;AACqB;AACpB;AACvC,qBAAqB,gEAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAK;AAChC;AACA;AACA,+BAA+B,wDAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iFAAmB;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV,0BAA0B,mDAAI;AAC9B;AACA;AACA;AACA;AACA,mGAAmG;AACnG,cAAc;AACd,uGAAuG;AACvG;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,sCAAsC,4EAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;ACtH2D;;AAEpD,2BAA2B,gEAAU;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC;AACnC,+BAA+B;AAC/B,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChCiD;AACU;;AAEpD,sBAAsB,gEAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAa;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClC2D;AACX;AACzC,4BAA4B,gEAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAK;AACpC;AACA,SAAS;AACT,yBAAyB,qDAAK;AAC9B;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvC6C;AACc;;AAEpD,oBAAoB,gEAAU;AACrC;AACA;AACA;AACA;AACA,+BAA+B,sDAAW;AAC1C;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACd2D;AACX;AACzC,0BAA0B,gEAAU;AAC3C;AACA;AACA;AACA;AACA,+BAA+B,qDAAK;AACpC;AACA,SAAS;AACT,yBAAyB,qDAAK;AAC9B;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,iCAAiC;AACjC;AACA,8BAA8B;AAC9B;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrD8D;AACb;AACE;AACM;AACZ;;AAEtC,oBAAoB,gEAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAI;AACjC;AACA,8BAA8B,qDAAK;AACnC;AACA,+BAA+B,sDAAW;AAC1C,oCAAoC,8DAAU;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;AC7D8D;AACvD,0BAA0B,gEAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,0CAA0C;AAC1C,2CAA2C;AAC3C,6CAA6C;AAC7C,oCAAoC;AACpC;;AAEA;AACA;AACA,oCAAoC;AACpC,8CAA8C;AAC9C,4CAA4C;AAC5C,2CAA2C;AAC3C,mCAAmC;AACnC;;AAEA;AACA;AACA,8CAA8C;AAC9C,8CAA8C;AAC9C,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C,6CAA6C;AAC7C,0CAA0C;AAC1C;AACA;;AAEA;AACA;AACA,4CAA4C;AAC5C,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvM4D;AACX;AACM;AACV;;;AAG7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGO,qBAAqB,gEAAU;AACtC;AACA;AACA,8BAA8B,qDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAY;AAC3C,oCAAoC,8DAAU;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;;;;;AAKA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpiB8D;;AAEvD,2BAA2B,gEAAU;AAC5C;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChO4D;AACX;AACA;AACM;AACZ;AACpC,oBAAoB,gEAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAK;AACnC;AACA,+BAA+B,sDAAW;AAC1C,oCAAoC,8DAAU;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,mDAAI;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,mDAAI;AAClC,SAAS;AACT;AACA;AACA;;;;;;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;AC1H4D;AACrD,0BAA0B,gEAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B,8BAA8B;AAC9B,gCAAgC;AAChC;AACA;AACA;;;;;AAKA;;;;;;;;;;;;;;;;;;;;AC3DiD;AACF;AACa;AACL;AACN;;AAE1C,uBAAuB,gEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAI;AACjC,8BAA8B,qDAAK;AACnC;AACA,+BAA+B,4DAAc;AAC7C,oCAAoC,8DAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;AC1C8D;AACvD,6BAA6B,gEAAU;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B,4BAA4B;AAC5B,2BAA2B;AAC3B,0BAA0B;AAC1B,2BAA2B;AAC3B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,2BAA2B;AAC3B,2BAA2B;AAC3B,yBAAyB;;AAEzB;AACA;AACA;;;;;AAKA;;;;;;;;;;;;;;;;;;ACzE2D;AACA;AACpD,2BAA2B,gEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,gEAAU;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzC8D;AACX;AACF;AACK;;AAE/C,wBAAwB,gEAAU;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+DAAe;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;AC5E8D;;AAEvD,8BAA8B,gEAAU;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC1C8D;AACX;AACF;AACsB;AACa;AAC3B;AACA;AACoB;AACpC;AACmB;AACrD,0BAA0B,gEAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAK;AACnC,uCAAuC,qDAAK;AAC5C,iCAAiC,qDAAK;AACtC;AACA,8BAA8B,qDAAK;AACnC;;AAEA;AACA,+BAA+B,kEAAiB;AAChD,oCAAoC,8DAAU;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kFAAoB;AACxD;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,kCAAkC,4EAAiB;AACnD;;AAEA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4EAAiB;AACnD;AACA;AACA;AACA,UAAU;AACV,kCAAkC,yFAAuB;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6BAA6B,iEAAS;AACtC;AACA;AACA;AACA,uGAAuG;AACvG,yFAAyF;AACzF,oBAAoB,mDAAI;AACxB,2BAA2B,mDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mDAAI;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,sBAAsB,mDAAI;AAC1B;AACA,mCAAmC,mDAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA,gBAAgB,kDAAS;AACzB;AACA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;;;;;AC/L8D;AACvD,gCAAgC,gEAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvD8D;AACX;AACF;AACQ;AACV;;;AAGxC,qBAAqB,gEAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,qDAAK;AACnC;AACA,+BAA+B,wDAAY;AAC3C,oCAAoC,8DAAU;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,mDAAI;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,mDAAI;AAClC,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,mDAAI;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;ACjJ8D;;AAEvD,2BAA2B,gEAAU;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B,0BAA0B;AAC1B,0BAA0B;AAC1B,2BAA2B;AAC3B,2BAA2B;AAC3B,oCAAoC;AACpC,mCAAmC;AACnC,kCAAkC;AAClC,mCAAmC;AACnC,oCAAoC;AACpC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClE8D;AACrB;AACE;AACM;AAC1C,mBAAmB,gEAAU;AACpC;AACA;;AAEA;;AAEA;AACA,+BAA+B;AAC/B,8BAA8B;;AAE9B;;AAEA,+BAA+B,oDAAU;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,mDAAI;AAC/B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,mDAAI;AAC/B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC,6BAA6B;AAC7B;AACA;AACA,gCAAgC,sCAAsC;AACtE,oCAAoC,sCAAsC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;;;;ACzG4D;;;AAGrD,wBAAwB,gEAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,gCAAgC;;AAEhC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;;;AClC8D;AACX;;AAE5C,yBAAyB,gEAAU;AAC1C;AACA;AACA;AACA;;AAEA,yBAAyB,qDAAK;AAC9B;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,8BAA8B;AACtD;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEiD;AACA;AACa;;;;AAIvD,uBAAuB,gEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA,6BAA6B,mDAAI;AACjC;AACA,6CAA6C;AAC7C,6BAA6B,mDAAI;AACjC,+BAA+B,4DAAc;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;AC/E8D;AACb;;AAE1C,6BAA6B,gEAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B;AAC1B,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC,iCAAiC;AACjC;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;AC5FA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAE8C;;AAEvC,kCAAkC,wDAAQ;AACjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;ACzC6C;AACY;AACX;AACA;AACvC,kCAAkC,gEAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAK;AACrC;AACA,SAAS;AACT;AACA,kCAAkC,qDAAK;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,wDAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9D2D;;AAEpD,yBAAyB,gEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/B6C;AACY;AACX;AACA;;AAEvC,gCAAgC,gEAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAK;AACrC;AACA,SAAS;AACT;AACA;AACA,oCAAoC;AACpC,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,mCAAmC,qDAAK;AACxC;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,wDAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvD+C;AACY;AACX;AACA;AACzC,4BAA4B,gEAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAK;AACrC;AACA,SAAS;AACT;AACA,mCAAmC,qDAAK;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,sBAAsB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,wDAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5C+C;AACY;AACX;AACA;AACzC,sCAAsC,gEAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAK;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,mCAAmC,qDAAK;AACxC;AACA;AACA;;AAEA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,wDAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClD2D;AACb;AACoC;AAClC;;AAEzC,mCAAmC,gEAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAK;AACrC;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,2FAAmB;AACvD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7E2D;AACA;;AAEpD,mBAAmB,gEAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO,yBAAyB,gEAAU;AAC1C;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxC2D;AACX;AACL;AACD;AACc;;AAEjD,mBAAmB,gEAAU;AACpC;AACA;AACA;AACA;AACA,mCAAmC,6DAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAU;AACzC,6BAA6B;AAC7B;AACA;AACA,+BAA+B,qDAAK;AACpC,uCAAuC,qDAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAoD;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,kDAAM;AACrC,+BAA+B,kDAAM;;AAErC;AACA,oCAAoC,kDAAM;;AAE1C;AACA,oCAAoC,kDAAM;AAC1C,oCAAoC,kDAAM;AAC1C,oCAAoC,kDAAM;AAC1C,oCAAoC,kDAAM;;AAE1C;AACA;AACA;AACA,wCAAwC,kDAAM;AAC9C,wCAAwC,kDAAM;AAC9C;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjX2D;;AAEpD,yBAAyB,gEAAU;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,2DAA2D;AAC3D,2DAA2D;AAC3D,2DAA2D;AAC3D,iEAAiE;AACjE,kCAAkC;AAClC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9D4C;AACI;AACG;AACM;AACC;AACI;AACM;AACT;AACA;AACG;AACe;AACH;AACM;AACR;AACrB;;AAEe;AACA;AACF;AACkB;AACV;;AAEjE;AACP;AACA;AACA,yBAAyB,qDAAK;AAC9B,iCAAiC,qDAAK;AACtC,kCAAkC,qDAAK;AACvC,kCAAkC,qDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,4EAAK;AAClC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qCAAqC,4EAAK;AAC1C;AACA;AACA,cAAc;AACd,2BAA2B,4EAAK;AAChC,cAAc;AACd,2BAA2B,0EAAI;AAC/B,cAAc;AACd,2BAA2B,mFAAa;AACxC,cAAc;AACd,2BAA2B,6EAAO,EAAE,gEAAgE;AACpG,cAAc;AACd,2BAA2B,oFAAS;AACpC;AACA,SAAS;AACT;;AAEA;AACA;AACA,uBAAuB,SAAS;AAChC,oFAAoF;AACpF;AACA;AACA;AACA,gBAAgB,+DAAI;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qBAAqB;;AAEhE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kFAAa;AACjC,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,oBAAoB,0FAAiB;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,uEAAM;AAC9C,0CAA0C,6EAAQ;AAClD,uCAAuC,oEAAK;AAC5C,uCAAuC,oEAAK;AAC5C,wCAAwC,uEAAM;AAC9C,6CAA6C,uFAAW;AACxD;AACA,oBAAoB,oFAAS;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,OAAO;AACvC,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,OAAO;AACvC,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,6DAA6D,sCAAsC;AACnG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC,+BAA+B,OAAO;AACtC;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB;AACnD;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,yDAAI;AACvB;;AAEA;AACA,mBAAmB,4DAAK;AACxB;;AAEA;AACA,mBAAmB,mEAAI;AACvB;;AAEA;AACA,mBAAmB,kEAAO;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjrBO;AACP;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,YAAY;;AAEZ;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,YAAY;;AAEZ;AACA,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA,4CAA4C;AAC5C,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD,8EAA8E;AAC9E,qDAAqD;AACrD;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC,qEAAqE;AACrE,4CAA4C;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCnPA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACN2C;AACJ;AACgB;AACY;AACnB;;AAEhD;AACA;AACA,qBAAqB,oDAAU;AAC/B,sBAAsB,oDAAU;;AAEhC;AACA,2BAA2B,gEAAU;AACrC;AACA;AACA;AACA,8BAA8B,yDAAa;AAC3C,8BAA8B,4EAAa;AAC3C;;AAEA,yBAAyB,gDAAQ;AACjC;AACA,CAAC","sources":["webpack://GEOWars/./src/AnimationView.js","webpack://GEOWars/./src/game_engine/Levels/DesignElements/Event.js","webpack://GEOWars/./src/game_engine/Levels/DesignElements/Loop.js","webpack://GEOWars/./src/game_engine/Levels/DesignElements/Operation.js","webpack://GEOWars/./src/game_engine/Levels/DesignElements/Scene.js","webpack://GEOWars/./src/game_engine/Levels/DesignElements/Spawn.js","webpack://GEOWars/./src/game_engine/Levels/DesignElements/Time.js","webpack://GEOWars/./src/game_engine/Levels/LevelDesign/EnemyPlacer.js","webpack://GEOWars/./src/game_engine/Levels/LevelDesign/PlacingAnimation.js","webpack://GEOWars/./src/game_engine/Levels/levelDesigner.js","webpack://GEOWars/./src/game_engine/UI_Element.js","webpack://GEOWars/./src/game_engine/UI_line_sprite.js","webpack://GEOWars/./src/game_engine/collider.js","webpack://GEOWars/./src/game_engine/color.js","webpack://GEOWars/./src/game_engine/game_engine.js","webpack://GEOWars/./src/game_engine/game_object.js","webpack://GEOWars/./src/game_engine/line_sprite.js","webpack://GEOWars/./src/game_engine/physics_component.js","webpack://GEOWars/./src/game_engine/sound.js","webpack://GEOWars/./src/game_engine/transform.js","webpack://GEOWars/./src/game_engine/util.js","webpack://GEOWars/./src/game_objects/Bullet/bullet.js","webpack://GEOWars/./src/game_objects/Bullet/bullet_sprite.js","webpack://GEOWars/./src/game_objects/Overlay/overlay.js","webpack://GEOWars/./src/game_objects/Overlay/overlay_sprite.js","webpack://GEOWars/./src/game_objects/Walls/walls.js","webpack://GEOWars/./src/game_objects/Walls/walls_sprite.js","webpack://GEOWars/./src/game_objects/enemies/Arrow/arrow.js","webpack://GEOWars/./src/game_objects/enemies/Arrow/arrow_sprite.js","webpack://GEOWars/./src/game_objects/enemies/BoxBox/boxbox.js","webpack://GEOWars/./src/game_objects/enemies/BoxBox/boxbox_sprite.js","webpack://GEOWars/./src/game_objects/enemies/Grunt/grunt.js","webpack://GEOWars/./src/game_objects/enemies/Grunt/grunt_sprite.js","webpack://GEOWars/./src/game_objects/enemies/Pinwheel/pinwheel.js","webpack://GEOWars/./src/game_objects/enemies/Pinwheel/pinwheel_sprite.js","webpack://GEOWars/./src/game_objects/enemies/RandomRandom.js","webpack://GEOWars/./src/game_objects/enemies/Singularity/alien_ship.js","webpack://GEOWars/./src/game_objects/enemies/Singularity/alien_ship_sprite.js","webpack://GEOWars/./src/game_objects/enemies/Singularity/singularity.js","webpack://GEOWars/./src/game_objects/enemies/Singularity/singularity_sprite.js","webpack://GEOWars/./src/game_objects/enemies/Weaver/weaver.js","webpack://GEOWars/./src/game_objects/enemies/Weaver/weaver_sprite.js","webpack://GEOWars/./src/game_objects/particles/Grid/grid.js","webpack://GEOWars/./src/game_objects/particles/Grid/grid_point.js","webpack://GEOWars/./src/game_objects/particles/Grid/grid_sprite.js","webpack://GEOWars/./src/game_objects/particles/Particle/particle.js","webpack://GEOWars/./src/game_objects/particles/Particle/particle_sprite.js","webpack://GEOWars/./src/game_objects/particles/Singularity_Particle/singularity_particle.js","webpack://GEOWars/./src/game_objects/particles/bullet_wall_explosion.js","webpack://GEOWars/./src/game_objects/particles/enemy_spawn.js","webpack://GEOWars/./src/game_objects/particles/particle_explosion.js","webpack://GEOWars/./src/game_objects/particles/ship_explosion.js","webpack://GEOWars/./src/game_objects/particles/singularity_hit_explosion.js","webpack://GEOWars/./src/game_objects/particles/singularity_particles.js","webpack://GEOWars/./src/game_objects/particles/star.js","webpack://GEOWars/./src/game_objects/ship/ship.js","webpack://GEOWars/./src/game_objects/ship/ship_sprite.js","webpack://GEOWars/./src/game_script.js","webpack://GEOWars/./src/game_view.js","webpack://GEOWars/webpack/bootstrap","webpack://GEOWars/webpack/runtime/define property getters","webpack://GEOWars/webpack/runtime/hasOwnProperty shorthand","webpack://GEOWars/webpack/runtime/make namespace object","webpack://GEOWars/./src/GEOWars.js"],"sourcesContent":["import { BoxBox } from \"./game_objects/enemies/BoxBox/boxbox\";\nimport { Pinwheel } from \"./game_objects/enemies/Pinwheel/pinwheel\";\nimport { Arrow } from \"./game_objects/enemies/Arrow/arrow\";\nimport { Grunt } from \"./game_objects/enemies/Grunt/grunt\";\nimport { Weaver } from \"./game_objects/enemies/Weaver/weaver\";\nimport { Singularity } from \"./game_objects/enemies/Singularity/singularity\";\nimport { AlienShip } from \"./game_objects/enemies/Singularity/alien_ship\";\nimport { RandomRandom } from \"./game_objects/enemies/RandomRandom\";\n\nexport class AnimationView {\n    constructor(ctx) {\n        this.ctx = ctx;\n        this.gameObjects = [];\n        this.lineSprites = [];\n        this.zoomScale = 1;\n        this.ship = {\n            transform: {\n                pos: [],\n            },\n        };\n        this.lastTime = 0;\n        this.animate = this.animate.bind(this);\n        this.overlayText = {\n            Location: [0, 0],\n            Time: 0,\n            Type: \"\",\n            StartingAngle: 0,\n        };\n        this.overlayTextCleared = true;\n    }\n\n    enemySelected({type, location, numberToGenerate, possibleSpawns, angle}) {\n        possibleSpawns = possibleSpawns || [];\n        this.overlayTextCleared = false;\n        const locationText = [Math.trunc(location[0].toString()), Math.trunc(location[1]).toString()];\n        this.overlayText = {\n            Location: locationText,\n            Time: 0,\n            Type: type,\n            StartingAngle: angle,\n            RandomCount: numberToGenerate,\n            RandomSelection: [...possibleSpawns]\n        };\n    }\n\n    animate(timeDelta) {\n        this.animateGameObjects(timeDelta);\n        this.clearCanvas();\n        this.renderLineSprites(this.ctx);\n        this.renderOverlayText();\n    }\n\n    renderOverlayText() {\n        if(this.overlayTextCleared) return;\n        this.ctx.save();\n        this.ctx.font = 18 + \"px \" + \"Arial\";\n        this.ctx.fillStyle = \"white\";\n        const typeText = \"Type: \" + this.overlayText.Type;\n        const positionText = \"Location: \" + this.overlayText.Location;\n        const angleText = \"Starting Angle: \" + Math.round(this.overlayText.StartingAngle * 360 / (2 * Math.PI));\n        let randomCountText = false;\n        let randomSelectionText = false;\n        if(this.overlayText.RandomCount) {\n            randomCountText = \"Random Count: \" + this.overlayText.RandomCount;\n            randomSelectionText = \"Random Selections: \";\n        }\n        \n        this.ctx.fillText(\n            typeText,\n            10,\n            20\n        );\n        this.ctx.fillText(\n            positionText,\n            10,\n            38\n        );\n        this.ctx.fillText(\n            angleText,\n            10,\n            56\n        );\n        if (randomCountText) {\n            this.ctx.fillText(\n                randomCountText,\n                10,\n                125\n            );\n            this.ctx.font = \"7px Arial\";\n            this.ctx.fillText(\n                randomSelectionText,\n                10,\n                143\n            );\n            for (let i = 0; i < this.overlayText.RandomSelection.length; i++) {\n                this.ctx.fillText(\n                    this.overlayText.RandomSelection[i].toString(),\n                    10,\n                    150 + i * 7\n                );\n            }\n        }\n        this.ctx.restore();\n    }\n\n\n    animateGameObjects(delta) {\n        this.gameObjects.forEach((object) => {\n            object.animate(delta);\n        });\n    }\n\n    clearCanvas() {\n        this.ctx.clearRect(0, 0, 200, 200);\n        this.ctx.fillStyle = \"#000000\";\n        this.ctx.fillRect(0, 0, 200, 200);\n    }\n\n    clear() {\n        const removeList = [...this.gameObjects];\n        removeList.forEach((gameObject) => {\n            this.remove(gameObject);\n        });\n        this.overlayTextCleared = true;\n    }\n\n    renderLineSprites(ctx) {\n    // ctx.scale = gameEngine.currentCamera.zoomScale\n        this.ctx.save();\n\n        this.ctx.scale(this.zoomScale, this.zoomScale);\n        this.lineSprites.forEach((sprite) => {\n            sprite.draw(ctx);\n        });\n        this.ctx.restore();\n    // ctx.scale(1,1)\n    }\n\n    addGameObject(gameObject) {\n        this.gameObjects.push(gameObject);\n    }\n\n    queueSound(sound) {\n        \n    }\n\n    addCollider() {}\n\n    addPhysicsComponent(physicsComponent) {}\n\n    remove(gameObject) {\n        if (gameObject.lineSprite) {\n            const lineSpriteIndex = this.lineSprites.indexOf(gameObject.lineSprite);\n            if (lineSpriteIndex !== -1) this.lineSprites.splice(lineSpriteIndex, 1);\n        }\n        const index = this.gameObjects.indexOf(gameObject);\n        if (index !== -1) this.gameObjects.splice(index, 1);\n       \n    }\n\n    addLineSprite(lineSprite) {\n        this.lineSprites.push(lineSprite);\n    }\n\n    addEnemy(type) {\n        const enemyMap = {\n            BoxBox: (pos) => new BoxBox(this, pos),\n            Pinwheel: (pos) => new Pinwheel(this, pos),\n            Arrow: (pos, angle) => new Arrow(this, pos, angle),\n            Grunt: (pos) => new Grunt(this, pos, this.ship.transform),\n            Weaver: (pos) => new Weaver(this, pos, this.ship.transform),\n            Singularity: (pos) => new Singularity(this, pos),\n            AlienShip: (pos) => new AlienShip(this, pos, [0, 0], this.ship.transform),\n            RANDOM: (pos) => new RandomRandom(this, pos)\n        };\n        enemyMap[type]([100, 100]);\n    }\n}\n","import { UIElement } from \"../../UI_Element\";\nimport { UILineSprite } from \"../../UI_line_sprite\";\nimport { Transform } from \"../../transform\";\n\nimport {EnemyPlacer, spriteMap} from \"../LevelDesign/EnemyPlacer\";\nimport { Spawn } from \"./Spawn\";\n\n// maybe this is what is created from the serialized version\nexport class Event {\n    constructor(spawns, parentScene, isShipRelative, gameEngine) { \n        // not sure what the type is for spawns here\n        this.type = 'Event';\n        this.parentScene = parentScene;\n        this.numberFactor = 1;\n        this.isShipRelative = isShipRelative;\n        // I think I'll have to create the spawns from the serialized data given here\n        this.spawns = spawns.map((spawn) => new Spawn(spawn, gameEngine)); // this is different than the single spawn thing I have in the mock data\n        // okay now I'm thoroughly confused. I think I have a plain javascript object as spawns, and also\n        // Spawn objects as spawns. \n    }\n\n    update() {\n        this.spawnEverything();\n        this.endEvent();\n    }\n\n    spawnEverything() {\n        this.spawns.forEach((spawn) => {\n            spawn.spawnEvent(this.numberFactor, this.isShipRelative);\n        });\n    }\n    \n    endEvent() {\n        this.parentScene.nextElement();\n    }\n\n    resetToStartingValues() {\n        this.numberFactor = 1;\n    }\n}\n\n// this is what is created by the UI\n// but it will also have to be created by the serialized data\nexport class EventObject extends UIElement {\n    constructor(levelDesigner, eventToLoad, position, parentScene) {\n        super(levelDesigner, position, parentScene);\n        this.spawns = [];\n        this.enemyPlacers = [];\n        this.selectedSpawns = [];\n        this.spawnSprites = {Pinwheel: 0, BoxBox: 0, Arrow: 0, Grunt: 0, Weaver: 0, Singularity: 0, AlienShip: 0, RANDOM: 0};\n        this.widthHeight = [80, 40];\n        this.clickRadius = 20;\n        this.addMouseClickListener();\n        this.isShipRelative = false;\n        \n        if(eventToLoad) {\n            eventToLoad.spawns.forEach((spawn) => this.addSpawn({spawn}));\n            this.isShipRelative = eventToLoad.isShipRelative;\n        }\n        this.addUIElementSprite(new EventObjectSprite(this.UITransform, this.spawnSprites, this.widthHeight));\n        this.levelDesigner.eventLoadShipRelative(this.isShipRelative);\n    }\n\n    // copy and paste should be supported\n    copy() {\n        return this.levelDesigner.addToClipBoard(new EventObject(this.levelDesigner, this.serialize()));\n    }\n\n    copySelectedSpawns() {\n        // I imagine shift click and then copy, and past\n    }\n\n    copyLineSpriteForDragging() {\n        const draggingSpriteTransform = new Transform(null, [this.UITransform.pos[0], this.UITransform.pos[1]]);\n        return new EventObjectSprite(draggingSpriteTransform, this.spawnSprites, this.widthHeight);\n    }\n\n    // this shit needs work\n    deleteSelectedSpawns() {\n        this.selectedSpawns.forEach((spawn) => {\n            this.deleteSpawn(spawn);\n        });\n    }\n\n    deleteYourShit() {\n        this.spawns = [];\n        this.enemyPlacers.forEach((placer) => (placer.remove()));\n        this.enemyPlacers = [];\n    }\n\n    deleteSelectedEnemyPlacers() {\n    }\n\n    makeCoordinatesShipRelative() {\n        this.isShipRelative = true;\n        console.log(this.isShipRelative);\n    }\n\n    makeCoordinatesArenaRelative() {\n        this.isShipRelative = false;\n        console.log(this.isShipRelative);\n    }\n\n    loadSpawns() {\n        this.spawns.forEach((spawn) => {\n            // pretty sure this is a serialized spawn....\n            const enemyPlacer = new EnemyPlacer(this.levelDesigner.engine, spawn, this.levelDesigner, true);\n            enemyPlacer.addMouseClickListener();\n            this.enemyPlacers.push(enemyPlacer);\n        });\n    }\n\n    // copied into engine's clipboard\n    pasteCopiedSpawns(spawns) {\n        spawns.forEach((spawn) => (this.addSpawn(spawn)));\n    }\n\n    serialize() {  \n        return {\n            type: 'Event',\n            spawns: this.spawns,\n            isShipRelative: this.isShipRelative\n        };\n    }\n\n    loadEvent(event) {\n        event.spawns.forEach((spawn) => this.addSpawn({spawn}));\n    }\n\n    addSpawn(spawn) {\n        this.spawns.push(spawn.spawn);\n        this.spawnSprites[spawn.spawn.type] += 1;\n    }\n\n    addRandomRandom(spawn) {\n        const randomRandomAdded = this.spawns.find((spawny) => spawny.type === 'RANDOM');\n        if(randomRandomAdded) {\n            randomRandomAdded.possibleSpawns = spawn.spawn.possibleSpawns;\n            randomRandomAdded.numberToGenerate = spawn.spawn.numberToGenerate;\n            const enemyPlacer = this.enemyPlacers.find((enemyPlacer) => (enemyPlacer.type === 'RANDOM'));\n            enemyPlacer.spawn.numberToGenerate = spawn.spawn.numberToGenerate;\n            enemyPlacer.spawn.possibleSpawns = spawn.spawn.possibleSpawns;\n        } else {\n            this.spawns.push(spawn.spawn);\n            const enemyPlacer = new EnemyPlacer(\n                this.levelDesigner.engine, \n                {\n                    location: 'RANDOM', \n                    type: 'RANDOM', \n                    numberToGenerate: spawn.spawn.numberToGenerate, \n                    possibleSpawns: spawn.spawn.possibleSpawns\n                }, \n                this.levelDesigner, \n                true\n            );\n            this.spawnSprites[spawn.spawn.type] += 1;\n            this.addEnemyPlacer(enemyPlacer);\n        }\n    }\n\n    addEnemyPlacer(enemyPlacer) {\n        this.enemyPlacers.push(enemyPlacer);\n    }\n\n    deleteSpawn(spawn) {\n        const index = this.spawns.indexOf(spawn);\n        if(index !== -1)  {\n            this.spawns.splice(index, 1);\n            this.spawnSprites[spawn.type] -= 1;\n        }\n    }\n\n    deleteEnemyPlacer(enemyPlacer) {\n        const index = this.enemyPlacers.indexOf(enemyPlacer);\n        if(index !== -1) {\n            this.enemyPlacers.splice(index, 1);\n        }\n    }\n\n    onMouseClick(mousePos) {\n        console.log('event object mouse click');\n        this.levelDesigner.eventSelected(this);\n        this.loadSpawns();\n        this.UILineSprite.selected = true;\n    }\n\n    unSelected() {\n        this.enemyPlacers.forEach((enemyPlacer) => enemyPlacer.eventUnselected());\n        this.levelDesigner.eventUnselected();\n        this.UILineSprite.selected = false;\n    }\n\n    onMouseDoubleClicked(mousePos) {\n        console.log('yay mouse double clicked here');\n    }\n\n    update() {\n    }\n}\n\nexport class EventObjectSprite extends UILineSprite {\n    constructor(UITransform, spawnSprites, widthHeight) {\n        super(UITransform);\n        this.selected = true;\n        this.expanded = true;\n        this.spawnSprites = spawnSprites;\n        this.widthHeight = widthHeight;\n\n        this.firstPosition = [10,10];\n        this.secondPosition = [30,10];\n        this.thirdPosition = [50,10];\n\n        this.fourthPosition = [10,30];\n        this.fifthPosition = [30,30];\n        this.sixthPosition = [50,30];\n\n        this.seventhPosition = [70,10];\n\n        this.spawnSpriteMap = {\n            BoxBox: spriteMap['BoxBox'](new Transform(null, this.firstPosition)),\n            Arrow: spriteMap['Arrow'](new Transform(null, this.secondPosition)),\n            Grunt: spriteMap['Grunt'](new Transform(null, this.thirdPosition)),\n\n            Pinwheel: spriteMap['Pinwheel'](new Transform(null, this.fourthPosition)),\n            Weaver: spriteMap['Weaver'](new Transform(null, this.fifthPosition)),\n            Singularity: spriteMap['Singularity'](new Transform(null, this.sixthPosition)),\n            RANDOM: spriteMap['RANDOM'](new Transform(null, this.seventhPosition)),\n        };\n\n        // change the sprites to have spawning scale be 0.5\n        Object.keys(this.spawnSpriteMap).forEach((key) => {\n            this.spawnSpriteMap[key].spawningScale = 0.5;\n        });\n    }\n\n    draw(ctx) {\n        const pos = this.UITransform.pos;\n        ctx.save();\n        ctx.translate(pos[0], pos[1]);\n\n        this.drawFunction(ctx);\n        ctx.restore();\n    }\n\n    drawFunction(ctx) {\n        const h = this.widthHeight[1];\n        const w = this.widthHeight[0];\n\n        ctx.fillStyle = \"#000000\";\n\n        ctx.fillRect(0, 0, w, h);\n\n        ctx.lineWidth = this.selected ? 3 : 1;\n        ctx.strokeStyle = \"#FFFFFF\";\n        ctx.beginPath();\n        ctx.moveTo(0,0);\n        ctx.lineTo(w,0);\n        ctx.lineTo(w,h);\n        ctx.lineTo(0,h);\n        ctx.closePath();\n        ctx.stroke();\n\n        // should add Alien too\n        // BoxBox, then Pinwheel, then Grunt, then Arrow, then Weaver, then Singularity\n\n        // BoxBox location: 5,5\n        // Grunt location: 10,5\n        // Arrow location: 15,5\n        const BoxBoxSprite = this.spawnSpriteMap['BoxBox'];\n        const ArrowSprite = this.spawnSpriteMap['Arrow'];\n        const GruntSprite = this.spawnSpriteMap['Grunt'];\n\n        const PinwheelSprite = this.spawnSpriteMap['Pinwheel'];\n        const WeaverSprite = this.spawnSpriteMap['Weaver'];\n        const SingularitySprite = this.spawnSpriteMap['Singularity'];\n        const RandomRandomSprite = this.spawnSpriteMap['RANDOM'];\n\n        this.spawnSprites.BoxBox > 0 ? BoxBoxSprite.makeVisible() : BoxBoxSprite.makeInvisible();\n        this.spawnSprites.Arrow > 0 ? ArrowSprite.makeVisible() : ArrowSprite.makeInvisible();\n        this.spawnSprites.Grunt > 0 ? GruntSprite.makeVisible() : GruntSprite.makeInvisible();\n\n        this.spawnSprites.Pinwheel > 0 ? PinwheelSprite.makeVisible() : PinwheelSprite.makeInvisible();\n        this.spawnSprites.Weaver > 0 ? WeaverSprite.makeVisible() : WeaverSprite.makeInvisible();\n        this.spawnSprites.Singularity > 0 ? SingularitySprite.makeVisible() : SingularitySprite.makeInvisible();\n\n        this.spawnSprites.RANDOM > 0 ? RandomRandomSprite.makeVisible() : RandomRandomSprite.makeInvisible();\n\n\n        BoxBoxSprite.draw(ctx);\n        ArrowSprite.draw(ctx);\n        GruntSprite.draw(ctx);\n\n        PinwheelSprite.draw(ctx);\n        WeaverSprite.draw(ctx);\n        SingularitySprite.draw(ctx);\n\n        RandomRandomSprite.draw(ctx);\n    }\n}\n\n","import { UIElement } from \"../../UI_Element\";\nimport { UILineSprite } from \"../../UI_line_sprite\";\nimport { Transform } from \"../../transform\";\n\n// loop, wait, \n\n// maybe I should have a loop beginner and a loop ender repeater thingy\n// like in music\n\n// maybe when the game sequence comes across the beginning of a loop it will store that loop\n// and then when it comes across the end of the loop it will check if the loop is done\n// if it is it will move on, if not it will go back to the beginning of the loop\nexport class LoopEnd {\n    // can only loop if start and end of loop are in the same scene\n    constructor(loop, parentScene) {\n        this.type === \"LoopEnd\";\n        this.parentScene = parentScene; // scene the loop is in\n        \n        this.startingLoopValues = {\n            loopIdx: loop.loopIdx || 0, // could probably default to 0. this is how many times it's looped\n            // during the level edit process, whenever a loop is added\n            // it will increment the loopId. This way beginning loops and end loops will always \n            // have matching loopIds without collision\n            loopId: parentScene.getLoopId(),\n            repeatTimes: loop.repeatTimes\n        };\n        this.loop = { // {loopIdx, loopId, repeatTimes}\n            loopIdx: this.startingLoopValues.loopIdx,\n            loopId: this.startingLoopValues.loopId,\n            repeatTimes: this.startingLoopValues.repeatTimes\n        }; \n    }\n\n    update() {\n        if(this.loop.loopIdx >= this.loop.repeatTimes) { // 3: 0, 1, 2\n            this.endLoop();\n        } else {\n            this.loop.loopIdx++;\n            this.parentScene.goToLoopId(this.loop.loopId);\n                \n        }\n    }\n\n    resetToStartingValues() {\n        this.loop =  {\n            loopIdx: this.startingLoopValues.loopIdx,\n            loopId: this.startingLoopValues.loopId,\n            repeatTimes: this.startingLoopValues.repeatTimes\n        };\n    }\n\n\n    endLoop() {\n        this.resetToStartingValues();\n        this.parentScene.nextElement();\n    }\n}\n\nexport class LoopBeginning {\n    constructor(parentScene) {\n        this.type = \"LoopBeginning\";\n        this.parentScene = parentScene;\n        this.loopId = this.parentScene.createLoopId();\n    }\n    update() {\n        this.parentScene.nextElement();\n        // this means the next step will be delayed by a frame waiting\n        // for the next update call\n    }\n    resetToStartingValues() {}\n}\n\n// UIElement\nexport class LoopBeginningObject extends UIElement {\n    constructor(levelDesigner, loop, position, parentScene) {\n        super(levelDesigner, position, parentScene);\n        this.widthHeight = [10, 40];\n        this.clickRadius = 5;\n        this.addMouseClickListener();\n        this.addUIElementSprite(new LoopBeginningObjectSprite(this.UITransform, this.widthHeight));\n        this.endLoopObject = undefined;\n    }\n\n    moveLeft() {\n        this.levelDesigner.moveLeft(this);\n    }\n\n    moveRight() {\n        this.levelDesigner.moveRight(this);\n    }\n\n    copy() {\n        // not sure how to create a new loop id if I'm copying a loop\n        return this.levelDesigner.addToClipBoard(new LoopBeginningObject(this.levelDesigner, this.serialize()));\n    }\n\n    copyLineSpriteForDragging() {\n        const draggingSpriteTransform = new Transform(null, [this.UITransform.pos[0], this.UITransform.pos[1]]);\n        return new LoopBeginningObjectSprite(draggingSpriteTransform, this.widthHeight);\n    }\n    \n\n    serialize() {\n        return {\n            type: \"LoopBeginning\"\n        };\n    }\n\n    onMouseClick() {\n        console.log('loop beginning clicked');\n        this.levelDesigner.loopSelected(this);\n        this.UILineSprite.selected = true;\n    }\n    unSelected() {\n        this.UILineSprite.selected = false;\n    }\n\n    deleteYourShit() {\n        const endObject = this.endLoopObject;\n        this.endLoopObject = undefined;\n        endObject?.delete();\n    }\n}\n\nexport class LoopEndObject extends UIElement {\n    constructor(levelDesigner, loop, position, parentScene) {\n        super(levelDesigner, position, parentScene);\n        this.loop = loop;\n        this.widthHeight = [30, 40];\n        this.clickRadius = 15;\n        this.addMouseClickListener();\n        this.addUIElementSprite(new LoopEndingObjectSprite(this.UITransform, this.widthHeight, this.loop.repeatTimes));\n        this.beginningLoopObject = undefined;\n    }\n\n    // maybe I can have a button that moves it left or right for now\n    // until I get drag and drop going\n\n    changeRepeatTimes(newRepeatTimes) {\n        this.loop.repeatTimes = newRepeatTimes;\n    }\n\n    changeStartingRepeatIndex(newRepeatIndex) {\n        this.loop.repeatIndex = newRepeatIndex;\n    }\n\n    copy() {\n        /// ohhhhh we don't care about the ids yet since they are \n        // made in runtime\n        // okay maybe we do because we might want to have matching colors\n        // another time\n        return this.levelDesigner.addToClipBoard(new LoopEndObject(this.levelDesigner, this.serialize()));\n    }\n\n    copyLineSpriteForDragging() {\n        const draggingSpriteTransform = new Transform(null, [this.UITransform.pos[0], this.UITransform.pos[1]]);\n        return new LoopEndingObjectSprite(draggingSpriteTransform, this.widthHeight, this.loop.repeatTimes);\n    }\n    \n\n    serialize() {\n        return {\n            type: \"LoopEnd\",\n            loopIdx: this.loop.loopIdx,\n            repeatTimes: this.loop.repeatTimes\n        };\n    }\n    onMouseClick() {\n        console.log('loop end clicked');\n        this.levelDesigner.loopSelected(this);\n        this.UILineSprite.selected = true;\n    }\n    unSelected() {\n        this.UILineSprite.selected = false;\n    }\n\n    deleteYourShit() {\n        const beginningObject = this.beginningLoopObject;\n        this.beginningLoopObject = undefined;\n        beginningObject?.delete();\n    }\n}\n\n\nexport class LoopBeginningObjectSprite extends UILineSprite {\n    constructor(UITransform, widthHeight) {\n        super(UITransform);\n        this.selected = false;\n        this.widthHeight = widthHeight;\n    }\n\n    draw(ctx) {\n        const pos = this.UITransform.pos;\n        ctx.save();\n        ctx.translate(pos[0], pos[1]);\n        this.drawFunction(ctx);\n        ctx.restore();\n    }\n\n    drawFunction(ctx) {\n        const h = this.widthHeight[1];\n        const w = this.widthHeight[0];\n\n        ctx.fillStyle = \"#FFD700\";\n        ctx.fillRect(0, 0, w, h);\n\n        const lineWidth = this.selected ? 3 : 1;\n\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = \"#FFFFFF\";\n        ctx.strokeRect(0 + lineWidth / 2, 0 + lineWidth / 2, w - lineWidth / 2, h - lineWidth / 2);\n    }\n\n}\n\n\nexport class LoopEndingObjectSprite extends UILineSprite {\n    constructor(UITransform, widthHeight, repeatTimes) {\n        super(UITransform);\n        this.widthHeight = widthHeight;\n        this.repeatTimes = repeatTimes;\n        this.selected = false;\n    }\n\n    draw(ctx) {\n        const pos = this.UITransform.pos;\n        ctx.save();\n        \n        ctx.translate(pos[0], pos[1]);\n        this.drawFunction(ctx);\n    \n        ctx.restore();\n    }\n\n    drawFunction(ctx) {\n        const h = this.widthHeight[1];\n        const w = this.widthHeight[0];\n\n        ctx.fillStyle = \"#FFD700\";\n        ctx.fillRect(0, 0, w, h);\n\n        ctx.lineWidth = this.selected ? 3 : 1;\n        ctx.strokeStyle = \"#FFFFFF\";\n        ctx.strokeRect(0,0, w, h);\n\n        ctx.fillStyle = \"#000000\";\n        ctx.font = \"10px Arial\";\n        ctx.fillText(this.repeatTimes, 2, this.widthHeight[1]/2);\n    }\n\n}","import { UIElement } from \"../../UI_Element\";\nimport { UILineSprite } from \"../../UI_line_sprite\";\nimport { Transform } from \"../../transform\";\n\nexport class Operation {\n    constructor(operand, parentScene, gameEngine, gameScript) {\n        this.operand = operand;\n        this.parentScene = parentScene;\n        this.gameEngine = gameEngine;\n        this.gameScript = gameScript;\n    }\n\n    update() {\n        this.doOperation();\n    }\n\n    doOperation() {\n        if(this.operand.type === \"SceneTimeFactor\") {\n            this.parentScene.gameElements.forEach((element) => {\n                this.applyTimeFactor(element);\n            });\n        } else if(this.operand.type === \"SceneNumberFactor\") {\n            this.parentScene.gameElements.forEach((element) => {\n                this.applyNumberFactor(element);\n            });\n        } else if (this.operand.type === \"ResetToStartingValues\") {\n            this.parentScene.gameElements.forEach((element) => {\n                this.applyResetToStartingValues(element);\n            });\n        } else if (this.operand.type === \"UpgradeBullets\") {\n            this.gameScript.ship.upgradeBullets();\n        }\n\n        this.parentScene.nextElement();\n    }\n\n    applyNumberFactor(element) {\n        if(element.type === \"Event\") {\n            element.numberFactor *= this.operand.factor;\n        }\n        if(element.type === \"Scene\") {\n            element.gameElements.forEach((element) => {\n                this.applyNumberFactor(element);\n            });\n        }\n    }\n\n    applyTimeFactor(element) {\n        if(element.type === \"Time\") {\n            element.applyNewTimeFactor(this.operand.factor);\n        }\n        if(element.type === \"Scene\") {\n            element.gameElements.forEach((element) => {\n                this.applyTimeFactor(element);\n            });\n        }\n    }\n\n    applyResetToStartingValues(element) {\n        if(element.type === \"Scene\") {\n            element.gameElements.forEach((element) => {\n                this.applyResetToStartingValues(element);\n            });\n        }\n        if(element.type === \"Time\" || element.type === \"Event\" || element.type === \"LoopEnd\" || element.type === \"LoopBeginning\" || element.type === \"Operation\") {\n            element.resetToStartingValues();\n        }\n    }\n\n    resetToStartingValues() {\n        \n    }\n}\n\nexport class OperationObject extends UIElement {\n    constructor(levelDesigner, operationToLoad, position, parentScene) {\n        super(levelDesigner, position, parentScene);\n        this.operand = operationToLoad;\n        this.widthHeight = [50, 40];\n        this.clickRadius = 20;\n        this.addMouseClickListener();\n        this.addUIElementSprite(new OperationObjectSprite(this.UITransform, this.widthHeight, this.operand));\n    }\n\n    unSelected() {\n        this.UILineSprite.selected = false;\n    }\n\n    copy() {\n        return this.levelDesigner.addToClipBoard(new OperationObject(this.levelDesigner, this.serialize()));\n    }\n\n    copyLineSpriteForDragging() {\n        const draggingSpriteTransform = new Transform(null, [this.UITransform.pos[0], this.UITransform.pos[1]]);\n        return new OperationObjectSprite(draggingSpriteTransform, this.widthHeight, this.operand);\n    }\n\n    serialize() {\n        return {\n            type: \"Operation\",\n            operand: {\n                type: this.operand.type,\n                factor: this.operand.factor\n            }\n        };\n    }\n\n    changeOperation(newOperand) {\n        this.operand = {\n            type: newOperand.type,\n            factor: newOperand.factor\n        };\n        this.UILineSprite.operand = this.operand;\n    }\n\n    onMouseClick() {\n        this.levelDesigner.operationSelected(this);\n        this.UILineSprite.selected = true;\n    }\n}\n\nexport class OperationObjectSprite extends UILineSprite {\n    constructor(UITransform, widthHeight, operand) {\n        super(UITransform);\n        this.operand = operand;\n        this.widthHeight = widthHeight;\n        this.selected = false;\n    }\n\n    draw(ctx) {\n        const pos = this.UITransform.pos;\n        ctx.save();\n        ctx.translate(pos[0], pos[1]);\n        this.drawFunction(ctx, pos);\n        ctx.restore();\n    }\n\n    drawFunction(ctx) {\n        const h = this.widthHeight[1];\n        const w = this.widthHeight[0];\n        \n        ctx.fillStyle = \"tomato\";\n        if(this.selected) ctx.fillStyle = \"#419ef0\";\n        ctx.fillRect(0, 0, w, h);\n        ctx.fillStyle = \"rgba(0, 0, 0, 1)\";\n        ctx.font = \"10px Arial\";\n        ctx.fillText(this.operand.type, 2, h/2);\n        ctx.fillText(this.operand.factor, 2, 4 * h / 4);\n    }\n}","import { UILineSprite } from \"../../UI_line_sprite\";\nimport { UIElement } from \"../../UI_Element\";\nimport { Transform } from \"../../transform\";\n\n// there will have to be an ancestor scene that holds all the scenes and stuffs\nexport class Scene {\n    constructor(parentScene, name, gameElements, currentElementIndex) {\n        this.parentScene = parentScene;\n        this.type = \"Scene\";\n        this.name = name || \"\";\n        this.gameElements = gameElements || [];\n        this.currentElementIndex = currentElementIndex || 0;\n        this.loopId = 0;\n        this.loopsToClose = [];\n    }\n    /*\n    stack works I believe\n    1 2 2 1 3 4 4 3\n    [ [ ] ] [ [ ] ]\n    */\n    createLoopId() {\n        this.loopId++;\n        this.loopsToClose.push(this.loopId);\n        return this.loopId;\n    }\n    getLoopId() {\n        return this.loopsToClose.pop();  \n    }\n\n\n    update(dT) {\n        this.gameElements[this.currentElementIndex]?.update(dT);\n    }\n\n    nextElement() {\n        if(this.currentElementIndex < this.gameElements.length - 1) {\n            this.currentElementIndex++;\n        } else {\n            this.currentElementIndex = 0;\n            this.parentScene.nextElement();\n        }\n    }\n\n    goToLoopId(loopId) {\n        this.gameElements.forEach((element, idx) => {\n            if(element.loopId === loopId) {\n                this.currentElementIndex = idx;\n            }\n        });\n    }\n}\n\nexport class SceneObject extends UIElement {\n    constructor(levelDesigner, name, parentScene, position) {\n        super(levelDesigner, position, parentScene);\n        // i'll have to create the game elements from the serialized data\n        this.gameElements = [];\n        \n        this.expanded = false;\n        this.widthHeight = [40,40];\n        this.name = name || \"Scene\";\n        this.addUIElementSprite(new SceneSprite(name, this.UITransform, this.widthHeight));\n        this.clickRadius = 20;\n        this.addMouseClickListener();\n        this.addMouseDoubleClickListener();\n        \n    }\n\n    expandScene() {\n        this.expanded = true;\n        this.UILineSprite.expanded = true;\n        this.levelDesigner.expandScene(this);\n    }\n\n    unExpandScene() {\n        this.expanded = false;\n        this.UILineSprite.expanded = false;\n        this.levelDesigner.unExpandScene(this);\n    }\n\n    copyLineSpriteForDragging() {\n        const draggingSpriteTransform = new Transform(null, [this.UITransform.pos[0], this.UITransform.pos[1]]);\n        return new SceneSprite(this.name, draggingSpriteTransform, this.widthHeight);\n    }\n\n    copy() {\n        return this.levelDesigner.addToClipBoard(new SceneObject(this.levelDesigner, this.serialize()));\n    }\n\n    loadGameElements(gameElements) {\n        this.gameElements = this.levelDesigner.loadGameElements(gameElements, false, this);\n    }\n\n    serialize() {\n        return {\n            type: 'Scene',\n            name: this.name,\n            gameElements: this.gameElements.map((element) => element.serialize()),\n        };\n    }\n\n    onMouseClick() {\n        this.levelDesigner.sceneSelected(this);\n        this.UILineSprite.selected = true;\n    }\n    onMouseDoubleClicked() {\n        this.expanded ? this.unExpandScene() : this.expandScene();\n        \n    }\n\n    selected() {\n        this.UILineSprite.selected = true;\n    }\n\n    unSelected() {\n        this.UILineSprite.selected = false;\n    }\n\n    deleteYourShit() {\n        this.gameElements.forEach((element) => {\n            element.delete();\n        });\n    }\n\n    removeUIElement(element) {\n        const index = this.gameElements.indexOf(element);\n        if(index !== -1) this.gameElements.splice(index, 1);\n    }\n\n}\n\nexport class SceneSprite extends UILineSprite {\n    constructor(name, UITransform, widthHeight) {\n        super(UITransform);\n        this.name = name;\n        this.widthHeight = widthHeight;\n        this.selected = false;\n        this.expanded = false;\n    }\n\n    draw(ctx) {\n        const pos = this.UITransform.pos;\n        ctx.save();\n        ctx.translate(pos[0], pos[1]);\n\n        this.drawFunction(ctx, pos);\n        ctx.restore();\n    }\n\n    drawFunction(ctx) {\n        const h = this.widthHeight[1];\n        const w = this.widthHeight[0];\n        ctx.fillStyle = \"#d3d3d3\";\n        if(this.selected) ctx.fillStyle = \"#419ef0\";\n        if(this.expanded) ctx.fillStyle = \"#A020F0\";\n        // I can add lines to the top and sides to show that it's expanded\n        ctx.fillRect(0, 0, w, h);\n        ctx.fillStyle = \"rgba(0, 0, 0, 1)\";\n        ctx.font = \"10px Arial\";\n        ctx.fillText(this.name, 2, h/2);\n\n        if(this.expanded) {\n            ctx.lineWidth = 3;\n            ctx.strokeStyle = \"#FFFFFF\";\n            ctx.beginPath();\n            ctx.moveTo(0, h);\n            ctx.lineTo(0, 0);\n            ctx.lineTo(w, 0);\n            ctx.lineTo(w, h);\n            ctx.stroke();\n        }\n    }\n}\n\n","// a single enemy, and location\nexport class Spawn { \n    constructor(spawn, gameEngine) { // spawn: {type, location: [x,y]} \n        this.spawn = spawn;\n        //  spawn: {\n        //     type: 'RANDOM',\n        //     location: 'RANDOM',\n        //     possibleSpawns: ['Weaver', 'Grunt']\n        //     angle: 'PI/3'\n        // }\n        this.gameEngine = gameEngine;\n    }\n\n    // start with known positions entered first, \n    // then we can easily add random and the buttons needed for that\n\n    // these random functions should be in the Event class I think\n\n    randomPosition() {\n        return [\n            this.gameEngine.gameScript.DIM_X * 0.95 * Math.random(),\n            this.gameEngine.gameScript.DIM_Y * 0.90 * Math.random(),\n        ];\n    }\n\n    randomMob(possibleSpawns) {\n        return possibleSpawns[Math.floor(Math.random() * possibleSpawns.length) % possibleSpawns.length];\n    }\n\n    spawnEvent(numberFactor, isShipRelative) {\n        const numberToGenerate = Math.trunc(this.spawn.numberToGenerate * numberFactor) || 1;\n\n        for(let i = 0; i < numberToGenerate; i++) {\n            let mobToSpawn = this.spawn.type;\n            let location;\n            if(mobToSpawn === 'RANDOM') {\n                mobToSpawn = this.randomMob(this.spawn.possibleSpawns);\n            }\n            if(this.spawn.location === 'RANDOM') {\n                location = this.randomPosition();\n            } else {\n                location = [Number(this.spawn.location[0]), Number(this.spawn.location[1])];\n                if(isShipRelative) {\n                    location[0] += this.gameEngine.gameScript.ship.transform.pos[0] - this.gameEngine.gameScript.DIM_X / 2;\n                    location[1] += this.gameEngine.gameScript.ship.transform.pos[1] - this.gameEngine.gameScript.DIM_Y / 2;\n\n                    // check if off edge of map\n                    if(location[0] > this.gameEngine.gameScript.DIM_X  - 100) {\n                        location[0] = this.gameEngine.gameScript.DIM_X - 100;\n                    } else if(location[0] < 100) {\n                        location[0] = 100;\n                    }\n                    \n                    if( location[1] > this.gameEngine.gameScript.DIM_Y - 100)  {\n                        location[1] = this.gameEngine.gameScript.DIM_Y - 100;\n                    } else if(location[1] < 0 + 100) {\n                        location[1] = 0 + 100;\n                    }\n                }\n            }\n            this.gameEngine.gameScript.enemyCreatorList[mobToSpawn](location);\n        }\n    }\n\n    // serialize() {\n    //     return {\n    //         type: \"Spawn\",\n    //         spawn: this.spawn\n    //     };\n    // }\n}","import { UIElement } from \"../../UI_Element\";\nimport { UILineSprite } from \"../../UI_line_sprite\";\nimport { Transform } from \"../../transform\";\n\n// wait times\nexport class Time {\n    constructor(parentScene, waitTime) {\n        this.type = \"Time\";\n        this.parentScene = parentScene;\n        this.waitTime = waitTime;\n        this.timeFactor = 1;\n        this.time = 0;\n        this.startingValues = {\n            time: 0,\n            waitTime: waitTime,\n            timeFactor: 1,\n        };\n    }\n\n    // I'll have to make sure pausing doesn't fuck this up\n    update(dT) {\n        // maybe I just check if it's paused?\n        this.time += dT;\n        if(this.time >= this.waitTime * this.timeFactor) {\n            this.endOperation();\n        }\n    }\n\n    applyNewTimeFactor(factor) {\n        this.timeFactor *= factor;\n    }\n\n    resetToStartingValues() {\n        this.time = this.startingValues.time;\n        this.waitTime = this.startingValues.waitTime;\n        this.timeFactor = this.startingValues.timeFactor;\n    }\n\n    endOperationReset() {\n        this.time = this.startingValues.time;\n        this.waitTime = this.startingValues.waitTime;\n        // keep time factor\n    }\n\n    endOperation() {\n        this.endOperationReset();\n        \n        // this will have to be the scene it's in I think\n        this.parentScene.nextElement();\n    }\n\n}\n\n// UIElement\nexport class TimeObject extends UIElement {\n    constructor(levelDesigner, {waitTime}, position, parentScene) {\n        super(levelDesigner, position, parentScene);\n        this.waitTime = waitTime;\n        this.widthHeight = [50, 40];\n        this.clickRadius = 20;\n        this.addMouseClickListener();\n        this.addUIElementSprite(new TimeObjectSprite(this.UITransform, this.waitTime, this.widthHeight));\n    }\n\n    unSelected() {\n        this.UILineSprite.selected = false;\n    }\n\n    copy() {\n        return this.levelDesigner.addToClipBoard(new TimeObject(this.levelDesigner, this.serialize()));\n    }\n\n    copyLineSpriteForDragging() {\n        const draggingSpriteTransform = new Transform(null, [this.UITransform.pos[0], this.UITransform.pos[1]]);\n        return new TimeObjectSprite(draggingSpriteTransform, this.waitTime, this.widthHeight);\n    }\n    serialize() {\n        return {\n            type: \"Time\",\n            waitTime: this.waitTime,\n        };\n    }\n\n    changeTime(newTime) {\n        this.waitTime = newTime;\n        this.UILineSprite.waitTime = newTime;\n    \n    }\n    onMouseClick() {\n        this.levelDesigner.timeSelected(this);\n        this.UILineSprite.selected = true;\n    }\n}\n\n\nexport class TimeObjectSprite extends UILineSprite {\n    constructor(UITransform, waitTime, widthHeight) {\n        super(UITransform);\n        this.waitTime = waitTime;\n        this.widthHeight = widthHeight;\n        this.selected = false;\n    }\n\n    draw(ctx) {\n        const pos = this.UITransform.pos;\n        ctx.save();\n        ctx.translate(pos[0], pos[1]);\n\n        this.drawFunction(ctx);\n        ctx.restore();\n    }\n\n    drawFunction(ctx) {\n        const h = this.widthHeight[1];\n        const w = this.widthHeight[0];\n        \n        ctx.fillStyle = \"#A020F0\";\n        if(this.selected) ctx.fillStyle = \"#419ef0\";\n        ctx.fillRect(0, 0, w, h);\n        ctx.fillStyle = \"rgba(0, 0, 0, 1)\";\n        ctx.font = \"10px Arial\";\n        ctx.fillText(this.waitTime, 2, h/2);\n    }\n}","// while placing, could do spawning animation over mouse position\n// once placed, draw it at the placed location\n// store the location\n\n// maybe I need a nested canvas for the pallet\n\n// load spawn event\n// save spawn event\n// create spawn event\nimport { GameObject } from \"../../game_object\";\n\nimport { PlacingAnimation } from \"./PlacingAnimation\";\nimport { BoxBoxSprite } from \"../../../game_objects/enemies/BoxBox/boxbox_sprite\";\nimport { ArrowSprite } from \"../../../game_objects/enemies/Arrow/arrow_sprite\";\nimport { GruntSprite } from \"../../../game_objects/enemies/Grunt/grunt_sprite\";\nimport { PinwheelSprite } from \"../../../game_objects/enemies/Pinwheel/pinwheel_sprite\";\nimport { WeaverSprite } from \"../../../game_objects/enemies/Weaver/weaver_sprite\";\nimport { SingularitySprite } from \"../../../game_objects/enemies/Singularity/singularity_sprite\";\nimport { RandomRandomSprite } from \"../../../game_objects/enemies/RandomRandom\";\nimport { Util } from \"../../util\";\n\n// should add Alien too\nexport const spriteMap = {\n    BoxBox: (transform) => {\n        const _BoxBoxSprite = new BoxBoxSprite(transform);\n        _BoxBoxSprite.spawning = true;\n        return _BoxBoxSprite;\n    },\n    Arrow: (transform) => new ArrowSprite(transform),\n    Grunt: (transform) => new GruntSprite(transform),\n    Pinwheel: (transform) => new PinwheelSprite(transform),\n    Weaver: (transform) => new WeaverSprite(transform),\n    Singularity: (transform) => new SingularitySprite(transform),\n    RANDOM: (transform) => new RandomRandomSprite(transform),\n};\n\n// if trying to spawn multiple things on top of each other, I should only grab the first placer that is found in the click colission\nconst getClickRadius = {\n    BoxBox: 10,\n    Arrow: 10,\n    Grunt: 10,\n    Pinwheel: 10,\n    Weaver: 10,\n    Singularity: 10,\n    RANDOM: 10,\n};\n\nexport class EnemyPlacer extends GameObject {\n    constructor(engine, spawn, levelDesigner, loadingEvent) {\n        super(engine);\n        const {type, location, numberToGenerate, possibleSpawns, angle} = spawn;\n        this.addLineSprite(spriteMap[type](this.transform));\n        this.levelDesigner = levelDesigner;\n        this.clickRadius = getClickRadius[type];\n        this.type = type;\n        \n        if(loadingEvent) {\n            if(location === \"RANDOM\") {\n                this.transform.pos[0] = 500;\n                this.transform.pos[1] = 500;\n                this.spawn = {type: \"RANDOM\", location: \"RANDOM\", numberToGenerate, possibleSpawns};\n                this.addMouseClickListener();\n            } else {\n                this.transform.pos[0] = location[0];\n                this.transform.pos[1] = location[1];\n                this.transform.angle = angle;\n                this.spawn = spawn;\n            }   \n            this.originalClickComplete = true;\n        } else {\n            this.originalClickComplete = false;\n            this.addChildGameObject(new PlacingAnimation(this.gameEngine));\n        }\n    }\n\n    place() {\n        this.spawn = {type: this.type, location: this.transform.pos};\n        const spawn = this.spawn;\n        this.levelDesigner.addSpawnToEvent(spawn, this);\n        this.levelDesigner.enemyPlaced(spawn);\n        this.removeMousePosListener();\n        this.addMouseClickListener();\n    }\n\n    setCoordinates(x, y, angle) {\n        const radiansAngle = angle * Math.PI / 180;\n        this.transform.pos[0] = x || this.transform.pos[0];\n        this.transform.pos[1] = y || this.transform.pos[1];\n        this.transform.angle = radiansAngle || this.transform.angle;\n        this.spawn.angle = radiansAngle || this.spawn.angle;\n    }\n\n    setRandomCoordinates() {\n        this.transform.pos[0] = this.gameEngine.gameScript.DIM_X * 0.85 * Math.random();\n        this.transform.pos[1] = this.gameEngine.gameScript.DIM_Y * 0.85 * Math.random();\n        this.transform.angle = Math.random() * Math.PI * 2;\n        this.spawn.angle = this.transform.angle;\n    }\n\n    eventUnselected() {\n        this.remove();\n    }\n\n\n\n    addMouseClickListener() {\n        this.gameEngine.addClickListener(this);\n    }\n\n\n    mouseClicked(mousePos) {\n        const centerDist = Util.dist(\n            this.transform.pos,\n            mousePos\n        );\n        if (centerDist < this.clickRadius) {\n            this.onMouseClick(mousePos);\n        }\n    }\n\n    onMouseClick(mousePos) {\n        if (this.originalClickComplete) {\n            this.levelDesigner.enemyPlacerClicked(this);\n        } else {\n            this.originalClickComplete = true;\n        }\n    }\n\n\n\n}\n\n","import { GameObject } from \"../../game_object\";\n\nexport class PlacingAnimation extends GameObject {\n    constructor(engine) {\n        super(engine);\n        this.initialSpawningScale = 1.5;\n        this.cycleSpeed = 0.1;\n        this.addClickListener();\n        this.addMousePosListener();\n    }\n\n    // Mouse handling should call this I think?\n    placeEnemy() {\n        this.parentObject.place();\n        this.parentObject.lineSprite.spawningScale = 1;\n        this.remove();\n        this.parentObject.levelDesigner.addAnotherEnemy(this.parentObject.type);\n    }\n\n    updateMousePos(mousePos) {\n        this.parentObject.transform.pos[0] = mousePos[0];\n        this.parentObject.transform.pos[1] = mousePos[1];\n    }\n\n    mouseDoubleClicked() {\n        \n    }\n\n    mouseClicked(mousePos) {\n        this.placeEnemy();\n    }\n\n    update(timeDelta) {\n        const cycleSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n\n        if (this.parentObject.lineSprite.spawningScale < 0.7) {\n            this.parentObject.lineSprite.spawningScale = this.initialSpawningScale;\n        } else {\n            this.parentObject.lineSprite.spawningScale -=\n        this.cycleSpeed * cycleSpeedScale;\n        }\n    }\n}\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n","import { Walls } from \"../../game_objects/Walls/walls\";\nimport { Overlay } from \"../../game_objects/Overlay/overlay\";\nimport { Grid } from \"../../game_objects/particles/Grid/grid\";\nimport { EnemyPlacer } from \"./LevelDesign/EnemyPlacer\";\nimport { GameScript } from \"../../game_script\";\nimport { Transform } from \"../transform\";\nimport { SceneObject } from \"./DesignElements/Scene\";\nimport { Spawn } from \"./DesignElements/Spawn\";\n\nimport { EventObject } from \"./DesignElements/Event\";\nimport { TimeObject } from \"./DesignElements/Time\";\nimport { LoopBeginningObject, LoopEndObject } from \"./DesignElements/Loop\";\nimport { OperationObject } from \"./DesignElements/Operation\";\n\n// I should collect placed enemies\n\n\n// for a tracker I can highlight the current game element\n// just like selecting it... but maybe the same color for \n// all of them \nexport class LevelDesigner {\n    constructor(engine, animationView, levelDesignerCtx, animationWindow, serializedGame) {\n        this.serializedGame = serializedGame;\n        this.UIElementSprites = [];\n\n        // duck typing for scene\n        this.gameElements = []; // top level list of game elements\n        this.expandedScenes = [this];\n        this.UITransform = {pos: [0,0]};\n\n        this.widthHeight = [0,0];\n\n        this.loopBeginningObjectStackForLoading = [];\n\n        this.DIM_X = 1200;\n        this.DIM_Y = 300;\n        this.BG_COLOR = \"#000000\";\n        this.engine = engine;\n        this.animationView = animationView;\n        this.levelDesignerCtx = levelDesignerCtx;\n\n        this.animationWindow = animationWindow;\n        this.UIActionsToRun = [];\n\n        this.ctx = levelDesignerCtx;\n        this.gameObjects = [];\n        this.lineSprites = [];\n        this.zoomScale = 1;\n        this.ship = {\n            transform: {\n                pos: [],\n            },\n        };\n        this.lastTime = 0;\n        this.animate = this.animate.bind(this);\n        this.overlayText = {\n            Location: [0, 0],\n            Time: 0,\n            Type: \"\",\n            StartingAngle: 0,\n        };\n        this.overlayTextCleared = true;\n\n        this.palletModal = this.getPalletModal();\n\n        // can be scene, time, event, or loop\n        this.selectedGameElement;\n\n        this.currentEnemyPlacer;\n \n\n        // main game array is the main list of sequence objects\n        this.mainGameArray = [];\n\n        this.gameEditorOpened = false;\n        \n\n        const addArrowButton = document.getElementById(\"Arrow\");\n        const addGruntButton = document.getElementById(\"Grunt\");\n        const addBoxBox = document.getElementById(\"BoxBox\");\n        const addPinwheel = document.getElementById(\"Pinwheel\");\n        const addWeaver = document.getElementById(\"Weaver\");\n        const addSingularity = document.getElementById(\"Singularity\");\n        const makeGame = document.getElementById(\"LevelEditor\");\n        const makeEvent = document.getElementById(\"MakeEvent\");\n        const addTime = document.getElementById(\"TimeSubmit\");\n        const addLoop = document.getElementById(\"LoopSubmit\");\n        const addOperation = document.getElementById(\"OperationSubmit\");\n        const sceneNameSubmit = document.getElementById(\"sceneNameSubmit\");\n        const shipRelative = document.getElementById(\"shipRelative\");\n        this.shipRelative = shipRelative;\n        const setCoordinate = document.getElementById(\"changeCoordinates\");\n        const setRandomCoordinates = document.getElementById(\"setRandomCoordinates\");\n\n        const randomSpawnCoordinate = document.getElementById(\"randomSpawnCoordinate\");\n\n\n        const saveGameDesign = document.getElementById(\"saveGameDesign\");\n\n        const loadGameDesign = document.getElementById(\"loadGameDesign\");\n\n        const startGame = document.getElementById(\"startGame\");\n\n        shipRelative.onclick = (e) => {\n            e.stopPropagation();\n            const value = e.target.value;\n            console.log(value);\n            if(value === \"on\") {\n                e.target.value = \"off\";\n                this.makeCoordinatesShipRelative();\n            } else {\n                e.target.value = \"on\";\n                this.makeCoordinatesArenaRelative();\n            }\n\n        };\n\n        setCoordinate.onclick = (e) => {\n            e.stopPropagation();\n            const x = Number(document.getElementById(\"xCoordinate\").value);\n            const y = Number(document.getElementById(\"yCoordinate\").value);\n            const angle = Number(document.getElementById(\"angle\").value);\n            this.currentEnemyPlacer?.setCoordinates(x, y, angle);\n        };\n\n        setRandomCoordinates.onclick = (e) => {\n            e.stopPropagation();\n            this.currentEnemyPlacer?.setRandomCoordinates();\n        };\n\n        randomSpawnCoordinate.onclick = (e) => {\n            // should make it so you can only make one\n            // this would allow me to find the spawn and change it's value here as well\n            e.stopPropagation();\n            this.currentEnemyPlacer?.type === \"RANDOM\";\n\n            const selectedEnemies = Array.from(document.getElementById('possibleSpawns').selectedOptions).map(({ value }) => value);\n            const numberToGenerate = document.getElementById('numberToGenerate').value;\n\n            const newSpawn = {\n                location: 'RANDOM',\n                type: 'RANDOM',\n                possibleSpawns: selectedEnemies,\n                numberToGenerate: numberToGenerate,\n            };\n            \n            this.addRandomRandomSpawnToEvent(newSpawn);\n        };\n       \n        addGruntButton.onclick = (e) => {\n            e.stopPropagation();\n            const type = \"Grunt\";\n            this.addEnemy(type);\n            this.animationView.clear();\n            this.animationView.addEnemy(type);\n        };\n\n        addArrowButton.onclick = (e) => {\n            e.stopPropagation();\n            const type = \"Arrow\";\n            this.addEnemy(type);\n            this.animationView.clear();\n            this.animationView.addEnemy(type);\n        };\n        addBoxBox.onclick = (e) => {\n            e.stopPropagation();\n            const type = \"BoxBox\";\n            this.addEnemy(type);\n            this.animationView.clear();\n            this.animationView.addEnemy(type);\n        };\n        addPinwheel.onclick = (e) => {\n            e.stopPropagation();\n            const type = \"Pinwheel\";\n            this.addEnemy(type);\n            this.animationView.clear();\n            this.animationView.addEnemy(type);\n        };\n        addWeaver.onclick = (e) => {\n            e.stopPropagation();\n            const type = \"Weaver\";\n            this.addEnemy(type);\n            this.animationView.clear();\n            this.animationView.addEnemy(type);\n        };\n        addSingularity.onclick = (e) => {\n            e.stopPropagation();\n            const type = \"Singularity\";\n            this.addEnemy(type);\n            this.animationView.clear();\n            this.animationView.addEnemy(type);\n        };\n        // makeGame.onclick = (e) => {\n        //     e.stopPropagation();\n        //     console.log(\"game editor opened clicked\");\n        //     this.gameEditorOpened = !this.gameEditorOpened;\n        //     this.engine.gameEditorOpened = this.gameEditorOpened;\n        // };\n        makeEvent.onclick = (e) => {\n            e.stopPropagation();\n            this.UIActionsToRun.push(() => this.makeEvent());\n        };\n\n        saveGameDesign.onclick = (e) => {  \n            e.stopPropagation();\n            this.saveGameDesign();\n        };\n\n        sceneNameSubmit.onclick = (e) => {\n            e.stopPropagation();\n            const name = document.getElementById(\"sceneName\").value;\n            this.UIActionsToRun.push(() => this.makeScene(name));\n        };\n        // loadGameDesign.onclick = (e) => {\n        //     e.stopPropagation();\n        //     const json = document.getElementById(\"loadGameDesignInput\").value;\n        //     this.loadGameDesign(json);\n        // };\n        addTime.onclick = (e) => {\n            e.stopPropagation();\n            const time = document.getElementById(\"Time\").value;\n            this.UIActionsToRun.push(() => this.makeTime(time));\n        };\n        addOperation.onclick = (e) => {\n            e.stopPropagation(); \n            const operationType = document.getElementById(\"OperationType\").value;\n            const operationValue = document.getElementById(\"OperationFactor\").value;\n            const operand = {\n                type: operationType,\n                factor: operationValue,\n            };\n            this.UIActionsToRun.push(() => this.makeOperation(operand));\n        };\n\n\n        // should add a loop next to the currently selected element\n        // once I have elements nested under scenes, I'm not sure how this will work\n        // maybe it will make one next to the selected scene if nothing else is selected\n        addLoop.onclick = (e) => {\n            e.stopPropagation();\n            const loop = {\n                repeatTimes: Number(document.getElementById(\"Repeats\").value),\n                // loopIdx: Number(document.getElementById(\"StartingIndex\").value),\n            };\n            this.UIActionsToRun.push(() => this.makeLoop(loop));\n        };\n\n        window.addEventListener(\"scroll\", (e) => {\n            // get the current mouse position to know if it is within the \n            // level editor\n            // then move the level editor up or down \n        });\n\n        window.addEventListener(\"keydown\", (e) => {\n            e.stopPropagation();\n            if(e.key === \"Escape\") {\n                this.escapePressed();\n            }\n            if(e.key === \"Backspace\") {\n                if(this.currentMousePos) {\n                    this.selectedGameElement?.delete();\n                    this.leftJustifyGameElements();\n                }\n            }\n        });\n\n\n        startGame.onclick = (e) => {\n            e.stopPropagation();\n            // serialize game, send to game script\n            this.startGame();\n        };\n\n\n        // this.levelDesignerCtx.addEventListener(\"dblclick\", (e) => {\n        //     e.stopPropagation();\n        //     console.log(\"double clicked\");\n        //     const pos = [e.offsetX, e.offsetY];\n        //     this.mouseDoubleClicked(pos);\n        // });\n    }\n\n    startGame() {\n        this.serializedGame = {\n            gameName: \"Game\",\n            gameElements: this.gameElements.map(\n                (element) => element.serialize()\n            ),\n        };\n        const serializedGame = JSON.stringify(this.serializedGame);\n        // I should unselect whatever is selected.\n        // events being the main issue since they have things\n        // on the game \n        this.engine.gameScript.startGame(serializedGame);\n        this.engine.gameEditorOpened = false;\n    }\n\n    makeTime(time, parentScene = this.expandedScenes[this.expandedScenes.length - 1]) {\n        const newElementPosition = this.getNewDrawPosition();\n        const timeObject = new TimeObject(this, {waitTime: time}, newElementPosition, parentScene);\n        this.selectedGameElement = timeObject;\n        return timeObject;\n    }\n\n    makeOperation(operand, parentScene = this.expandedScenes[this.expandedScenes.length - 1]) {\n        const newElementPosition = this.getNewDrawPosition();\n        const operationObject = new OperationObject(this, operand, newElementPosition, parentScene);\n        operationObject.onMouseClick();\n        this.selectedGameElement = operationObject;\n        return operationObject;\n    }\n\n    mouseDoubleClicked(pos) {\n        console.log(pos);\n    }\n\n    expandScene(scene) {\n        this.selectedGameElement?.unSelected();\n        this.selectedGameElement = undefined;\n\n        const parentIndex = this.expandedScenes.indexOf(scene.parentScene);\n\n        this.expandedScenes[parentIndex + 1]?.unExpandScene();\n\n        scene.gameElements.forEach((element) => {\n            element.parentSceneExpanded();\n            this.addUIElementSprite(element.UILineSprite);\n        });\n        \n        this.expandedScenes.push(scene);\n    }\n\n    unExpandScene(scene) {\n        if(this.expandedScenes.length === 1) return console.log(\"can't unexpand the base scene\");\n        if(this.expandedScenes.indexOf(scene) === -1) return console.log(\"scene not expanded\");\n        const bottomExpandedScene = this.expandedScenes.pop();\n        this.removeExpandedElements(bottomExpandedScene);\n        bottomExpandedScene.expanded = false;\n        bottomExpandedScene.UILineSprite.expanded = false;\n        if(scene !== bottomExpandedScene) bottomExpandedScene.parentScene.unExpandScene();\n    }\n\n    mouseMoveEvent(e) {\n        if (e.target.classList[0] === \"level-editor-canvas\") {\n            \n            this.currentMousePos = [e.offsetX, e.offsetY];\n            if(this.UIElementMouseFollower) {\n\n                const moveToPosition = [e.offsetX - this.draggingLineSprite.widthHeight[0] / 2, e.offsetY - this.draggingLineSprite.widthHeight[1] / 2];\n                this.draggingLineSprite.UITransform.pos = [...moveToPosition];\n                // check if the element is overlapping with another element\n                const bottomExpandedScene = this.expandedScenes[this.expandedScenes.length - 1];\n\n                const draggedElementSceneIndex = bottomExpandedScene.gameElements.indexOf(this.UIElementMouseFollower);\n                if(draggedElementSceneIndex === -1) return;\n\n\n                const leftElementIndex = draggedElementSceneIndex - 1;\n                const rightElementIndex = draggedElementSceneIndex + 1;\n\n                const draggedElementXPosition = this.draggingLineSprite.UITransform.pos[0];\n                const draggedElementWidth = this.draggingLineSprite.widthHeight[0];\n\n                // check left element:\n                let moved = false;\n                if(leftElementIndex >= 0) {\n                    const leftElement = bottomExpandedScene.gameElements[leftElementIndex];\n                    const leftElementWidth = leftElement.widthHeight[0];\n                    const leftElementX = leftElement.UITransform.pos[0];\n                    const leftElementMiddlePosition = leftElementX + leftElementWidth / 2;\n\n                    \n                    if (\n                        draggedElementXPosition < leftElementMiddlePosition &&\n                        draggedElementXPosition + draggedElementWidth > leftElementMiddlePosition\n                    ) {\n                        this.moveLeft(this.UIElementMouseFollower);\n                        moved = true;\n                        // swap position of ghost element and \n                    }\n                        \n                    \n                }\n\n                // check right:\n                if( rightElementIndex < bottomExpandedScene.gameElements.length && moved === false) {\n                    const rightElement = bottomExpandedScene.gameElements[rightElementIndex];\n                    const rightElementWidth = rightElement.widthHeight[0];\n                    const rightElementX = rightElement.UITransform.pos[0];\n                    const rightElementMiddlePosition = rightElementX + rightElementWidth / 2;\n\n                    \n                    if (\n                        draggedElementXPosition < rightElementMiddlePosition &&\n                        draggedElementXPosition + draggedElementWidth > rightElementMiddlePosition\n                    ) {\n                        this.moveRight(this.UIElementMouseFollower);\n                        // swap position of ghost element and \n                    }\n                }\n                \n            }\n        } else {\n            this.currentMousePos = undefined;\n        }\n    }\n\n    getExpandedScenePosition() {\n        // expands into next row\n    }\n\n    leftJustifyGameElements() {\n        const bottomExpandedScene = this.expandedScenes[this.expandedScenes.length - 1];\n        const expandedElements = bottomExpandedScene.gameElements;\n        bottomExpandedScene.gameElements = [];\n\n        expandedElements.forEach((element) => {\n            const newPos = this.getNewDrawPosition();\n            element.UITransform.pos = newPos;\n            bottomExpandedScene.gameElements.push(element);\n        });\n    }\n\n    makeLoop(loop, parentScene = this.expandedScenes[this.expandedScenes.length - 1]) {\n        const beginningObject = new LoopBeginningObject(this, undefined, this.getNewDrawPosition(), parentScene);\n        const endObject = new LoopEndObject(this, loop, this.getNewDrawPosition(), parentScene);\n        beginningObject.endLoopObject = endObject;\n        endObject.beginningLoopObject = beginningObject;\n    }\n\n    makeLoopBeginning(loop, parentScene) {\n        const loopBeginning = new LoopBeginningObject(this, undefined, this.getNewDrawPosition(), parentScene);\n        this.loopBeginningObjectStackForLoading.push(loopBeginning);\n        return loopBeginning;\n    }\n\n    makeLoopEnding(loop, parentScene) {\n        const loopEndObject = new LoopEndObject(this, loop, this.getNewDrawPosition(), parentScene);\n        const matchingBeginning = this.loopBeginningObjectStackForLoading.pop();\n        matchingBeginning.endLoopObject = loopEndObject;\n        loopEndObject.beginningLoopObject = matchingBeginning;\n        return loopEndObject;\n    }\n\n    moveLeft(UIElement) {\n        const gameElements = this.expandedScenes[this.expandedScenes.length - 1].gameElements;\n        for(let i = 0; i < gameElements.length; i++) {\n            const element = gameElements[i];\n            if(element === UIElement) {\n                if(i === 0) return;\n                const temp = gameElements[i - 1];\n                gameElements[i - 1] = UIElement;\n                gameElements[i] = temp;\n                this.swapAdjacentPositions(temp, UIElement);\n            }\n        }\n    }\n\n    moveRight(UIElement) {\n        const gameElements = this.expandedScenes[this.expandedScenes.length - 1].gameElements;\n        for(let i = 0; i < gameElements.length; i++) {\n            const currentElement = gameElements[i];\n            if(currentElement === UIElement) {\n                if(i === gameElements.length - 1) return;\n                const temp = gameElements[i + 1];\n                gameElements[i + 1] = UIElement;\n                gameElements[i] = temp;\n                this.swapAdjacentPositions(UIElement, temp);\n                return;\n            }\n        }\n    }\n\n    saveGameDesign() {\n\n        const gameElements = this.gameElements.map(\n            (element) => element.serialize() \n        );\n\n        this.serializedGame = {\n            gameName: \"Game\",\n            gameElements,\n        };\n        console.log(JSON.stringify(this.serializedGame));\n    }\n\n    \n\n    loadGameDesign(json) {\n        const serializedGame = JSON.parse(json);\n        this.serializedGame = serializedGame;\n        this.gameElements = this.loadGameElements(serializedGame.gameElements);\n    }\n\n    loadGameElements(gameElements, parentScene = this) {\n        return gameElements.map((element) => {\n            if(element.type === \"Scene\") {\n                const newScene = this.makeScene(element.name, parentScene);\n                this.expandedScenes.push(newScene);\n                newScene.gameElements = this.loadGameElements(element.gameElements, newScene) || [];\n                newScene.unExpandScene();\n                return newScene;\n            } else if(element.type === \"Event\") {\n                return this.makeEvent(element, parentScene);\n            } else if(element.type === \"Time\") {\n                return this.makeTime(element.waitTime, parentScene);\n            } else if(element.type === \"LoopBeginning\") {\n                return this.makeLoopBeginning(element, parentScene);\n            } else if (element.type === \"LoopEnd\") {\n                return this.makeLoopEnding(element, parentScene);\n            } else if (element.type === \"Operation\") {\n                return this.makeOperation(element.operand, parentScene);\n            }\n        });\n    }\n\n    makeEvent(eventToLoad, parentScene = this.expandedScenes[this.expandedScenes.length - 1]) {\n        // should provide this the current scene to know which array of elements to use\n        const newElementPosition = this.getNewDrawPosition();\n        \n        const event = new EventObject(this, eventToLoad, newElementPosition, parentScene);\n        this.selectedGameElement?.unSelected();\n        this.selectedGameElement = event;\n        return event;\n    }\n    \n    swapAdjacentPositions(leftUIElement, rightUIElement) {\n        const newLeftX = leftUIElement?.UITransform?.pos[0] || 0;\n        const newRightX = newLeftX + rightUIElement?.widthHeight[0] + 4;\n        leftUIElement.UITransform.pos[0] = newRightX;\n        rightUIElement.UITransform.pos[0] = newLeftX;\n    }\n\n    getNewDrawPosition() {\n        const bottomExpandedScene = this.expandedScenes[this.expandedScenes.length - 1];\n        const expandedElements = bottomExpandedScene.gameElements;\n        const lastElement = expandedElements[expandedElements.length - 1];\n        const lastXPosition = lastElement?.UITransform?.pos[0] || 0;\n        const lastYPosition = lastElement?.UITransform?.pos[1] || bottomExpandedScene.widthHeight[1] + bottomExpandedScene.UITransform.pos[1] + 4;\n        const lastWidth = lastElement?.widthHeight[0] || 0;\n  \n        return [lastXPosition + lastWidth + 4, lastYPosition];\n    }\n\n    makeScene(name, visible = true, parentScene = this.expandedScenes[this.expandedScenes.length - 1]) {\n        // this should add a box inside either the game sequence as a whole,\n        // or inside the current scene\n        let newElementPosition;\n        if(visible) {\n            newElementPosition = this.getNewDrawPosition();\n        }\n        \n        // sprites are made and added automatically\n        return(new SceneObject(this, name, parentScene, newElementPosition));\n    }\n\n    loopSelected(loop) {\n        this.selectedGameElement?.unSelected();\n        this.selectedGameElement = loop;\n    }\n\n    timeSelected(time) {\n        this.selectedGameElement?.unSelected();\n        this.selectedGameElement = time;\n    }\n\n    operationSelected(operation) {\n        this.selectedGameElement?.unSelected();\n        this.selectedGameElement = operation;\n    }\n\n    eventSelected(event) {\n        this.selectedGameElement?.unSelected();\n        this.selectedGameElement = event;\n        this.shipRelative.checked = event.isShipRelative;\n    }\n\n    eventUnselected() {\n        this.currentEnemyPlacer?.remove();\n        this.currentEnemyPlacer = undefined;\n    }\n\n    enemyPlacerClicked(enemyPlacer) {\n        this.animationView.clear();\n        this.animationView.addEnemy(enemyPlacer.type);\n        this.animationView.enemySelected(enemyPlacer.spawn);\n        this.currentEnemyPlacer = enemyPlacer;\n    }\n\n    sceneDoubleClicked(scene) {\n        // this should open the array of elements in the scene\n        console.log(\"scene double clicked: \", scene);\n        // should move this into scene object\n        // this.selectedScene.UILineSprite.selected = false;\n        // this.selectedScene = scene;\n        // scene.UILineSprite.selected = true;\n    }\n\n    sceneSelected(scene) {\n        this.selectedGameElement?.unSelected();\n        this.selectedGameElement = scene;\n    }\n\n    getPalletModal() {\n        const modal = document.getElementById(\"pallet\");\n    // add functions to buttons of the pallet\n    }\n\n    enemyPlaced(spawn) {\n        this.animationView.enemySelected(spawn);\n    }\n\n    escapePressed() {\n\n        this.currentEnemyPlacer?.remove();\n        this.currentEnemyPlacer = undefined;\n    }\n\n    addEnemy(type) {\n        this.currentEnemyPlacer?.remove();\n        this.currentEnemyPlacer = new EnemyPlacer(this.engine, {type}, this);\n    }\n\n    addAnotherEnemy(type) {\n        this.currentEnemyPlacer = new EnemyPlacer(this.engine, {type}, this);\n    }\n\n    // might be redundent and useless TODO\n    downClick() {\n        this.clickedDown = true;\n    }\n\n    unClicked() {\n        if(this.UIElementMouseFollower) {\n            this.UIElementMouseFollower.elementLetGo();\n            this.UIElementMouseFollower = undefined;\n        }\n        this.clickedDown = false;\n    }\n\n    addMouseClickListener(object) {\n        this.engine.addLevelDesignerClickListener(object);\n    }\n    addMouseDoubleClickListener(object) {\n        this.engine.addLevelDesignerDoubleClickListener(object);\n    }\n\n    removeMouseClickListener(object) {\n        this.engine.removeLevelDesignerClickListener(object);\n    }\n    removeMouseDoubleClickListener(object) {\n        this.engine.removeLevelDesignerDoubleClickListener(object);\n    }\n\n    addRandomRandomSpawnToEvent(spawn, ) {\n        if(this.selectedGameElement.enemyPlacers) {\n            this.selectedGameElement?.addRandomRandom(new Spawn(spawn, this.engine));\n        }\n    }\n\n    addSpawnToEvent(spawn, enemyPlacer) {\n        if(this.selectedGameElement.enemyPlacers) {\n            this.selectedGameElement?.addSpawn(new Spawn(spawn, this.engine));\n            if(enemyPlacer) this.selectedGameElement?.addEnemyPlacer(enemyPlacer);\n        }\n    }\n\n    update(deltaTime) {\n\n    }\n\n    createWalls() {\n        return new Walls(this.engine, this);\n    }\n\n    createGrid(cameraTransform) {\n        return new Grid(this.engine, this, new Transform());\n    }\n\n    createOverlay() {\n        return new Overlay(this.engine, this, this.ship.transform);\n    }\n\n    isOutOfBounds(pos, radius) {\n        const max = [GameScript.DIM_X - radius, GameScript.DIM_Y - radius];\n        if (radius) {\n            return (\n                pos[0] <= radius ||\n        pos[0] >= max[0] ||\n        pos[1] <= radius ||\n        pos[1] >= max[1]\n            );\n        } else {\n            return (\n                pos[0] < 0 ||\n        pos[1] < 0 ||\n        pos[0] > GameScript.DIM_X ||\n        pos[1] > GameScript.DIM_Y\n            );\n        }\n    }\n\n    runUIActions() {\n        this.UIActionsToRun.forEach((action) => action());\n        this.UIActionsToRun = [];\n    }\n\n    animate(timeDelta) {\n        // it might be cool to animate the tiny enemies in the spawn card\n        // this.animateGameObjects(timeDelta);\n\n        this.clearCanvas();\n        this.runUIActions();\n        this.renderLineSprites(this.levelDesignerCtx);\n        this.renderUILineSprites(this.levelDesignerCtx);\n        this.renderOverlayText();\n    }\n\n    renderOverlayText() {\n        // if(this.overlayTextCleared) return;\n        // this.ctx.save();\n        // this.ctx.font = 18 + \"px \" + \"Arial\";\n        // this.ctx.fillStyle = \"white\";\n        // const typeText = \"Type: \" + this.overlayText.Type;\n        // const positionText = \"Location: \" + this.overlayText.Location;\n        // this.ctx.fillText(\n        //     typeText,\n        //     10,\n        //     20\n        // );\n        // this.ctx.fillText(\n        //     positionText,\n        //     10,\n        //     38\n        // );\n        // this.ctx.restore();\n    }\n\n\n    animateGameObjects(delta) {\n        // this.gameObjects.forEach((object) => {\n        //     object.animate(delta);\n        // });\n    }\n\n    clearCanvas() {\n        this.ctx.clearRect(0, 0, this.DIM_X, this.DIM_Y);\n        this.ctx.fillStyle = \"#000000\";\n        this.ctx.fillRect(0, 0, this.DIM_X, this.DIM_Y);\n    }\n\n    clear() {\n        const removeList = [...this.gameObjects];\n        removeList.forEach((gameObject) => {\n            this.remove(gameObject);\n        });\n        this.overlayTextCleared = true;\n    }\n\n    renderLineSprites(ctx) {\n        ctx.save();\n        ctx.scale(this.zoomScale, this.zoomScale);\n        this.lineSprites.forEach((sprite) => {\n            sprite.draw(ctx);\n        });\n        ctx.restore();\n    }\n\n    renderUILineSprites(ctx) {\n        ctx.save();\n        this.UIElementSprites.forEach((sprite) => {\n            sprite.draw(ctx);\n        });\n        ctx.restore();\n    }\n\n    addGameObject(gameObject) {\n        this.gameObjects.push(gameObject);\n    }\n\n    queueSound() {\n        \n    }\n\n    addCollider() {}\n\n    addPhysicsComponent() {}\n\n    remove(gameObject) {\n        if (gameObject.lineSprite) {\n            const lineSpriteIndex = this.lineSprites.indexOf(gameObject.lineSprite);\n            if (lineSpriteIndex > -1) this.lineSprites.splice(lineSpriteIndex, 1); \n        }\n        const index = this.gameObjects.indexOf(gameObject);\n        if (index !== -1) this.gameObjects.splice(index, 1);\n    }\n\n    removeExpandedElements(expandedScene) {\n        const UIElements = expandedScene.gameElements;\n        UIElements.forEach((UIElement) => {\n            UIElement.parentSceneUnexpanded();\n            if(UIElement.UILineSprite) {\n                const index = this.UIElementSprites.indexOf(UIElement.UILineSprite);\n                if(index !== -1) this.UIElementSprites.splice(index, 1);\n            }\n        });\n    }\n\n    removeUIElementSprite(UILineSprite) {\n        const index = this.UIElementSprites.indexOf(UILineSprite);\n        if (index !== -1) this.UIElementSprites.splice(index, 1);\n    }\n\n    removeUIElement(element) {\n        const index = this.gameElements.indexOf(element);\n        if (index !== -1) this.gameElements.splice(index, 1);\n    }\n\n    addUIElementSprite(UILineSprite) {\n        this.UIElementSprites.push(UILineSprite);\n    }\n\n    addUIElement(UIElement) {\n        const bottomExpandedScene = this.expandedScenes[this.expandedScenes.length - 1];\n        bottomExpandedScene.gameElements.push(UIElement);\n    }\n\n    addLineSprite(lineSprite) {\n        this.lineSprites.push(lineSprite);\n    }\n\n    makeCoordinatesShipRelative() {\n        this.selectedGameElement?.makeCoordinatesShipRelative();\n    }\n\n    eventLoadShipRelative(isRelative) {\n        this.shipRelative.checked = isRelative;\n        console.log('loading ship',this.shipRelative);\n    }\n            \n    makeCoordinatesArenaRelative() {\n        this.selectedGameElement?.makeCoordinatesArenaRelative();\n    }\n\n}\n","import { Transform } from \"./transform\";\nimport { Util } from \"./util\";\n\nexport class UIElement {\n    constructor(levelDesigner, position, parentScene) {\n        this.parentScene = parentScene;\n        this.UITransform = new Transform(null, position);\n        this.levelDesigner = levelDesigner; // this is level designer not the game engine\n        this.levelDesigner.addUIElement(this);\n        this.inExpandedScene = true;\n    }\n    addUIElementSprite(UILineSprite) {\n        this.UILineSprite = UILineSprite;\n        this.levelDesigner.addUIElementSprite(UILineSprite);\n    }\n    addMouseClickListener() {\n        this.levelDesigner.addMouseClickListener(this);\n    }\n    addMouseDoubleClickListener() {\n        this.levelDesigner.addMouseDoubleClickListener(this);\n    }\n\n    removeMouseClickListener() {\n        this.levelDesigner.removeMouseClickListener(this);\n    }\n    removeMouseDoubleClickListener() {\n        this.levelDesigner.removeMouseDoubleClickListener(this);\n    }\n\n    parentSceneUnexpanded() {\n        this.inExpandedScene = false;\n        this.removeMouseClickListener();\n        this.removeMouseDoubleClickListener();\n    }\n\n    parentSceneExpanded () {\n        this.inExpandedScene = true;\n        this.addMouseClickListener();\n        this.addMouseDoubleClickListener();\n    }\n\n    mouseDoubleClicked(mousePos) {\n        if(!this.inExpandedScene) return;\n        const centerPosition = [\n            this.UITransform.pos[0] + this.widthHeight[0] / 2,\n            this.UITransform.pos[1] + this.widthHeight[1] / 2\n        ];\n        const centerDist = Util.dist(\n            centerPosition,\n            mousePos\n        );\n        if (centerDist < this.clickRadius) {\n            this.onMouseDoubleClicked(mousePos);\n        }\n    }\n\n    mouseClicked(mousePos) {\n        if(!this.inExpandedScene) return;\n        const centerPosition = [\n            this.UITransform.pos[0] + this.widthHeight[0] / 2,\n            this.UITransform.pos[1] + this.widthHeight[1] / 2\n        ];\n        const centerDist = Util.dist(\n            centerPosition,\n            mousePos\n        );\n        if (centerDist < this.clickRadius) {\n            this.onMouseClick(mousePos);\n        }\n    }\n\n    mouseDowned(mousePos) {\n        if(!this.inExpandedScene) return;\n        const centerPosition = [\n            this.UITransform.pos[0] + this.widthHeight[0] / 2,\n            this.UITransform.pos[1] + this.widthHeight[1] / 2\n        ];\n        const centerDist = Util.dist(\n            centerPosition,\n            mousePos\n        );\n        if (centerDist < this.clickRadius) {\n            this.draggingElement = true;\n            this.followMouse();\n        }\n    }\n\n    copyLineSpriteForDragging() {\n        // Abstract\n    }\n\n    elementLetGo() {\n        this.draggingElement = false;\n        this.levelDesigner.UIElementMouseFollower = null;\n        this.levelDesigner.removeUIElementSprite(this.levelDesigner.draggingLineSprite);\n        this.levelDesigner.draggingLineSprite = null;\n        // send to ghost position\n    }\n\n    onMouseDoubleClick(mousePos) {\n\n    }\n\n    onMouseClick(mousePos) {\n\n    }\n\n    followMouse() {\n        this.levelDesigner.UIElementMouseFollower = this;\n        this.levelDesigner.draggingLineSprite = this.copyLineSpriteForDragging();\n        this.levelDesigner.addUIElementSprite(this.levelDesigner.draggingLineSprite);\n    }\n\n    delete() {\n        this.removeMouseClickListener();\n        this.removeMouseDoubleClickListener();\n        this.levelDesigner.removeUIElementSprite(this.UILineSprite);\n        this.parentScene.removeUIElement(this);\n        this.deleteYourShit();\n    }\n\n    deleteYourShit() {\n        // Abstract for event I guess\n    }\n\n\n\n}","// this is a type of sprite for ui elements\n\nexport class UILineSprite {\n    // \n    constructor(UITransform) {\n        this.UITransform = UITransform;\n        this.zoomScaling = 1;\n    }\n    // abstract functions\n    draw(ctx) {\n        // the context position is changed by the ui game engine\n        const pos = [0,0];\n        // if an element is being dragged, a ghost element replaces is for this drawing array\n        // the part that is being dragged will be handled by a separate drawing function\n\n        // allowing for drag and drop, and scrolling etc\n        const angle = this.transform.absoluteAngle();\n        this.drawFunction(ctx, pos, angle);\n    }\n    drawFunction(ctx, pos) {\n        // abstract\n        \n    }\n}","// engine takes in collider with gameobject type as string\n// this way subscriptions can be done via string names\n// enemy is subscribed to bullets..\n// each enemy will check every bullet\n// convert gameobject type to string\n// colliders can be added without subscriptions\n// subscriptions are an array of strings stored with the collider\n\n// collider: object absolute transform\n// collider { gameObject gameObject, \"subscriptions\" [\"name\", \"name\"] }\n// colliders {\"BoxBox\" [collider, collider]}\n\nimport { Util } from \"./util\";\n\nexport class Collider {\n    constructor(\n        type,\n        gameObject,\n        radius = 5,\n        subscriptions, // the things this collider effects\n        subscribedColliderTypes // the things that effect this collider?\n    ) {\n        this.objectType = gameObject.constructor.name;\n        this.type = type;\n        this.subscriptions = subscriptions;\n        this.subscribedColliderTypes = subscribedColliderTypes;\n        this.radius = radius;\n        this.gameObject = gameObject;\n    }\n    // wondering if collision should cascade up the parent objects\n    // nope not yet anyway\n\n    collisionCheck(otherCollider) {\n        const centerDist = Util.dist(\n            this.gameObject.transform.pos,\n            otherCollider.gameObject.transform.pos\n        );\n        if (centerDist < this.radius + otherCollider.radius) {\n            this.gameObject.onCollision(otherCollider, this.type);\n        }\n    }\n}\n\n// on\n\n// When you add new things that effect other things\n// like a new type of bullet, singularity effect, etc\n// you just have to add that functionality to the bullet\n// add the things it effects as things\n// the collider subscribes to\n// this way you don't have to edit every object type\n// that is effected\n\n// singularity has two colliders\n// outer one for gravity effects\n// inner one for actual hits\n// it's subscribed to everything\n// on collision it changes that object properties either\n// directly or with a object method... preferably\n","\nexport class Color {\n    constructor(colorSpec){\n        this.colorType = Object.keys(colorSpec)[0];\n        this.creationErrorCheck(colorSpec);\n        this.extractColorInfo(colorSpec);\n    }\n\n    creationErrorCheck(colorSpec){\n        if (Object.keys(colorSpec).length !== 1) {\n            new Error(\"Color object accepts one color type\");\n        }\n        if (!Color.COLOR_TYPES.includes(this.colorType)) {\n            new Error(\"Color Object given unsupported color type\");\n        }\n    }\n\n    dup(){\n        const dupSpec = {};\n        if (this.colorType === \"rgb\") {\n            dupSpec[\"rgb\"]  = [this.r, this.g, this.b];\n        } else if (this.colorType === \"rgba\") {\n            dupSpec[\"rgba\"] = [this.r, this.g, this.b, this.a];\n        } else if (this.colorType === \"hsl\") {\n            dupSpec[\"hsl\"]  = [this.h, this.s, this.l];\n        } else if (this.colorType === \"hsla\") {\n            dupSpec[\"hsla\"] = [this.h, this.s, this.l, this.a];\n        }\n        const newColor = new Color(dupSpec);\n        return newColor;\n    }\n\n    extractColorInfo(colorSpec){\n        if (this.colorType === \"rgb\"){\n            this.r = colorSpec[this.colorType][0];\n            this.g = colorSpec[this.colorType][1];\n            this.b = colorSpec[this.colorType][2];\n        } else if (this.colorType === \"rgba\"){\n            this.r = colorSpec[this.colorType][0];\n            this.g = colorSpec[this.colorType][1];\n            this.b = colorSpec[this.colorType][2];\n            this.a = colorSpec[this.colorType][3];\n        } else if (this.colorType === \"hsl\"){\n            this.h = colorSpec[this.colorType][0];\n            this.s = colorSpec[this.colorType][1];\n            this.l = colorSpec[this.colorType][2];\n        } else if (this.colorType === \"hsla\"){\n            this.h = colorSpec[this.colorType][0];\n            this.s = colorSpec[this.colorType][1];\n            this.l = colorSpec[this.colorType][2];\n            this.a = colorSpec[this.colorType][3];\n        } \n        colorSpec[this.colorType];\n    }\n\n    evaluateColor(){\n        if (this.colorType === \"rgb\"){\n            return `rbg(${this.r},${this.g},${this.b},)`;\n        } else if (this.colorType === \"rgba\"){\n            return `rbg(${this.r},${this.g},${this.b},${this.a})`;\n        } else if (this.colorType === \"hsl\"){\n            return `hsl(${this.h},${this.s}%,${this.l}%`;\n        } else if (this.colorType === \"hsla\") {\n            return `hsla(${this.h}, ${this.s}%, ${this.l}%, ${this.a}`;\n        }\n    }\n}\nColor.COLOR_TYPES = [\"rgb\", \"rgba\", \"hsl\", \"hsla\"];","import { GameScript } from \"../game_script\";\n\nexport class GameEngine {\n    constructor(ctx) {\n        this.ctx = ctx;\n        this.gameObjects = [];\n        this.physicsComponents = [];\n        this.lineSprites = [];\n        this.soundsToPlay = {};\n        this.colliders = {};\n        this.subscribers = [];\n        this.muted = true;\n        this.mouseListeners = [];\n        this.gameClickListeners = [];\n        this.levelDesignerClickListeners = [];\n        this.gameDoubleClickListeners = [];\n        this.levelDesignerDoubleClickListeners = [];\n        this.doubleClickListeners = [];\n        this.leftControlStickListeners = [];\n        this.rightControlStickListeners = [];\n        this.xButtonListeners = [];\n        this.startButtonListeners = [];\n        this.gameScript = new GameScript(this);\n        this.toRemoveQueue = [];\n        this.paused = false;\n        this.currentCamera = null;\n        this.defaultZoomScale = 1.3;\n        this.zoomScale = 1.3;\n        this.graphicQuality = 1;\n        this.setupController();\n        this.setupPerformance();\n        window.engine = this;\n        this.gameEditorOpened = false;\n        this.frameCountForPerformance = 0;\n        this.levelDesigner = null;\n    }\n\n    setupPerformance() {\n        this.frameCountForPerformance = 0;\n        this.collisionTime = 0;\n        this.physicsCalcTime = 0;\n        this.updateTime = 0;\n        this.renderTime = 0;\n        this.scriptTime = 0;\n        this.timePassed = 0;\n    }\n\n    setupController() {\n        window.addEventListener(\"gamepadconnected\", function (e) {\n            window.controller = e.gamepad;\n            window.engine.controller = e.gamepad;\n            // Gamepad connected\n            console.log(\"Gamepad connected\", e.gamepad);\n        });\n\n        window.addEventListener(\"gamepaddisconnected\", function (e) {\n            // Gamepad disconnected\n            window.engine.controller = null;\n            console.log(\"Gamepad disconnected\", e.gamepad);\n        });\n    }\n\n    updateGraphicSetting(delta) {\n        if (delta > 50) {\n            // console.log(\"worst\")\n            this.graphicQuality = 3;\n        } else if (delta > 25) {\n            this.graphicQuality = 2;\n        } else {\n            this.graphicQuality = 1;\n        }\n    }\n\n    tick(delta) {\n    // debugger\n        this.updateGraphicSetting(delta);\n        if (this.paused) {\n            this.updateControlListeners();\n            return;\n        }\n        // console.log(delta)\n        // if(delta > 125){\n        //   delta = 125\n        // }\n        const beforeCollisionTime = performance.now();\n        this.checkCollisions();\n        const beforePhysicsCalcs = performance.now();\n        const collisionTime = beforePhysicsCalcs - beforeCollisionTime;\n        this.movePhysicsComponents(delta);\n        const beforeUpdate = performance.now();\n        const physicsCalcTime = beforeUpdate - beforePhysicsCalcs;\n        this.updateGameObjects(delta);\n        const beforeRender = performance.now();\n        const updateTime = beforeRender - beforeUpdate;\n        this.clearCanvas();\n        this.renderLineSprites(this.ctx);\n        const beforeScriptUpdate = performance.now();\n        const renderTime = beforeScriptUpdate - beforeRender;\n        this.updateControlListeners();\n        \n        if (!this.gameEditorOpened) {\n            this.updateGameScript(delta);\n        }\n        const scriptTime = performance.now() - beforeScriptUpdate;\n        this.playSounds();\n\n        this.collectPerformanceData(\n            delta,\n            collisionTime,\n            physicsCalcTime,\n            updateTime,\n            renderTime,\n            scriptTime,\n        );\n    }\n\n    collectPerformanceData(\n        delta,\n        collisionTime,\n        physicsCalcTime,\n        updateTime,\n        renderTime,\n        scriptTime\n    ) {\n        this.frameCountForPerformance += 1;\n        this.collisionTime += collisionTime;\n        this.physicsCalcTime += physicsCalcTime;\n        this.updateTime += updateTime;\n        this.renderTime += renderTime;\n        this.scriptTime += scriptTime;\n\n        this.timePassed += delta;\n        if (this.timePassed > 1000 * 60) {\n            const timeData = {\n                frameRate: this.frameCountForPerformance / (this.timePassed / 1000),\n                collisionTime: (this.collisionTime) / this.frameCountForPerformance,\n                physicsCalcTime: (this.physicsCalcTime) / this.frameCountForPerformance,\n                updateTime: (this.updateTime) / this.frameCountForPerformance,\n                renderTime: (this.renderTime) / this.frameCountForPerformance,\n                scriptTime: (this.scriptTime) / this.frameCountForPerformance\n            };\n            console.log(timeData);\n\n            this.setupPerformance();\n        }\n    }\n\n    pause() {\n        this.paused = true;\n        this.gameScript.onPause();\n    }\n\n    unPause() {\n        this.paused = false;\n        this.gameScript.onUnPause();\n    }\n\n    togglePause() {\n    // console.log(\"pausetoggle\")\n        this.paused ? this.unPause() : this.pause();\n    }\n\n    clearCanvas() {\n        this.ctx.clearRect(\n            -this.gameScript.DIM_X,\n            -this.gameScript.DIM_Y,\n            this.gameScript.DIM_X * this.zoomScale * 4,\n            this.gameScript.DIM_Y * this.zoomScale * 4\n        );\n        this.ctx.fillStyle = this.gameScript.BG_COLOR;\n        this.ctx.fillRect(\n            -this.gameScript.DIM_X,\n            -this.gameScript.DIM_Y,\n            this.gameScript.DIM_X * this.zoomScale * 4,\n            this.gameScript.DIM_Y * this.zoomScale * 4\n        );\n    }\n\n    addLeftControlStickListener(object) {\n        this.leftControlStickListeners.push(object);\n    }\n\n    addRightControlStickListener(object) {\n        this.rightControlStickListeners.push(object);\n    }\n\n    addxButtonListener(object) {\n        this.xButtonListeners.push(object);\n    }\n\n    addStartButtonListener(object) {\n        this.startButtonListeners.push(object);\n    }\n\n    // ******** mouse stuff *******\n\n    addClickListener(object) {\n        this.gameClickListeners.push(object);\n    }\n\n    addDoubleClickListener(object) {\n        this.gameDoubleClickListeners.push(object);\n    }\n\n    addLevelDesignerClickListener(object) {\n        this.levelDesignerClickListeners.push(object);\n    }\n\n    addLevelDesignerDoubleClickListener(object) {\n        this.levelDesignerDoubleClickListeners.push(object);\n    }\n\n    mouseDown(e) {\n        if (e.target.classList[0] === \"level-editor-canvas\") {\n            this.levelDesigner.downClick();\n            this.levelDesignerClickListeners.forEach((object) => {\n                object.mouseDowned([e.offsetX, e.offsetY]);\n            });\n        } else if(e.target.classList[0] === \"gameCanvas\") {\n            // const position = [e.layerX, e.layerY];\n            // this.gameClickListeners.forEach((object) => {\n            //     object.mouseClicked(position);\n            // });\n        }\n    }\n\n    mouseClicked(e) {\n        if (e.target.classList[0] === \"level-editor-canvas\") {\n            this.levelDesignerClickListeners.forEach((object) => {\n                object.mouseClicked([e.offsetX, e.offsetY]);\n            });\n        } else if(e.target.classList[0] === \"gameCanvas\") {\n            const position = [e.layerX, e.layerY];\n            this.gameClickListeners.forEach((object) => {\n                object.mouseClicked(position);\n            });\n        }\n    }\n\n    mouseUnClicked(e) { \n        if (e.target.classList[0] === \"level-editor-canvas\") {\n            this.levelDesigner.unClicked();\n        }\n    }\n\n    mouseDoubleClicked(e) {\n        if (e.target.classList[0] === \"level-editor-canvas\") {\n            this.levelDesignerDoubleClickListeners.forEach((object) => {\n                object.mouseDoubleClicked([e.offsetX, e.offsetY]);\n            });\n        } else if(e.target.classList[0] === \"game-canvas\") {\n            const position = [e.layerX, e.layerY];\n            this.gameDoubleClickListeners.forEach((object) => {\n                object.mouseDoubleClicked(position);\n            });\n        }\n    }\n\n    removeClickListener(object) {\n        const index = this.gameClickListeners.indexOf(object);\n        if (index !== -1) this.gameClickListeners.splice(index, 1);\n    }\n\n    removeDoubleClickListener(object) {\n        const index = this.gameDoubleClickListeners.indexOf(object);\n        if (index !== -1) this.gameDoubleClickListeners.splice(index, 1);\n    }\n\n    removeLevelDesignerClickListener(object) {\n        const index = this.levelDesignerClickListeners.indexOf(object);\n        if (index !== -1) this.levelDesignerClickListeners.splice(index, 1);\n    }\n\n    removeLevelDesignerDoubleClickListener(object) {\n        const index = this.levelDesignerDoubleClickListeners.indexOf(object);\n        if (index !== -1) this.levelDesignerDoubleClickListeners.splice(index, 1);\n    }\n\n    // ******** end of mouse stuff *******\n\n    updateLeftControlStickListeners(unitVector) {\n        this.leftControlStickListeners.forEach((listener) => {\n            listener.updateLeftControlStickInput(unitVector);\n        });\n    }\n\n    updateRightControlStickListeners(unitVector) {\n        this.rightControlStickListeners.forEach((listener) => {\n            listener.updateRightControlStickInput(unitVector);\n        });\n    }\n\n    updatexButtonListeners(xButton) {\n        this.xButtonListeners.forEach((listener) => {\n            listener.updatexButtonListener(xButton);\n        });\n    }\n\n\n\n    updateStartButtonListeners(startButton, down) {\n    // console.log([startButton, down])\n        this.startButtonListeners.forEach((listener) => {\n            listener.updateStartButtonListener(startButton, down);\n        });\n    }\n\n    // called by game view\n    updateMousePos(mousePos) {\n        this.mouseListeners.forEach((object) => {\n            object.updateMousePos(mousePos);\n        });\n    }\n\n    removeMouseListener(object) {\n        const index = this.mouseListeners.indexOf(object);\n        if(index !== -1) this.mouseListeners.splice(index, 1);\n    }\n\n    updateControlListeners() {\n        navigator.getGamepads();\n        if (this.controller) {\n            const leftAxis = [window.controller.axes[0], window.controller.axes[1]];\n            const rightAxis = [window.controller.axes[2], window.controller.axes[3]];\n            const xButton = [window.controller.buttons[0].pressed];\n            const startButton = [window.controller.buttons[9].pressed];\n            this.updatexButtonListeners(xButton);\n            this.updateLeftControlStickListeners(leftAxis);\n            this.updateRightControlStickListeners(rightAxis);\n            this.updateStartButtonListeners(startButton);\n        }\n    }\n\n    movePhysicsComponents(delta) {\n        this.physicsComponents.forEach((component) => {\n            component.move(delta);\n        });\n    }\n\n    addCollider(collider) {\n        if (collider.subscriptions) {\n            this.subscribers.push(collider);\n        }\n        const colliders = this.colliders;\n        // collider: object absolute transform\n        // collider {\"objectType\": \"Bullet\", \"type\": \"general\", \"subscriptions\": [\"BoxBox\", \"Arrow\"], \"subscribedColliderTypes\": [\"General\"]}\n        // colliders {\"Singularity\": {\"General\": [collider, collider], \"GravityWell\": [collider, collider]}}\n        if (!colliders[collider.objectType]) {\n            const collidersSameTypeAndObject = {};\n            collidersSameTypeAndObject[collider.type] = [collider];\n            colliders[collider.objectType] = collidersSameTypeAndObject;\n        } else {\n            if (!colliders[collider.objectType][collider.type]) {\n                colliders[collider.objectType][collider.type] = [collider];\n            } else {\n                colliders[collider.objectType][collider.type].push(collider);\n            }\n        }\n    }\n\n    // must be a way to only retrieve\n    // the data for subscribed colliders once\n\n    checkCollisions() {\n    // colliders{\n    // \"Arrow\": [collider, collider]\n    // }\n\n        // collider {\n        //   \"objectType\": \"Bullet\",\n        //   \"type\": \"general\",\n        //   \"subscriptions\": [\"BoxBox\", \"Arrow\"],\n        //   \"subscribedColliderTypes\": [\"general\"]\n        // }\n        const subscribers = this.subscribers;\n        const colliders = this.colliders;\n        this.stillCanDie = false;\n        // console.log(this.subscribers)\n        subscribers.forEach((subscriber) => {\n            if (subscriber.type === \"ShipDeath\") {\n                this.stillCanDie = true;\n                // console.log(\"CAN DIE\")\n            }\n            subscriber.subscriptions.forEach((subscription) => {\n                colliders[subscription] = colliders[subscription] || {};\n                subscriber.subscribedColliderTypes.forEach((colliderType) => {\n                    colliders[subscription][colliderType] =\n                        colliders[subscription][colliderType] || [];\n                    colliders[subscription][colliderType].forEach((subscribedCollider) => {\n                        subscriber.collisionCheck(subscribedCollider);\n                    });\n                });\n            });\n        });\n        if (!this.stillCanDie) {\n            // console.log(this.gameScript.ship.collider)\n            this.gameScript.ship.addCollider(\n                \"General\",\n                this.gameScript.ship,\n                this.gameScript.ship.radius\n            );\n            this.gameScript.ship.addCollider(\n                \"ShipDeath\",\n                this.gameScript.ship,\n                this.gameScript.ship.radius,\n                [\"BoxBox\", \"Singularity\", \"Weaver\", \"Grunt\", \"Arrow\", \"Pinwheel\"],\n                [\"General\"]\n            );\n        }\n    }\n\n    updateGameObjects(delta) {\n        this.gameObjects.forEach((object) => {\n            object.update(delta);\n        });\n    }\n\n    toggleMute() {\n        this.muted = !this.muted;\n    }\n\n    playSounds() {\n        Object.values(this.soundsToPlay).forEach((sound) => {\n            sound.play();\n        });\n        this.soundsToPlay = {};\n    }\n\n    renderLineSprites(ctx) {\n        // ctx.scale = gameEngine.currentCamera.zoomScale\n        this.ctx.save();\n\n        // this belongs in the camera #camera\n        this.ctx.scale(this.zoomScale, this.zoomScale);\n        this.lineSprites.forEach((sprite) => {\n            sprite.draw(ctx);\n        });\n        this.ctx.restore();\n    // ctx.scale(1,1)\n    }\n\n    addMouseListener(object) {\n        this.mouseListeners.push(object);\n    }\n\n    updateGameScript(delta) {\n        this.gameScript.update(delta);\n    }\n\n    addGameObject(object) {\n        this.gameObjects.push(object);\n    }\n\n    addPhysicsComponent(physicsComponent) {\n        this.physicsComponents.push(physicsComponent);\n    }\n\n    addLineSprite(lineSprite) {\n        this.lineSprites.push(lineSprite);\n    }\n\n    queueSound(sound) {\n        if (!this.muted) {\n            this.soundsToPlay[sound.url] = sound;\n        }\n    }\n\n    // remove(gameObject){\n    //   this.toRemoveQueue.push(gameObject)\n    // }\n\n    // emptyRemoveQueue(){\n    //   this.toRemoveQueue.forEach((gameObject) => {\n    //     this.removeAction(gameObject)\n    //   })\n    // }\n\n    remove(gameObject) {\n        if (gameObject.physicsComponent) {\n            const physicsComponentIndex = this.physicsComponents.indexOf(gameObject.physicsComponent);\n            if (physicsComponentIndex !== -1) this.physicsComponents.splice(physicsComponentIndex, 1);\n        }\n\n        if (gameObject.lineSprite) {\n            const lineSpriteIndex = this.lineSprites.indexOf(gameObject.lineSprite);\n            if(lineSpriteIndex !== -1) this.lineSprites.splice(lineSpriteIndex, 1);\n        }\n        this.removeMouseListeners(gameObject);\n        this.removeColliders(gameObject.colliders);\n        const gameObjectIndex = this.gameObjects.indexOf(gameObject);\n        if (gameObjectIndex !== -1) this.gameObjects.splice(gameObjectIndex, 1);\n    }\n\n    removeMouseListeners(gameObject) {\n        this.removeMouseListener(gameObject);\n        this.removeClickListener(gameObject);\n        this.removeDoubleClickListener(gameObject);\n    }\n\n    removeColliders(colliders) {\n        colliders.forEach((collider) => {\n            if (collider.subscriptions) {\n                const colliderSubscriptionsIndex = this.subscribers.indexOf(collider);\n                if(colliderSubscriptionsIndex !== -1) this.subscribers.splice(colliderSubscriptionsIndex, 1);\n            }\n\n            const objectAndColliderTypeList =\n            this.colliders[collider.objectType][collider.type];\n            const colliderIndex = objectAndColliderTypeList.indexOf(collider);\n            if(colliderIndex !== -1) objectAndColliderTypeList.splice(colliderIndex, 1);\n        });\n    }\n}\n\n// the idea:\n// engine takes in collider with gameobject type as string\n// this way subscriptions can be done via string names\n// enemy is subscribed to bullets..\n// each enemy will check every bullet\n// convert gameobject type to string\n// colliders can be added without subscriptions\n// subscriptions are an array of strings stored with the collider\n","import { Util } from \"./util\";\nimport { Sound } from \"./sound\";\n\nimport { Transform } from \"./transform\";\nimport { PhysicsComponent } from \"./physics_component\";\nimport { LineSprite } from \"./line_sprite\";\nimport { Collider } from \"./collider\";\n\nexport class GameObject {\n    constructor(engine) {\n        this.gameEngine = engine;\n        this.gameEngine.addGameObject(this);\n        this.transform = new Transform();\n        this.childObjects = [];\n        this.physicsComponent = null;\n        this.lineSprite = null;\n        this.parentObject = null;\n        this.colliders = [];\n    }\n\n    animate() {\n    // put animation stuffs here\n    }\n\n    addPhysicsComponent() {\n        this.physicsComponent = new PhysicsComponent(this.transform);\n        this.gameEngine.addPhysicsComponent(this.physicsComponent);\n    }\n\n    addLineSprite(lineSprite) {\n        this.lineSprite = lineSprite;\n        this.gameEngine.addLineSprite(this.lineSprite);\n    }\n\n    addMousePosListener() {\n        this.gameEngine.addMouseListener(this);\n    }\n\n    removeMousePosListener() {\n        this.gameEngine.removeMouseListener(this);\n    }\n\n    addLeftControlStickListener() {\n        this.gameEngine.addLeftControlStickListener(this);\n    }\n\n    addRightControlStickListener() {\n        this.gameEngine.addRightControlStickListener(this);\n    }\n\n    addxButtonListener() {\n        this.gameEngine.addxButtonListener(this);\n    }\n\n    addStartButtonListener() {\n        this.gameEngine.addStartButtonListener(this);\n    }\n\n    updateRightControlStickInput(direction) {}\n\n    updateLeftControlStickInput(direction) {}\n\n    updatexButtonListener() {}\n\n    updateStartButtonListener() {}\n\n    updateMousePos(mousePos) {}\n\n    addClickListener() {\n        this.gameEngine.addClickListener(this);\n    }\n\n    removeClickListener() {\n        this.gameEngine.removeClickListener(this);\n    }\n\n    mouseClicked(mousePos) {}\n\n    mouseDoubleClicked(mousePos) {}\n\n    addCollider(type, gameObject, radius, subscriptionTypes, subscriptions) {\n    // game engine checks every collider with it's subscription types\n        const newCollider = new Collider(\n            type,\n            gameObject,\n            radius,\n            subscriptionTypes,\n            subscriptions\n        );\n        this.colliders.push(newCollider);\n        this.gameEngine.addCollider(newCollider);\n    }\n\n    playSound(sound) {\n        this.gameEngine.queueSound(sound);\n    }\n\n    // relative motion needs to be fixed... FOR ANOTHER TIME\n    addChildGameObject(obj, relative) {\n        this.childObjects.push(obj);\n        if (relative) {\n            obj.transform.parentTransform = this.transform;\n        }\n        obj.parentObject = this;\n    }\n\n    update(deltaTime) {\n    // overwritten by child class for update scripts\n    }\n\n    onCollision(collider, type) {\n    // overwritten by child class for handler\n    }\n\n    removeMouseListeners() {\n        this.gameEngine.removeMouseListener(this);\n        this.gameEngine.removeClickListener(this);\n        this.gameEngine.removeDoubleClickListener(this);\n    }\n\n    // remove is the issue\n    // i need a remove queue!!!\n    // ... I think\n    remove() {\n        this.childObjects.forEach((obj) => {\n            obj.remove();\n        });\n        if (this.parentObject) {\n            const index = this.parentObject.childObjects.indexOf(this);\n            if(index !== -1) this.parentObject.childObjects.splice(index, 1);\n        }\n        this.gameEngine.remove(this);\n    }\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n","export class LineSprite {\n    constructor(transform) {\n        this.transform = transform;\n        // this.drawFunction = draw\n        this.zoomScaling = 1;\n        this.visible = true;\n    }\n\n    makeVisible() {\n        this.visible = true;\n    }\n    makeInvisible() {\n        this.visible = false;\n    }\n    // abstract functions\n    draw(ctx) {\n        const pos = this.transform.absolutePosition();\n        const angle = this.transform.abosluteAngle();\n        this.drawFunction(ctx, pos, angle);\n    }\n    drawFunction(ctx, pos, angle) {\n\n    }\n}\n","export class PhysicsComponent {\n    constructor(transform) {\n        this.transform = transform;\n    }\n\n    move(timeDelta) {\n    // timeDelta is number of milliseconds since last move\n    // if the computer is busy the time delta will be larger\n    // in this case the PhysicsObject should move farther in this frame\n        const timeScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n        this.transform.pos[0] += this.transform.vel[0] * timeScale + (this.transform.acc[0] * (timeScale * timeScale)) / 2;\n        this.transform.pos[1] += this.transform.vel[1] * timeScale + (this.transform.acc[1] * (timeScale * timeScale)) / 2;\n        this.transform.pos[2] += this.transform.vel[2] * timeScale + (this.transform.acc[2] * (timeScale * timeScale)) / 2;\n        \n        this.transform.vel[0] += this.transform.acc[0] * timeScale;\n        this.transform.vel[1] += this.transform.acc[1] * timeScale;\n        this.transform.vel[2] += this.transform.acc[2] * timeScale;\n\n        this.transform.angle += this.transform.aVel;\n        this.transform.aVel += this.transform.aAcc;\n\n        this.transform.acc = [0, 0, 0];\n        this.transform.aAcc = 0;\n    }\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n","\nexport class Sound {\n    constructor(url, volume = 1, muted = false){\n        this.url = url;\n        this.volume = volume;\n        this.muted = muted;\n    }\n\n    play() {\n    // if (this.sound) {\n    //   this.sound.play()\n    // } else {\n        this.sound = new Audio(this.url);\n        this.sound.volume = this.volume;\n        this.sound.play();\n    // }\n    }\n    toggleMute(){\n        if(this.sound){\n            this.muted ? this.unmute() : this.mute();\n        }\n    }\n\n    unmute(){\n        if(this.sound){\n            this.muted = false; \n            this.sound.volume = this.volume;\n        }\n    }\n\n    mute(){\n        if(this.sound){\n            this.muted = true;\n            this.sound.volume = 0;\n        }\n    }\n\n    pause(){\n        if(this.sound){\n            this.sound.pause();\n        } \n    }\n    unPause(){\n        if (this.sound) {\n            this.sound.play();\n        }\n    }\n}\n","export class Transform {\n    constructor(\n        cameraTransform = null,\n        pos = [0, 0, 0],\n        vel = [0, 0, 0],\n        acc = [0, 0, 0],\n        angle = 0,\n        aVel = 0,\n        aAcc = 0,\n        parentTransform = null\n    ) {\n        this.cameraTransform = cameraTransform;\n        this.parentTransform = parentTransform;\n        this.angle = angle;\n        this.aVel = aVel;\n        this.aAcc = aAcc;\n        this.pos = pos;\n        this.vel = vel;\n        this.acc = acc;\n    }\n\n    // object will have a render position projected on to the field based on where the camera is and the object's position (z)\n\n    getRenderPosition() {\n        // takes in the camera position and the object's position\n        // returns the render position (position projected on to the field)\n        \n        //Yp = -Zc(Ys - Yc)/(-Zc + Zs)\n        //Xp = -Zc(Xs - Xc)/(-Zc + Zs)\n\n\n    }\n\n    // call up the tree of parent transforms until null\n    // performing the transformation each step for the absolute\n    absoluteAngle() {\n        if (this.parentTransform == null) {\n            return this.angle;\n        } else {\n            return this.angleAdd(this.angle, this.parentTransform.absoluteAngle());\n        }\n    }\n\n    absolutePosition() {\n        let absPos = [];\n       \n        if (this.parentTransform == null) {\n            if (this.cameraTransform) {\n                const Xc = this.cameraTransform.pos[0];\n                const Yc = this.cameraTransform.pos[1];\n                const Zc = this.cameraTransform.pos[2];\n                const Xs = this.pos[0];\n                const Ys = this.pos[1];\n                const Zs = this.pos[2];\n\n                const Yp = Yc + (Ys-Yc)/(Zs-Zc) * (0 - Zc);\n                const Xp = Xc + (Xs-Xc)/(Zs-Zc) * (0 - Zc);\n                absPos = [Xp, Yp];\n            } else {\n                absPos = [this.pos[0], this.pos[1]];\n            }\n            \n\n            return absPos;\n        } else {\n            return this.vectorAdd(this.pos, this.parentTransform.absolutePosition());\n        }\n    }\n\n    absoluteLength(length, relativePosition = [0,0,0]) {\n        // doesn't care about line orientation\n        // center of the line is current position, or adjusted by relative position\n        // assuming camera is on top of the line\n        const linePosition = this.vectorAdd(relativePosition, this.pos);\n        const Zc = this.cameraTransform.pos[2];\n        const pointOne = length / 2;\n        const pointTwo = -length / 2;\n        const Zs = linePosition[2];\n        const absPointOne = (pointOne)/(Zs-Zc) * (0 - Zc);\n        const absPointTwo = (pointTwo)/(Zs-Zc) * (0 - Zc);\n        return absPointOne - absPointTwo;\n    }\n\n    absoluteVelocity() {\n        let absVel = [];\n        if (this.parentTransform == null) {\n            absVel = this.vel;\n            return absVel;\n        } else {\n            return this.vectorAdd(this.vel, this.parentTransform.absoluteVelocity());\n        }\n    }\n\n    absoluteAcceleration() {\n        let absAcc = [];\n        if (this.parentTransform == null) {\n            absAcc = this.acc;\n            return absAcc;\n        } else {\n            return this.vectorAdd(\n                this.acc,\n                this.parentTransform.absoluteAcceleration()\n            );\n        }\n    }\n\n    vectorAdd(vector1, vector2) {\n        return vector1.length === 3 && vector2.length === 3 ? \n            [vector1[0] + vector2[0], vector1[1] + vector2[1], vector1[2] + vector2[2]] : \n            [vector1[0] + vector2[0], vector1[1] + vector2[1]];\n    }\n\n    angleAdd(angle1, angle2) {\n        return (angle1 + angle2) % (2 * Math.PI);\n    }\n}\n","export const Util = {\n    // Normalize the length of the vector to 1, maintaining direction.\n    dir(vec) {\n        if(vec[0] === 0 && vec[1] === 0) return [0, 0];\n        const norm = Util.norm(vec);\n        return Util.scale(vec, 1 / norm);\n    },\n    vectorCartesian(angle,scale){\n        let vector = [];\n        vector = [scale * Math.cos(angle), scale * Math.sin(angle)];\n        return vector;\n    },\n    vector3Cartesian(angle,scale){ // angle is [plane, out of plane]\n        return [scale * Math.cos(angle[0]) * Math.cos(angle[1]), scale * Math.sin(angle[0]) * Math.cos(angle[1]), scale * Math.sin(angle[1])];\n    },\n    vector3Add(vec1, vec2){\n        return [vec1[0] + vec2[0], vec1[1] + vec2[1], vec1[2] + vec2[2]];\n    },\n    // Find distance between two points.\n    dist(pos1, pos2) {\n        let answer;\n        if(isNaN(pos1[2]) || typeof pos1[2] !== 'number') pos1[2] = 0;\n        if(isNaN(pos2[2]) || typeof pos2[2] !== 'number') pos2[2] = 0;\n        if(pos1.length === 3 && pos2.length === 3) {\n\n            answer =  Math.sqrt(\n                (pos1[0] - pos2[0]) ** 2 + (pos1[1] - pos2[1]) ** 2 + (pos1[2] - pos2[2]) ** 2\n            );\n            if(isNaN(answer)) {\n                console.log(\"NaN\");\n            }\n            return answer;\n        }\n        answer =  Math.sqrt(\n            (pos1[0] - pos2[0]) ** 2 + (pos1[1] - pos2[1]) ** 2\n        );\n        if(isNaN(answer)) {\n            console.log(\"NaN\");\n        }\n        return answer;\n    },\n    // Find the length of the vector.\n    norm(vec) {\n        return Util.dist([0, 0, 0], vec);\n    },\n    // Return a randomly oriented vector with the given length.\n    randomVec(length) {\n        const deg = 2 * Math.PI * Math.random();\n        return Util.scale([Math.sin(deg), Math.cos(deg)], length);\n    },\n    // Scale the length of a vector by the given amount.\n    scale(vec, m) {\n        if(vec.length === 3) {\n            return [vec[0] * m, vec[1] * m, vec[2] * m];\n        }\n        return [vec[0] * m, vec[1] * m];\n    },\n\n  \n \n};\n","import {GameObject} from \"../../game_engine/game_object\";\nimport {Sound} from \"../../game_engine/sound\";\nimport {BulletWallExplosion} from \"../particles/bullet_wall_explosion\";\nimport {BulletSprite} from \"./bullet_sprite\";\nimport {ParticleExplosion} from \"../particles/particle_explosion\";\nimport { Util } from \"../../game_engine/util\";\nexport class Bullet extends GameObject {\n    constructor(engine, pos, vel, bulletNumber, powerUpSide, powerLevel) {\n        super(engine);\n        this.ID = bulletNumber;\n        this.transform.pos[0] = pos[0];\n        this.transform.pos[1] = pos[1];\n        this.transform.pos[2] = 0;\n        this.transform.vel[0] = vel[0];\n        this.transform.vel[1] = vel[1];\n        this.transform.vel[2] = 0;\n        this.length = 12;\n        this.radius = this.length / 4;\n        this.wrap = false;\n        this.wallhit = new Sound(\"sounds/bullet_hitwall.wav\", 1);\n        this.addExplosionCollider();\n        this.addPhysicsComponent();\n        this.addLineSprite(new BulletSprite(this.transform));\n        this.exploded = false;\n        this.lifeTime = 4000;\n        this.aliveTime = 0;\n        this.powerUpSide = powerUpSide;\n        this.bending = true;\n        this.bendTime = 0;\n        this.timeToBend = 1000;\n        this.powerLevel = 1; \n        if (!powerUpSide) {\n            this.bending = false;\n        }\n    }\n\n    addExplosionCollider() {\n        const subscribers = [\n            \"Grunt\",\n            \"Pinwheel\",\n            \"BoxBox\",\n            \"Arrow\",\n            \"Singularity\",\n            \"Weaver\",\n            \"AlienShip\",\n        ];\n        this.addCollider(\"bulletHit\", this, this.radius, subscribers, [\"General\"]);\n        this.addCollider(\"General\", this, this.radius);\n    }\n\n    update(deltaTime) {\n        this.aliveTime += deltaTime;\n        if (this.aliveTime > this.lifeTime) {\n            this.remove();\n        }\n\n        if (this.bending) {\n            this.bend(deltaTime);\n        } \n        if (\n            this.gameEngine.gameScript.isOutOfBounds(\n                this.transform.absolutePosition()\n            ) &&\n            !this.exploded\n        ) {\n            this.exploded = true;\n            new BulletWallExplosion(this.gameEngine, this.transform.pos);\n\n            this.gameEngine.queueSound(this.wallhit);\n            this.remove();\n        }\n    }\n\n    bend(deltaTime) {  \n        this.bendTime += deltaTime;\n        if (this.bendTime > this.timeToBend) {\n            this.bending = false;\n        } else {\n            const speed = Util.norm(this.transform.vel);\n            const velDir = Math.atan2(this.transform.vel[1], this.transform.vel[0]);\n            let bendSpeed;\n            if(this.powerLevel > 2){\n                // maybe I control the speed with trigger pressure\n                bendSpeed = this.powerUpSide === 'left' ? -0.0098 * deltaTime : 0.0098 * deltaTime;// (pi/32) / 1000 radians per milisecond\n            } else {\n                bendSpeed = this.powerUpSide === 'left' ? -0.000098 * deltaTime : 0.000098 * deltaTime;// (pi/32) / 1000 radians per milisecond\n            }\n            \n\n            this.transform.vel[0] = Math.cos(velDir + bendSpeed) * speed;\n            this.transform.vel[1] = Math.sin(velDir + bendSpeed) * speed;\n        }\n        // take speed, take velocity direction, change direction with bend speed, apply speed to that direction \n    }\n\n    onCollision(collider, type) {\n        if (type === \"bulletHit\") {\n            if (collider.objectType === \"Singularity\") {\n                collider.gameObject.bulletHit();\n                this.remove();\n            } else {\n                const hitObjectTransform = collider.gameObject.transform;\n                const pos = hitObjectTransform.absolutePosition();\n                const explosion = new ParticleExplosion(this.gameEngine, pos);\n                this.gameEngine.gameScript.tallyScore(collider.gameObject);\n                collider.gameObject.remove();\n                this.remove();\n            }\n        }\n    }\n\n    // move(timeDelta) {\n\n    // }\n}\n\nBullet.RADIUS = 3;\nBullet.SPEED = 7;\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n","import { LineSprite } from \"../../game_engine/line_sprite\";\n\nexport class BulletSprite extends LineSprite {\n    constructor(transform, spawningScale = 1) {\n        super(transform);\n        this.spawningScale = spawningScale;\n        this.length = 12;\n    }\n\n    draw(ctx) {\n        const l = this.length;\n        const pos = this.transform.absolutePosition();\n        const vel = this.transform.absoluteVelocity();\n\n        const w = this.length / 2;\n        const movementDirection = Math.atan2(vel[0], -vel[1]);\n\n        ctx.save();\n        ctx.beginPath();\n        ctx.translate(pos[0], pos[1]);\n        ctx.rotate(movementDirection + 2 * Math.PI);\n\n        ctx.beginPath();\n        ctx.strokeStyle = \"#FBFBC2\";\n        ctx.lineWidth = 1;\n\n        ctx.moveTo(-l / 4, l / 2); //1\n        ctx.lineTo(0, -l / 2); //2\n        ctx.lineTo(l / 4, l / 2); //3\n\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n}\n","\n\nimport { OverlaySprite } from \"./overlay_sprite\";\nimport { GameObject } from \"../../game_engine/game_object\";\n\nexport class Overlay extends GameObject {\n    constructor(engine, gameScript, shipTransform) {\n        super(engine);\n        this.gameScript = gameScript;\n        this.shipTransform = shipTransform;\n        this.transform.pos = [0, 0];\n        this.frameRateUpdateRate = 500;\n        this.currentFrameRateUpdateTime = 0; \n        this.currentFrameCount = 0;\n        this.frameRate = 0;\n        this.addLineSprite(new OverlaySprite(this.shipTransform, this.gameScript.DIM_X, this.gameScript.DIM_Y, this.gameEngine));\n    }\n\n    update(deltaTime) {\n        this.lineSprite.score = this.gameScript.score;\n        this.lineSprite.lives = this.gameScript.lives;\n        this.updateFrameRate(deltaTime);\n        this.lineSprite.frameRate = this.frameRate;\n    }\n\n    updateFrameRate(deltaTime) {\n        this.currentFrameRateUpdateTime += deltaTime;\n        this.currentFrameCount += 1;\n        if (this.currentFrameRateUpdateTime > this.frameRateUpdateRate) {\n            this.currentFrameRateUpdateTime = 0;\n            this.currentframeCount = 0;\n            this.frameRate = Math.floor(this.currentFrameCount / (this.frameRateUpdateRate / 1000));\n        }\n    }\n}\n","import { LineSprite } from \"../../game_engine/line_sprite\";\nimport { Color } from \"../../game_engine/color\";\nexport class OverlaySprite extends LineSprite {\n    constructor(transform, DIM_X, DIM_Y, gameEngine) {\n        super(transform);\n        this.gameEngine = gameEngine;\n        this.transform = transform;\n        this.width = DIM_X;\n        this.height = DIM_Y;\n        this.score = 0;\n        this.lives = 0;\n        this.frameRate = 0;\n        this.fontSize = 20;\n        this.fontStyle = \"Arial\";\n        this.shadowColor = new Color({\n            \"hsla\": [202, 100, 70, 1]\n        });\n        this.color = new Color({\n            \"hsla\": [202, 100, 70, 0.5]\n        });\n    }\n\n    draw(ctx) {\n        ctx.save();\n        ctx.scale(1 / this.gameEngine.zoomScale, 1 / this.gameEngine.zoomScale);\n        const zoomFactor = this.gameEngine.zoomScale / this.gameEngine.defaultZoomScale;\n        ctx.font = this.fontSize * 1.3 + \"px \" + this.fontStyle;\n        ctx.fillStyle = this.color.evaluateColor();\n        let displayText = \"Score: \" + this.score + \"      \" + \"Lives: \" + this.lives;\n        if(this.gameEngine.gameScript.testing) {\n            displayText += \"      \" + \"FPS: \" + this.frameRate;\n        }\n        ctx.fillText(\n            displayText,\n            (this.transform.pos[0] - 350 / zoomFactor) * this.gameEngine.zoomScale, \n            (this.transform.pos[1] - 150 / zoomFactor) * this.gameEngine.zoomScale\n        );\n        ctx.restore();\n    }\n}","import { WallsSprite } from \"./walls_sprite\";\nimport { GameObject } from \"../../game_engine/game_object\";\n\nexport class Walls extends GameObject {\n    constructor(engine, gameScript) {\n        super(engine);\n        this.gameScript = gameScript;\n        this.transform.pos = [0,0];\n        this.addLineSprite(new WallsSprite(this.transform, this.gameScript.DIM_X, this.gameScript.DIM_Y));\n    }\n\n    update(deltaTime) {\n        \n    }\n}","import { LineSprite } from \"../../game_engine/line_sprite\";\nimport { Color } from \"../../game_engine/color\";\nexport class WallsSprite extends LineSprite {\n    constructor(transform, DIM_X, DIM_Y) {\n        super(transform);\n        this.width = DIM_X;\n        this.height = DIM_Y;\n        this.shadowColor = new Color({\n            \"hsla\": [202, 100, 70, 1]\n        });\n        this.color = new Color({\n            \"hsla\": [202, 100, 70, 0.2]\n        });\n    }\n\n    draw(ctx) {\n        const w = this.width;\n        const h = this.height;\n        const pos = this.transform.absolutePosition();\n\n        ctx.save();\n        ctx.beginPath();\n        ctx.translate(pos[0], pos[1]);\n\n        const blurFactor = 0.5;\n        ctx.shadowColor = this.shadowColor.evaluateColor();\n        ctx.shadowBlur = 10;\n        ctx.strokeStyle = this.color.evaluateColor();\n        ctx.lineWidth = 7.5 * blurFactor * 2;\n        this.drawWalls(ctx, w, h);\n        ctx.lineWidth = 6 * 2;// * blurFactor;\n        this.drawWalls(ctx, w, h);\n        ctx.lineWidth = 4.5 * 2; // * blurFactor;\n        this.drawWalls(ctx, w, h);\n        ctx.lineWidth = 3 * 2;// * blurFactor;\n        this.drawWalls(ctx, w, h);\n        ctx.strokeStyle = 'rgb(255, 255, 255)';\n        ctx.lineWidth = 1.5 * 2;// * blurFactor;\n        this.drawWalls(ctx, w, h);\n\n        ctx.restore();\n    }\n\n    drawWalls(ctx,w,h){\n        const offset = 6;\n        ctx.beginPath;\n        ctx.moveTo(-offset, -offset);\n        ctx.lineTo(w + offset, -offset);\n        ctx.lineTo(w + offset, h + offset); //3\n        ctx.lineTo(0 - offset, h + offset);\n        ctx.closePath();\n        ctx.stroke();\n    }\n}","import { GameObject } from \"../../../game_engine/game_object\";\nimport { Util } from \"../../../game_engine/util\";\nimport { Sound } from \"../../../game_engine/sound\";\nimport { EnemySpawn } from \"../../particles/enemy_spawn\";\nimport { ArrowSprite } from \"./arrow_sprite\";\n\nexport class Arrow extends GameObject {\n    constructor(engine, pos, angle = Math.random() * Math.PI * 2) {\n        super(engine);\n        this.transform.pos = pos;\n        this.transform.angle = angle;\n        this.speed = 3;\n        this.points = 50;\n        this.transform.vel = Util.vectorCartesian(this.transform.angle, this.speed);\n        this.radius = 6;\n        this.spawnSound = new Sound(\"sounds/Enemy_spawn_purple.wav\", 0.5);\n        this.playSound(this.spawnSound);\n        this.addLineSprite(new ArrowSprite(this.transform));\n        this.addChildGameObject(new EnemySpawn(this.gameEngine));\n        this.exists = false;\n        this.time = 0;\n    }\n\n    exist() {\n    // leaving off subscriptions means that things will subscribe to it\n        this.addCollider(\"General\", this, this.radius);\n        // now it will move\n        this.addPhysicsComponent();\n        this.exists = true;\n    }\n\n    animate(delta) {\n        this.time += delta;\n        const cycleSpeedScale = delta / NORMAL_FRAME_TIME_DELTA;\n        const cycleSpeed = 0.004;\n        // const widthRotate = Math.sin(this.time * cycleSpeedScale * cycleSpeed);\n        const twoFullRotationCheck = this.time * cycleSpeedScale * cycleSpeed;\n\n        if (twoFullRotationCheck >= Math.PI * 2 * 4) {\n            this.time = 0;\n        }\n        this.lineSprite.yRotation = this.time * cycleSpeedScale * cycleSpeed;\n        this.lineSprite.widthScaleForRotation = Math.sin(\n            this.time * cycleSpeedScale * cycleSpeed\n        );\n        this.lineSprite.zScaleForRotation = Math.sin(\n            this.time * cycleSpeedScale * cycleSpeed + Math.PI / 2\n        );\n    }\n\n    update(delta) {\n    // ADD TO UPDATE FOR THE OBJECTS\n        this.animate(delta);\n\n        const pos = this.transform.absolutePosition();\n        if (this.gameEngine.gameScript.isOutOfBounds(pos)) {\n            this.gameEngine.gameScript.redirect(this.transform);\n        }\n    }\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n","import { LineSprite } from \"../../../game_engine/line_sprite\";\nexport class ArrowSprite extends LineSprite {\n    constructor(transform, spawningScale = 1) {\n        super(transform);\n        this.spawningScale = spawningScale;\n        this.widthScaleForRotation = 1;\n        this.zScaleForRotation = 0;\n        this.yRotation = 0;\n    }\n\n    draw(ctx) {\n        if(!this.visible) return;\n        const pos = this.transform.absolutePosition();\n        const spawningScale = this.spawningScale || 1;\n        const shipLength = 10.5 * 2.2 * spawningScale;\n        const shipWidth = 9 * 2.2 * spawningScale;\n        const l = shipLength;\n        const w = shipWidth * this.widthScaleForRotation;\n        const z = shipWidth * this.zScaleForRotation;\n        let movementDirection = 0;\n        if(this.transform.vel[0] === 0 && this.transform.vel[1] === 0) {\n            movementDirection = this.transform.angle;\n        } else {\n            movementDirection = Math.atan2(\n                this.transform.vel[0],\n                -this.transform.vel[1]\n            );\n        }\n        \n\n        const r = 255;\n        const g = 255;\n        const b = 50;\n\n        ctx.save();\n        ctx.beginPath();\n        ctx.translate(pos[0], pos[1]);\n        ctx.rotate(movementDirection + 1 * Math.PI);\n\n        // ctx.strokeStyle = \"#f2ff00\"; // look up rgb and put here\n        // ctx.lineWidth = 2 / 2;\n\n        ctx.shadowColor = \"rgb(255,255,255)\";\n        ctx.shadowBlur = 1.5;\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n        const lineWidth = 2;\n\n        const rightLineWidth =\n      lineWidth + 2.5 * Math.sin(this.yRotation + Math.PI / 2);\n        const leftLineWidth =\n      lineWidth - 2.5 * Math.sin(this.yRotation + Math.PI / 2);\n        const topLineWidth = lineWidth + 2.5 * Math.sin(this.yRotation);\n        const bottomLineWidth = lineWidth - 2.5 * Math.sin(this.yRotation);\n\n        // this.drawArrow(\n        //   ctx,\n        //   l,\n        //   w,\n        //   z,\n        //   rightLineWidth,\n        //   leftLineWidth,\n        //   topLineWidth,\n        //   bottomLineWidth\n        // );\n\n        this.drawArrow(\n            ctx,\n            l,\n            w,\n            z,\n            rightLineWidth * 0.75,\n            leftLineWidth * 0.75,\n            topLineWidth * 0.75,\n            bottomLineWidth * 0.75\n        );\n\n        this.drawArrow(\n            ctx,\n            l,\n            w,\n            z,\n            rightLineWidth * 0.6,\n            leftLineWidth * 0.6,\n            topLineWidth * 0.6,\n            bottomLineWidth * 0.6\n        );\n\n        this.drawArrow(\n            ctx,\n            l,\n            w,\n            z,\n            rightLineWidth * 0.45,\n            leftLineWidth * 0.45,\n            topLineWidth * 0.45,\n            bottomLineWidth * 0.45\n        );\n\n        this.drawArrow(\n            ctx,\n            l,\n            w,\n            z,\n            rightLineWidth * 0.3,\n            leftLineWidth * 0.3,\n            topLineWidth * 0.3,\n            bottomLineWidth * 0.3\n        );\n\n        ctx.strokeStyle = \"rgb(255, 255, 255)\";\n        // this should be half the other line width for the effect, even after adding sin\n        this.drawArrow(\n            ctx,\n            l,\n            w,\n            z,\n            rightLineWidth * 0.15,\n            leftLineWidth * 0.15,\n            topLineWidth * 0.15,\n            bottomLineWidth * 0.15\n        );\n\n        ctx.restore();\n    }\n\n    drawArrow(\n        ctx,\n        l,\n        w,\n        z,\n        rightLineWidth,\n        leftLineWidth,\n        topLineWidth,\n        bottomLineWidth\n    ) {\n        ctx.lineWidth = rightLineWidth;\n        ctx.beginPath();\n        ctx.moveTo(0, 0.4762 * l); //1\n        ctx.lineTo(0.5 * w, -0.2381 * l); //2\n        ctx.lineTo(0.25 * w, -0.5238 * l); //3\n        ctx.lineTo(0.1666 * w, -0.2381 * l); //4\n        ctx.lineTo(0, -0.2381 * l); //4.5\n        ctx.stroke();\n\n        ctx.lineWidth = leftLineWidth;\n        ctx.beginPath();\n        ctx.lineTo(0, -0.2381 * l); //4.5\n        ctx.lineTo(-0.1666 * w, -0.2381 * l); //5\n        ctx.lineTo(-0.25 * w, -0.5238 * l); //6\n        ctx.lineTo(-0.5 * w, -0.2381 * l); //7\n        ctx.lineTo(0, 0.4762 * l); //1\n        ctx.stroke();\n\n        ctx.lineWidth = topLineWidth;\n        ctx.beginPath();\n        ctx.moveTo(-0.1666 * z, -0.0952 * l); //1\n        ctx.lineTo(-0.3333 * z, -0.2381 * l); //2\n        ctx.lineTo(-0.25 * z, -0.381 * l); //3\n        ctx.closePath();\n        ctx.stroke();\n\n        ctx.lineWidth = bottomLineWidth;\n        ctx.beginPath();\n        ctx.moveTo(0.1666 * z, -0.0952 * l); //1\n        ctx.lineTo(0.3333 * z, -0.2381 * l); //2\n        ctx.lineTo(0.25 * z, -0.381 * l); //3\n        ctx.closePath();\n        ctx.stroke();\n\n    // ctx.lineWidth = lineWidth / 2;\n    // ctx.beginPath();\n    // ctx.moveTo(0.2083 * z, -0.2381 * l); //1\n    // ctx.lineTo(-0.2083 * z, -0.2381 * l); //2\n    // ctx.stroke();\n    }\n}\n/*\n// OG\nlet blurFactor = 0.5\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    ctx.shadowBlur = 10 * blurFactor;\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n\n    ctx.lineWidth = 7.5 * blurFactor;\n    this.drawArrow(ctx, l, w);\n\n    ctx.lineWidth = 6 * blurFactor;\n    this.drawArrow(ctx, l, w);\n\n    ctx.lineWidth = 4.5;\n    this.drawArrow(ctx, l, w);\n\n    ctx.lineWidth = 3;\n    this.drawArrow(ctx, l, w);\n\n    ctx.strokeStyle = 'rgb(255, 255, 255)';\n    \n    ctx.lineWidth = 1.5;\n    this.drawArrow(ctx, l, w);\n*/\n","import {GameObject} from \"../../../game_engine/game_object\";\nimport {Sound} from \"../../../game_engine/sound\";\nimport {EnemySpawn} from \"../../particles/enemy_spawn\";\nimport {BoxBoxSprite} from \"./boxbox_sprite\";\n\n\n// this is where i'm defining huge static stuff that doesn't change\n// between different boxboxes. There's only need to load one of these\n\nconst boxWidth = 13;\nconst boxDepth =  boxWidth / 3;\n\n// there's only two versions of this coordate object\n// 1. bottom left, top right\n// 2. top left, bottom right\n\n\n// bottom left:\nconst w = boxWidth;\nconst d = boxDepth;\n\n\nconst drawCoordinatesTopLeft = {\n    // try making y negativified\n\n    BottomSquareBL: [-3/4 * w, 3/4 * w],\n    BottomSquareBR: [1/4 * w, 3/4 * w],\n    BottomSquareTL: [-3/4 * w, -1/4 * w],\n    BottomSquareTR: [1/4 * w, -1/4 * w],\n    TopSquareBL: [-1/4 * w, 1/4 * w],\n    TopSquareBR: [3/4 * w, 1/4 * w],\n    TopSquareTL: [-1/4 * w, -3/4 * w],\n    TopSquareTR: [3/4 * w, -3/4 * w],\n    Left: { // distances to axis of rotation, [x, y, angleOffset], y is the same, x requires pythag;\n        // take these distances to the axis of rotation, and then multiply them by cos(angle) of rotation\n        _BottomSquareBL: [d,  3/4 * w, Math.PI/2], // angle starts 90 degrees \n        _BottomSquareBR: [Math.sqrt(w**2 + d**2), 3/4 * w, Math.atan(d/w)], // scaled length is distance from axis of rotation\n        _BottomSquareTL: [d, -1/4 * w, Math.PI/2],\n        _BottomSquareTR: [Math.sqrt(w**2 + d**2), -1/4 * w, Math.atan(d/w)],\n        _TopSquareBL: [Math.sqrt((w / 2)**2 + d**2), 1/4 * w, Math.atan(d/(w/2))],\n        _TopSquareBR: [Math.sqrt((3/2 * w)**2 + d**2), 1/4 * w, Math.atan(d/(3/2 * w))],\n        _TopSquareTL: [Math.sqrt((w / 2)**2 + d**2), -3/4 * w, Math.atan(d/(w/2))],\n        _TopSquareTR: [Math.sqrt((3/2 * w)**2 + d**2), -3/4 * w, Math.atan(d/(3/2 * w))]\n    },\n    Right: {\n        _BottomSquareBL: [Math.sqrt((3/2 * w)**2 + d**2), 3/4 * w, Math.atan(d/(3/2 * w))], // angle starts 90 degrees \n        _BottomSquareBR: [Math.sqrt((w / 2)**2 + d**2), 3/4 * w, Math.atan(d/(w/2))],\n        _BottomSquareTL: [Math.sqrt((3/2 * w)**2 + d**2), -1/4 * w, Math.atan(d/(3/2 * w))],\n        _BottomSquareTR: [Math.sqrt((w / 2)**2 + d**2), -1/4 * w, Math.atan(d/(w/2))],\n        _TopSquareBL: [Math.sqrt(w**2 + d**2), 1/4 * w, Math.atan(d/w)],\n        _TopSquareBR: [d, 1/4 * w, Math.PI/2], \n        _TopSquareTL: [Math.sqrt(w**2 + d**2), -3/4 * w, Math.atan(d/w)],\n        _TopSquareTR: [d, -3/4 * w, Math.PI/2] \n    },\n    Top: { // X stays the same, Y scales\n        _BottomSquareBL: [-3/4 * w, d, -Math.PI/2],\n        _BottomSquareBR: [1/4 * w, d, -Math.PI/2],\n        _BottomSquareTL: [-3/4 * w, -Math.sqrt(w**2 + d**2), Math.atan(d/ w)],\n        _BottomSquareTR: [1/4 * w, -Math.sqrt(w**2 + d**2), Math.atan(d/ w)],\n        _TopSquareBL: [-1/4 * w, -Math.sqrt((w / 2)**2 + d**2), Math.atan(d/(w/2))],\n        _TopSquareBR: [3/4 * w, -Math.sqrt((w / 2)**2 + d**2), Math.atan(d/(w/2))],\n        _TopSquareTL: [-1/4 * w, -Math.sqrt((3/2 * w)**2 + d**2),  Math.atan(d/(3/2 * w))],\n        _TopSquareTR: [3/4 * w, -Math.sqrt((3/2 * w)**2 + d**2),  Math.atan(d/(3/2 * w))],\n    },\n    Bottom: { // X stays the same, Y scales\n        // BL <=> TR, TL <=> BR\n        _BottomSquareBL: [-3/4 * w, Math.sqrt((3/2 * w)**2 + d**2),  Math.atan(d/(3/2 * w))],\n        _BottomSquareBR: [1/4 * w, Math.sqrt((3/2 * w)**2 + d**2),  Math.atan(d/(3/2 * w))],\n        _BottomSquareTL: [-3/4 * w, Math.sqrt((w / 2)**2 + d**2), Math.atan(d/(w/2))],\n        _BottomSquareTR: [1/4 * w, Math.sqrt((w / 2)**2 + d**2), Math.atan(d/(w/2))],\n        _TopSquareBL: [-1/4 * w, Math.sqrt(w**2 + d**2), Math.atan(d/ w)],\n        _TopSquareBR: [3/4 * w, Math.sqrt(w**2 + d**2), Math.atan(d/ w)],\n        _TopSquareTL: [-1/4 * w, d, Math.PI/2],\n        _TopSquareTR: [3/4 * w, d, Math.PI/2],\n    },\n    _BottomSquareBL: [-3/4 * w, 3/4 * w],\n    _BottomSquareBR: [1/4 * w, 3/4 * w],\n    _BottomSquareTL: [-3/4 * w, -1/4 * w],\n    _BottomSquareTR: [1/4 * w, -1/4 * w],\n    _TopSquareBL: [-1/4 * w, 1/4 * w],\n    _TopSquareBR: [3/4 * w, 1/4 * w],\n    _TopSquareTL: [-1/4 * w, -3/4 * w],\n    _TopSquareTR: [3/4 * w, -3/4 * w],\n};\n\nconst drawCoordinatesBottomLeft = {\n    // I think \n    // flip Y coordinates for this shape\n\n\n    BottomSquareBL: [-3/4 * w, 1/4 * w],\n    BottomSquareBR: [1/4 * w, 1/4 * w],\n    BottomSquareTL: [-3/4 * w, -3/4 * w],\n    BottomSquareTR: [1/4 * w, -3/4 * w],\n    TopSquareBL: [-1/4 * w, 3/4 * w],\n    TopSquareBR: [3/4 * w, 3/4 * w],\n    TopSquareTL: [-1/4 * w, -1/4 * w],\n    TopSquareTR: [3/4 * w, -1/4 * w],\n\n    // top and bottom are correct\n    // left and right are wrong\n   \n    Left: { // distances to axis of rotation, [x, y, angleOffset], y is the same, x requires pythag;\n        // take these distances to the axis of rotation, and then multiply them by cos(angle) of rotation\n        //BL <=> TL, BR <=> TR\n        _BottomSquareBL: [d, 1/4 * w, Math.PI/2],\n        _BottomSquareBR:  [Math.sqrt(w**2 + d**2), 1/4 * w, Math.atan(d/w)],\n        _BottomSquareTL: [d,  -3/4 * w, Math.PI/2], \n        _BottomSquareTR: [Math.sqrt(w**2 + d**2), -3/4 * w, Math.atan(d/w)],\n        _TopSquareBL: [Math.sqrt((w / 2)**2 + d**2), 3/4 * w, Math.atan(d/(w/2))],\n        _TopSquareBR: [Math.sqrt((3/2 * w)**2 + d**2), 3/4 * w, Math.atan(d/(3/2 * w))],\n        _TopSquareTL: [Math.sqrt((w / 2)**2 + d**2), -1/4 * w, Math.atan(d/(w/2))],\n        _TopSquareTR: [Math.sqrt((3/2 * w)**2 + d**2), -1/4 * w, Math.atan(d/(3/2 * w))],\n    },\n    Right: { // BL <=> TL, BR <=> TR\n        _BottomSquareBL: [Math.sqrt((3/2 * w)**2 + d**2), 1/4 * w, Math.atan(d/(3/2 * w))],// angle starts 90 degrees \n        _BottomSquareBR: [Math.sqrt((w / 2)**2 + d**2), 1/4 * w, Math.atan(d/(w/2))],\n        _BottomSquareTL: [Math.sqrt((3/2 * w)**2 + d**2), -3/4 * w, Math.atan(d/(3/2 * w))], \n        _BottomSquareTR: [Math.sqrt((w / 2)**2 + d**2), -3/4 * w, Math.atan(d/(w/2))],\n        _TopSquareBL: [Math.sqrt(w**2 + d**2), 3/4 * w, Math.atan(d/w)],\n        _TopSquareBR: [d, 3/4 * w, Math.PI/2],\n        _TopSquareTL: [Math.sqrt(w**2 + d**2), -1/4 * w, Math.atan(d/w)],\n        _TopSquareTR:  [d, -1/4 * w, Math.PI/2], \n    },\n    Top: { // X stays the same, Y scales \n        _BottomSquareBL: [-3/4 * w, -Math.sqrt((3/2 * w)**2 + d**2),  Math.atan(d/(3/2 * w))],//[d,  -3/4 * w, Math.PI/2], // angle starts 90 degrees\n        _BottomSquareBR: [1/4 * w, -Math.sqrt((3/2 * w)**2 + d**2),  Math.atan(d/(3/2 * w))],\n        _BottomSquareTL: [-3/4 * w, -Math.sqrt((w / 2)**2 + d**2), Math.atan(d/(w/2))],\n        _BottomSquareTR: [1/4 * w, -Math.sqrt((w / 2)**2 + d**2), Math.atan(d/(w/2))],\n        _TopSquareBL: [-1/4 * w, -Math.sqrt(w**2 + d**2), Math.atan(d/w)],\n        _TopSquareBR: [3/4 * w, -Math.sqrt(w**2 + d**2), Math.atan(d/ w)],\n        _TopSquareTL: [-1/4 * w, -d, Math.PI/2],\n        _TopSquareTR: [3/4 * w, -d, Math.PI/2]\n    },\n    Bottom: { // X stays the same, Y scales\n        _BottomSquareBL: [-3/4 * w, d, Math.PI/2],\n        _BottomSquareBR: [1/4 * w, d, Math.PI/2],\n        _BottomSquareTL: [-3/4 * w, Math.sqrt(w**2 + d**2), Math.atan(d/ w)],\n        _BottomSquareTR: [1/4 * w, Math.sqrt(w**2 + d**2), Math.atan(d/ w)],\n        _TopSquareBL: [-1/4 * w, Math.sqrt((w / 2)**2 + d**2), Math.atan(d/(w/2))],\n        _TopSquareBR: [3/4 * w, Math.sqrt((w / 2)**2 + d**2), Math.atan(d/(w/2))],\n        _TopSquareTL: [-1/4 * w, Math.sqrt((3/2 * w)**2 + d**2),  Math.atan(d/(3/2 * w))],\n        _TopSquareTR: [3/4 * w,  Math.sqrt((3/2 * w)**2 + d**2),  Math.atan(d/(3/2 * w))]\n    },\n    _BottomSquareBL: [-3/4 * w, 1/4 * w],\n    _BottomSquareBR: [1/4 * w, 1/4 * w],\n    _BottomSquareTL: [-3/4 * w, -3/4 * w],\n    _BottomSquareTR: [1/4 * w, -3/4 * w],\n    _TopSquareBL: [-1/4 * w, 3/4 * w],\n    _TopSquareBR: [3/4 * w, 3/4 * w],\n    _TopSquareTL: [-1/4 * w, -1/4 * w],\n    _TopSquareTR: [3/4 * w, -1/4 * w],\n};\n\n\nexport class BoxBox extends GameObject {\n    constructor(engine, pos) {\n        super(engine);\n        this.spawnSound = new Sound(\"sounds/Enemy_spawn_blue.wav\", 0.5);\n        this.transform.pos = pos;\n        this.radius = 10;\n        this.points = 20;\n        // this.addPhysicsComponent()\n        this.projectedDrawCoordinates = {};\n        \n        this.boxWidth = boxWidth;\n        this.boxDepth = boxWidth / 3;\n\n        // there's only two versions of this coordate object\n        // 1. bottom left, top right\n        // 2. top left, bottom right\n\n\n        // bottom left:\n        const w = this.boxWidth;\n        // the axis of rotation determines the length of the line for the _ coordinates\n\n        // This one is done\n\n        const projectedDrawCoordinates = {\n            BottomSquareBL: [...drawCoordinatesBottomLeft.BottomSquareBL],\n            BottomSquareBR: [...drawCoordinatesBottomLeft.BottomSquareBR],\n            BottomSquareTL: [...drawCoordinatesBottomLeft.BottomSquareTL],\n            BottomSquareTR: [...drawCoordinatesBottomLeft.BottomSquareTR],\n            TopSquareBL: [...drawCoordinatesBottomLeft.TopSquareBL],\n            TopSquareBR: [...drawCoordinatesBottomLeft.TopSquareBR],\n            TopSquareTL: [...drawCoordinatesBottomLeft.TopSquareTL],\n            TopSquareTR: [...drawCoordinatesBottomLeft.TopSquareTR],\n            _BottomSquareBL: [...drawCoordinatesBottomLeft._BottomSquareBL],\n            _BottomSquareBR: [...drawCoordinatesBottomLeft._BottomSquareBR],\n            _BottomSquareTL: [...drawCoordinatesBottomLeft._BottomSquareTL],\n            _BottomSquareTR: [...drawCoordinatesBottomLeft._BottomSquareTR],\n            _TopSquareBL: [...drawCoordinatesBottomLeft._TopSquareBL],\n            _TopSquareBR: [...drawCoordinatesBottomLeft._TopSquareBR],\n            _TopSquareTL: [...drawCoordinatesBottomLeft._TopSquareTL],\n            _TopSquareTR: [...drawCoordinatesBottomLeft._TopSquareTR],\n        };\n\n        \n        this.animationStates = [\"Paused\", \"Rotating\", \"MidPaused\", \"CompletingRotation\"];\n        this.rotationDirections = [\"Bottom\", \"Top\", \"Left\", \"Right\"];\n        this.shapeStates = [\"BottomLeft\", \"TopLeft\"];\n        this.rotationState = {\n            animationState: \"Paused\",\n            rotationDirection: \"Left\",\n            coordinateShift: [3/4 * w,0],\n            rotationAngle: 0,\n            stateTime: 0,\n            shapeState: \"TopLeft\",\n            drawCoordinatesBottomLeft,\n            positionShift: [0,0],\n            drawCoordinatesTopLeft,\n            projectedDrawCoordinates, // change to projectedDrawCoordinates\n            midPauseTime: 10,\n            pauseTime: 1000,\n        };\n        this.addLineSprite(new BoxBoxSprite(this.transform, this.rotationState));\n        this.addChildGameObject(new EnemySpawn(this.gameEngine));\n        this.playSound(this.spawnSound);\n    }\n\n    // the radius will have to change as it spins\n    // maybe I should store relative coordinates of each point, and update them here\n    // I can make the further away line smaller width too\n\n    // I only care about the projected x and y coordinates as it rotates\n    // it will rotate a random direction, then pause\n\n    // directions it can rotate: Top, Bottom, Left, Right\n    // Bottom means x shift will be 0, y shift will be - 3/4 * w\n    // Top means x shift will be 0, y shift will be 3/4 * w\n    // Left means x shift will be - 3/4 * w, y shift will be 0\n    // Right means x shift will be 3/4 * w, y shift will be 0\n\n    // coordinates: BottomSquareBL, BottomSquareBR, BottomSquareTL, BottomSquareTR, TopSquareBL, TopSquareBR, TopSquareTL, TopSquareTR\n    // zCoordinates: _BottomSquareBL, _BottomSquareBR, _BottomSquareTL, _BottomSquareTR, _TopSquareBL, _TopSquareBR, _TopSquareTL, _TopSquareTR\n\n    // rotating next to the edge of the map is complicated... let's worry about it later\n\n    // tells the sprite which state it's in\n    // rotating, midPaused, completingRotation, paused\n\n    // lines parallel to the axis of rotation will be the same length\n    // coordinate perpendicular to the axis of rotation will be cosine of the angle of rotation\n\n    // switch to the other shape state\n    // switch to the other rotation direction\n    setupCompleteRotation() {\n        const rotationDirection = this.rotationState.rotationDirection;\n        const shapeState = this.rotationState.shapeState;\n        this.rotationState.shapeState = shapeState === \"TopLeft\" ? \"BottomLeft\" : \"TopLeft\";    \n        if(rotationDirection === \"Top\") {\n            this.setRotationDirectionProperties(\"Bottom\");\n        } else if(rotationDirection === \"Bottom\") {\n            this.setRotationDirectionProperties(\"Top\");\n        } else if(rotationDirection === \"Left\") {\n            this.setRotationDirectionProperties(\"Right\");\n        } else if(rotationDirection === \"Right\") {\n            this.setRotationDirectionProperties(\"Left\");\n        }\n    }\n\n    // let's just do flat boxbox rotation for now\n    // Bottom rotation first\n    // rotate until 90 degrees, pause, then unrotate until 0 degrees\n    animate(deltaTime) {\n        const animationState = this.rotationState.animationState;\n        let rotationAngle = this.rotationState.rotationAngle;\n        \n        const coordinateShift = this.rotationState.coordinateShift;\n        // defined statically above this class\n        const projectedDrawCoordinates = this.rotationState.projectedDrawCoordinates;\n\n        const midPauseTime = this.rotationState.midPauseTime;\n        const pauseTime = this.rotationState.pauseTime;\n        let originalAngle = rotationAngle;\n        if(animationState === \"Rotating\") {\n            this.rotationState.positionShift = [0,0];\n            if(rotationAngle < Math.PI / 2) {\n                rotationAngle += Math.PI / 2 * deltaTime / 1000;\n            } else {\n                rotationAngle = Math.PI / 2;\n                originalAngle = Math.PI / 2;\n                this.rotationState.animationState = \"MidPaused\";\n                // next rotation axis will be grabbed\n            }\n        } else if (animationState === \"MidPaused\") {\n            this.rotationState.stateTime += deltaTime;\n            // this.rotationState.positionShift[0] = this.rotationState.positionShift[0] * -1;\n            // this.rotationState.positionShift[1] = this.rotationState.positionShift[1] * -1;\n            if(this.rotationState.stateTime > midPauseTime) {\n                this.rotationState.stateTime = 0;\n                this.rotationState.animationState = \"CompletingRotation\";\n                this.setupCompleteRotation();\n            }\n        } else if(animationState === \"CompletingRotation\") {\n            // after the mid pause, we should continue the rotation\n            if(rotationAngle > 0) { \n                // this isn't general yet, since we can rotate up to 2 pi.. \n                // but that won't work since it could change to an orthogonal\n                // direction of rotation\n                rotationAngle -= Math.PI / 2 * deltaTime / 1000;\n            } else {\n                rotationAngle = 0;\n                originalAngle = 0;\n                this.rotationState.animationState = \"Paused\";\n            }\n        } else if(animationState === \"Paused\") {\n            this.rotationState.stateTime += deltaTime;\n            if(this.rotationState.stateTime > pauseTime) {\n                this.rotationState.stateTime = 0;\n                this.rotationState.animationState = \"Rotating\";\n                this.startRotation();\n            }\n        }\n        const rotationDirection = this.rotationState.rotationDirection;\n        this.rotationState.rotationAngle = rotationAngle;\n\n        // calculating the length and original angle once is faster than every frame\n        // #optimization\n        const w = this.boxWidth;\n        const d = this.boxDepth;\n        const positionChange = \n        (Math.sqrt((3/2 * w)**2 + d**2)/2) * Math.cos((originalAngle + Math.atan(d/ (3/2 * w)))) -\n        (Math.sqrt((3/2 * w)**2 + d**2)/2) * Math.cos((rotationAngle + Math.atan(d/ (3/2 * w))));\n        const drawPositionChange = (3/2 * w) / 2 - (Math.sqrt((3/2 * w)**2 + d**2)/2) * Math.cos((rotationAngle + Math.atan(d/ (3/2 * w))));\n\n        if(rotationDirection === \"Top\") { // because y is upside down\n            this.transform.pos[1] -= positionChange;\n            this.rotationState.positionShift[1] = -drawPositionChange;\n        } else if(rotationDirection === \"Bottom\") {\n            this.transform.pos[1] += positionChange;\n            this.rotationState.positionShift[1] = drawPositionChange;\n        } else if(rotationDirection === \"Left\") {\n            this.transform.pos[0] -= positionChange;\n            this.rotationState.positionShift[0] = -drawPositionChange;\n        } else if(rotationDirection === \"Right\") {\n            this.transform.pos[0] += positionChange;\n            this.rotationState.positionShift[0] = drawPositionChange;\n        }\n\n\n        // depending on which rotation direction, the coordinate shift will be different\n\n\n\n\n        // apply rotation angle to coordinates\n        const projectedWidthScale = [1, 1];\n        if(rotationDirection === \"Top\"  || rotationDirection === \"Bottom\") { \n            projectedWidthScale[1] = Math.cos(rotationAngle);\n        } else if (rotationDirection === \"Left\" || rotationDirection === \"Right\") {\n            projectedWidthScale[0] = Math.cos(rotationAngle);\n        }\n\n        // might be faster to do this as an array we map over and then draw with\n        // I can use the hard coded values directly when not rotating\n\n        // I think BottomLeft vs TopLeft will be no longer needed if we can continue to rotate past 90 degrees\n        // except theres issues there since it can rotate in any direction after getting to 180 degrees\n        // I think I'll have to then swap points to the reversed version\n        const drawCoordinates = this.rotationState.shapeState === \"BottomLeft\" ? this.rotationState.drawCoordinatesBottomLeft : this.rotationState.drawCoordinatesTopLeft;\n        let [x, y, angleOffset] = drawCoordinates.BottomSquareBL;\n        projectedDrawCoordinates.BottomSquareBL = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y + coordinateShift[1]) * projectedWidthScale[1]];\n        [x, y, angleOffset] = drawCoordinates.BottomSquareBR;\n        projectedDrawCoordinates.BottomSquareBR = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y + coordinateShift[1]) * projectedWidthScale[1]];\n        [x, y, angleOffset] = drawCoordinates.BottomSquareTL;\n        projectedDrawCoordinates.BottomSquareTL = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y + coordinateShift[1]) * projectedWidthScale[1]];\n        [x, y, angleOffset] = drawCoordinates.BottomSquareTR;\n        projectedDrawCoordinates.BottomSquareTR = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y + coordinateShift[1]) * projectedWidthScale[1]];\n        [x, y, angleOffset] = drawCoordinates.TopSquareBL;\n        projectedDrawCoordinates.TopSquareBL    = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y + coordinateShift[1]) * projectedWidthScale[1]];\n        [x, y, angleOffset] = drawCoordinates.TopSquareBR;\n        projectedDrawCoordinates.TopSquareBR    = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y + coordinateShift[1]) * projectedWidthScale[1]];\n        [x, y, angleOffset] = drawCoordinates.TopSquareTL;\n        projectedDrawCoordinates.TopSquareTL    = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y + coordinateShift[1]) * projectedWidthScale[1]];\n        [x, y, angleOffset] = drawCoordinates.TopSquareTR;\n        projectedDrawCoordinates.TopSquareTR    = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y + coordinateShift[1]) * projectedWidthScale[1]];\n\n        if(rotationDirection === \"Left\") {\n            const drawCoordinatesLeft = drawCoordinates.Left; \n            // rotationAngle += Math.PI;\n            // distances to axis of rotation, [x, y, angleOffset], y is the same, x requires pythag;\n            [x,y,angleOffset] = drawCoordinatesLeft._BottomSquareBL;\n            projectedDrawCoordinates._BottomSquareBL = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n                \n            [x, y, angleOffset] = drawCoordinatesLeft._BottomSquareBR;\n            projectedDrawCoordinates._BottomSquareBR = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n                \n            [x, y, angleOffset] = drawCoordinatesLeft._BottomSquareTL;\n            projectedDrawCoordinates._BottomSquareTL = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n                \n            [x, y, angleOffset] = drawCoordinatesLeft._BottomSquareTR;\n            projectedDrawCoordinates._BottomSquareTR = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n                \n            [x, y, angleOffset] = drawCoordinatesLeft._TopSquareBL;\n            projectedDrawCoordinates._TopSquareBL    = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n                \n            [x, y, angleOffset] = drawCoordinatesLeft._TopSquareBR;\n            projectedDrawCoordinates._TopSquareBR    = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n                \n            [x, y, angleOffset] = drawCoordinatesLeft._TopSquareTL;\n            projectedDrawCoordinates._TopSquareTL    = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n\n            [x, y, angleOffset] = drawCoordinatesLeft._TopSquareTR;\n            projectedDrawCoordinates._TopSquareTR    = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n        }\n        if(rotationDirection === \"Right\") {\n            const drawCoordinatesRight = drawCoordinates.Right; \n            rotationAngle += Math.PI;\n            // distances to axis of rotation, [x, y, angleOffset], y is the same, x requires pythag;\n            [x, y, angleOffset] = drawCoordinatesRight._BottomSquareBL;\n            projectedDrawCoordinates._BottomSquareBL = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n                \n            [x, y, angleOffset] = drawCoordinatesRight._BottomSquareBR;\n            projectedDrawCoordinates._BottomSquareBR = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n                \n            [x, y, angleOffset] = drawCoordinatesRight._BottomSquareTL;\n            projectedDrawCoordinates._BottomSquareTL = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n                \n            [x, y, angleOffset] = drawCoordinatesRight._BottomSquareTR;\n            projectedDrawCoordinates._BottomSquareTR = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n                \n            [x, y, angleOffset] = drawCoordinatesRight._TopSquareBL;\n            projectedDrawCoordinates._TopSquareBL    = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n                \n            [x, y, angleOffset] = drawCoordinatesRight._TopSquareBR;\n            projectedDrawCoordinates._TopSquareBR    = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n                \n            [x, y, angleOffset] = drawCoordinatesRight._TopSquareTL;\n            projectedDrawCoordinates._TopSquareTL    = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n\n            [x, y, angleOffset] = drawCoordinatesRight._TopSquareTR;\n            projectedDrawCoordinates._TopSquareTR    = [(x * Math.cos(angleOffset + rotationAngle)), (-y + coordinateShift[1]) * projectedWidthScale[1]];\n        }\n        if(rotationDirection === \"Top\") {\n            const drawCoordinatesTop = drawCoordinates.Top; \n            // rotationAngle += Math.PI;\n            // distances to axis of rotation, [x, y, angleOffset], x is the same, y requires pythag;\n            [x,y,angleOffset] = drawCoordinatesTop._BottomSquareBL;\n            projectedDrawCoordinates._BottomSquareBL = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n                \n            [x, y, angleOffset] = drawCoordinatesTop._BottomSquareBR;\n            projectedDrawCoordinates._BottomSquareBR = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n                \n            [x, y, angleOffset] = drawCoordinatesTop._BottomSquareTL;\n            projectedDrawCoordinates._BottomSquareTL = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n                \n            [x, y, angleOffset] = drawCoordinatesTop._BottomSquareTR;\n            projectedDrawCoordinates._BottomSquareTR = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n                \n            [x, y, angleOffset] = drawCoordinatesTop._TopSquareBL;\n            projectedDrawCoordinates._TopSquareBL    = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n                \n            [x, y, angleOffset] = drawCoordinatesTop._TopSquareBR;\n            projectedDrawCoordinates._TopSquareBR    = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n                \n            [x, y, angleOffset] = drawCoordinatesTop._TopSquareTL;\n            projectedDrawCoordinates._TopSquareTL    = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n\n            [x, y, angleOffset] = drawCoordinatesTop._TopSquareTR;\n            projectedDrawCoordinates._TopSquareTR    = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n        } \n        if(rotationDirection === \"Bottom\") {\n            const drawCoordinatesBottom = drawCoordinates.Bottom; \n            // rotationAngle += Math.PI;\n            // distances to axis of rotation, [x, y, angleOffset], x is the same, y requires pythag;\n            [x,y,angleOffset] = drawCoordinatesBottom._BottomSquareBL;\n            projectedDrawCoordinates._BottomSquareBL = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n                \n            [x, y, angleOffset] = drawCoordinatesBottom._BottomSquareBR;\n            projectedDrawCoordinates._BottomSquareBR = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n                \n            [x, y, angleOffset] = drawCoordinatesBottom._BottomSquareTL;\n            projectedDrawCoordinates._BottomSquareTL = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n                \n            [x, y, angleOffset] = drawCoordinatesBottom._BottomSquareTR;\n            projectedDrawCoordinates._BottomSquareTR = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n                \n            [x, y, angleOffset] = drawCoordinatesBottom._TopSquareBL;\n            projectedDrawCoordinates._TopSquareBL    = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n                \n            [x, y, angleOffset] = drawCoordinatesBottom._TopSquareBR;\n            projectedDrawCoordinates._TopSquareBR    = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n                \n            [x, y, angleOffset] = drawCoordinatesBottom._TopSquareTL;\n            projectedDrawCoordinates._TopSquareTL    = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n\n            [x, y, angleOffset] = drawCoordinatesBottom._TopSquareTR;\n            projectedDrawCoordinates._TopSquareTR    = [(x + coordinateShift[0]) * projectedWidthScale[0], (-y * Math.cos(angleOffset + rotationAngle))];\n        }\n        // I do not need to consider the coordinate shift for the prime coordinates\n        // I do for the non-primes because they are drawn from the center of the BoxBox, and are more general\n    }\n    \n    setRotationDirectionProperties(rotationDirection) {\n        const w = this.boxWidth;\n        const coordinateShift = this.rotationState.coordinateShift;\n        if(rotationDirection === \"Top\") {\n            coordinateShift[0] = 0;\n            coordinateShift[1] = 3/4 * w;\n        } else if (rotationDirection === \"Bottom\") {\n            coordinateShift[0] = 0;\n            coordinateShift[1] = -3/4 * w;\n        } else if (rotationDirection === \"Left\") {\n            coordinateShift[0] = 3/4 * w;\n            coordinateShift[1] = 0;\n        } else if (rotationDirection === \"Right\") {\n            coordinateShift[0] = -3/4 * w;\n            coordinateShift[1] = 0;\n        }\n        this.rotationState.rotationDirection = rotationDirection;\n    }\n\n    startRotation() {\n        // pick rotation direction\n        // if (this.rotationState.rotationDirection === \"Bottom\") {\n        //     this.rotationState.shapeState = this.rotationState.shapeState === \"TopLeft\" ? \"BottomLeft\" : \"TopLeft\";\n        // }\n        // const directionsMap = {Top: \"Right\", Right: \"Bottom\", Bottom: \"Left\", Left: \"Top\"};\n        // pick random rotation direction \n        const rotationDirection = this.rotationDirections[Math.floor(Math.random() * this.rotationDirections.length)]; \n        // const rotationDirection = directionsMap[this.rotationState.rotationDirection];\n        \n        this.setRotationDirectionProperties(rotationDirection);\n    }\n\n    continueRotation() {\n        // swap points, change coordinate shift\n    }\n\n    exist() {\n    // leaving off subscriptions means that things will subscribe to it\n        this.addCollider(\"General\", this, this.radius);\n        // now it will move\n        this.addPhysicsComponent();\n    }\n \n    wallGraze(){\n        this.gameEngine.gameScript.wallGraze(this.transform, this.radius);\n    }\n\n    update(delta){\n        this.animate(delta);\n        if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius * 2)) {\n            this.wallGraze(); \n        }\n    }\n}\n","import { LineSprite } from \"../../../game_engine/line_sprite\";\n\nexport class BoxBoxSprite extends LineSprite {\n    constructor(transform, rotationState) {\n        super(transform);\n        this.spawningScale = 1;\n        this.rotationState = rotationState || {positionShift: [0,0], coordinateShift: [0,0], projectedDrawCoordinates: []};\n        this.spawning = false;\n    }\n\n    draw(ctx) {\n        if(!this.visible) return;\n        const spawningScale = this.spawningScale ||= 1;\n        const pos = this.transform.absolutePosition();\n        const boxWidth = 11 * spawningScale;\n\n        // ctx.strokeStyle = \"#F173BA\";\n\n        const r = 210;\n        const g = 75;\n        const b = 75;\n        ctx.save();\n        if(this.spawning !== false) {\n            const w = boxWidth * spawningScale;\n            ctx.translate(\n                pos[0], \n                pos[1]\n            );\n            this.drawSpawningBoxBox(ctx, w);\n            \n            return;\n        }\n        ctx.translate(\n            pos[0]  - this.rotationState.positionShift[0] - this.rotationState.coordinateShift[0], \n            pos[1]  - this.rotationState.positionShift[1] - this.rotationState.coordinateShift[1]\n        );\n        const blurFactor = 0.5;\n        ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n        ctx.shadowBlur = 10 * blurFactor;\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n        ctx.lineWidth = 7.5 * blurFactor;\n        this.drawBox1(ctx);\n        this.drawBox2(ctx);\n        ctx.lineWidth = 6 * blurFactor;\n        this.drawBox1(ctx);\n        this.drawBox2(ctx);\n        ctx.lineWidth = 4.5;\n        this.drawBox1(ctx);\n        this.drawBox2(ctx);\n        ctx.lineWidth = 3;\n        this.drawBox1(ctx);\n        this.drawBox2(ctx);\n        ctx.strokeStyle = \"rgb(255, 255, 255)\";\n        ctx.lineWidth = 1.5;\n        this.drawBox1(ctx);\n        this.drawBox2(ctx);\n        ctx.restore();\n    }\n\n    drawSpawningBoxBox(ctx, w) {\n        const r = 210;\n        const g = 75;\n        const b = 75;\n        const blurFactor = 0.5;\n        ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n        ctx.shadowBlur = 10 * blurFactor;\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n        ctx.lineWidth = 7.5 * blurFactor;\n        this.drawSpawningBox1(ctx, w);\n        this.drawSpawningBox2(ctx, w);\n        ctx.lineWidth = 6 * blurFactor;\n        this.drawSpawningBox1(ctx, w);\n        this.drawSpawningBox2(ctx, w);\n        ctx.lineWidth = 4.5;\n        this.drawSpawningBox1(ctx, w);\n        this.drawSpawningBox2(ctx, w);\n        ctx.lineWidth = 3;\n        this.drawSpawningBox1(ctx, w);\n        this.drawSpawningBox2(ctx, w);\n        ctx.strokeStyle = \"rgb(255, 255, 255)\";\n        ctx.lineWidth = 1.5;\n        this.drawSpawningBox1(ctx, w);\n        this.drawSpawningBox2(ctx, w);\n        ctx.restore();\n    }\n\n    drawSpawningBox1(ctx, w) {\n        ctx.beginPath();\n        ctx.moveTo(-w / 4, w / 4);\n        ctx.lineTo(-w / 4, (-3 * w) / 4);\n        ctx.lineTo((3 * w) / 4, (-3 * w) / 4);\n        ctx.lineTo((3 * w) / 4, w / 4);\n        ctx.closePath();\n        ctx.stroke();\n    }\n    drawSpawningBox2(ctx, w) {\n        ctx.beginPath();\n        ctx.moveTo(w  / 4, -w  / 4);\n        ctx.lineTo(w  / 4, (3 * w)  / 4);\n        ctx.lineTo((-3 * w ) / 4, (3 * w ) / 4);\n        ctx.lineTo((-3 * w ) / 4, -w  / 4);\n        ctx.closePath();\n        ctx.stroke();\n    }\n\n    drawBox1(ctx) {\n\n        // need to rethink spawn scaling. \n        // I might have to bring back the original draw methods for spawn animation\n\n\n        \n        const projectedCoordinates = this.rotationState.projectedDrawCoordinates;\n        \n        const point1 = projectedCoordinates.BottomSquareBL;\n        const point2 = projectedCoordinates.BottomSquareBR;\n        const point3 = projectedCoordinates.BottomSquareTR;\n        const point4 = projectedCoordinates.BottomSquareTL;\n\n        ctx.beginPath();\n        ctx.moveTo(point1[0], point1[1]);\n        ctx.lineTo(point2[0], point2[1]);\n        ctx.lineTo(point3[0], point3[1]);\n        ctx.lineTo(point4[0], point4[1]);\n        ctx.closePath();\n        ctx.stroke();\n\n        const _point1 = projectedCoordinates._BottomSquareBL;\n        const _point2 = projectedCoordinates._BottomSquareBR;\n        const _point3 = projectedCoordinates._BottomSquareTR;\n        const _point4 = projectedCoordinates._BottomSquareTL;\n\n        ctx.beginPath();\n        ctx.moveTo(_point1[0], _point1[1]);\n        ctx.lineTo(_point2[0], _point2[1]);\n        ctx.lineTo(_point3[0], _point3[1]);\n        ctx.lineTo(_point4[0], _point4[1]);\n        ctx.closePath();\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(point1[0], point1[1]);\n        ctx.lineTo(_point1[0], _point1[1]);\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(point2[0], point2[1]);\n        ctx.lineTo(_point2[0], _point2[1]);\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(point3[0], point3[1]);\n        ctx.lineTo(_point3[0], _point3[1]);\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(point4[0], point4[1]);\n        ctx.lineTo(_point4[0], _point4[1]);\n        ctx.stroke();\n\n            \n    }\n\n    drawBox2(ctx) {\n        \n        const projectedCoordinates = this.rotationState.projectedDrawCoordinates;\n        const point1 = projectedCoordinates.TopSquareBL;\n        const point2 = projectedCoordinates.TopSquareBR;\n        const point3 = projectedCoordinates.TopSquareTR;\n        const point4 = projectedCoordinates.TopSquareTL;\n\n        ctx.beginPath();\n        ctx.moveTo(point1[0], point1[1]);\n        ctx.lineTo(point2[0], point2[1]);\n        ctx.lineTo(point3[0], point3[1]);\n        ctx.lineTo(point4[0], point4[1]);\n        ctx.closePath();\n        ctx.stroke();\n\n        const _point1 = projectedCoordinates._TopSquareBL;\n        const _point2 = projectedCoordinates._TopSquareBR;\n        const _point3 = projectedCoordinates._TopSquareTR;\n        const _point4 = projectedCoordinates._TopSquareTL;\n\n        ctx.beginPath();\n        ctx.moveTo(_point1[0], _point1[1]);\n        ctx.lineTo(_point2[0], _point2[1]);\n        ctx.lineTo(_point3[0], _point3[1]);\n        ctx.lineTo(_point4[0], _point4[1]);\n        ctx.closePath();\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(point1[0], point1[1]);\n        ctx.lineTo(_point1[0], _point1[1]);\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(point2[0], point2[1]);\n        ctx.lineTo(_point2[0], _point2[1]);\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(point3[0], point3[1]);\n        ctx.lineTo(_point3[0], _point3[1]);\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(point4[0], point4[1]);\n        ctx.lineTo(_point4[0], _point4[1]);\n        ctx.stroke();\n    }\n\n    // drawBox2(ctx, boxSize) {\n    //     const w = boxSize;\n    //     const slideFactor = 1.5;\n    //     ctx.beginPath();\n    //     ctx.moveTo(-w / 4, w / 4);\n    //     ctx.lineTo(-w / 4, (-3 * w) / 4);\n    //     ctx.lineTo((3 * w) / 4, (-3 * w) / 4);\n    //     ctx.lineTo((3 * w) / 4, w / 4);\n    //     ctx.closePath();\n    //     ctx.stroke();\n    // }\n}\n","import {GameObject} from \"../../../game_engine/game_object\";\nimport {Sound} from \"../../../game_engine/sound\";\nimport { Util } from \"../../../game_engine/util\";\nimport {EnemySpawn} from \"../../particles/enemy_spawn\";\nimport {GruntSprite} from \"./grunt_sprite\";\nexport class Grunt extends GameObject {\n    constructor(engine, pos, shipTransform) {\n        super(engine);\n        this.transform.pos = pos;\n        this.exists = false;\n        this.stretchDirection = -1;\n        this.shipTransform = shipTransform;\n        this.radius = 5;\n        this.points = 70;\n        this.speed = 1.5;\n        this.bumpAcceleration = 1.5;\n        this.bumpInfluencers = [];\n        this.bumpDirectionInfluenced = false;\n        this.spawnSound = new Sound(\"sounds/Enemy_spawn_blue.wav\", 0.5);\n        this.playSound(this.spawnSound);\n        this.addLineSprite(new GruntSprite(this.transform));\n        this.addChildGameObject(new EnemySpawn(this.gameEngine));\n    }\n\n    exist() {\n        this.exists = true;\n        // leaving off subscriptions means that things will subscribe to it\n        this.addCollider(\"General\", this, this.radius);\n        this.addCollider(\"Bump\", this, this.radius, [\"Grunt\", \"Weaver\"], [\"General\"]);\n        // now it will move\n        this.addPhysicsComponent();\n    }\n\n    onCollision(collider, type){\n        if (type === \"Bump\" && collider.gameObject !== this) {\n            this.acceptBumpDirection(collider.gameObject.transform.pos);\n        }\n    }\n    \n\n    acceptBumpDirection(source) {\n        this.bumpDirectionInfluenced = true;\n        const dy = this.transform.pos[1] - source[1];\n        const dx = this.transform.pos[0] - source[0];\n        const unitVector = Util.dir([dx, dy]);\n        this.bumpInfluencers.push(unitVector);\n    // first \n    }\n\n    influenceDirection(influencers) {\n        let directionVector = [0, 0];\n\n        influencers.forEach((influencer) => {\n            const dx = directionVector[0] + influencer[0];\n            const dy = directionVector[1] + influencer[1];\n            const newVector = [dx, dy];\n            directionVector = Util.dir(newVector);\n        });\n        const influencedDirection = Math.atan2(directionVector[1], directionVector[0]);\n        return influencedDirection;\n    }\n\n\n\n\n\n    // ADDING MOVEMENT MECHANICS FOR GRUNT\n\n    chase(timeDelta) {\n        const speed = this.speed; \n        const shipPos = this.shipTransform.pos;\n        const pos = this.transform.pos;\n        const dy = shipPos[1] - pos[1];\n        const dx = shipPos[0] - pos[0];\n\n        const velocityScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n        const direction = Math.atan2(dy, dx);\n\n        this.transform.pos[0] += speed * Math.cos(direction) * velocityScale;\n        this.transform.pos[1] += speed * Math.sin(direction) * velocityScale;\n    }\n\n    animate(timeDelta) {\n        const cycleSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n        const cycleSpeed = 0.01;\n        if (this.lineSprite.stretchScale_W < 0.7 || this.lineSprite.stretchScale_W > 1) {\n            this.stretchDirection *= -1;\n        }\n\n        this.lineSprite.stretchScale_W = this.lineSprite.stretchScale_W + -this.stretchDirection * cycleSpeed * cycleSpeedScale;\n        this.lineSprite.stretchScale_L = this.lineSprite.stretchScale_L + this.stretchDirection * cycleSpeed * cycleSpeedScale;\n\n    }\n\n    update(timeDelta) {\n        if (this.exists) {\n            const bumpAcceleration = this.bumpAcceleration;\n\n            this.animate(timeDelta);\n\n            if(this.bumpDirectionInfluenced) {\n                const direction = this.influenceDirection(this.bumpInfluencers);\n                this.transform.acc[0] += bumpAcceleration * Math.cos(direction) / 100;\n                this.transform.acc[1] += bumpAcceleration * Math.sin(direction) / 100;\n            } \n            this.chase(timeDelta);\n      \n            if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\n                this.wallGraze();\n            }\n            this.bumpInfluencers = [];\n            this.bumpDirectionInfluenced = false;\n        }\n    }\n\n    wallGraze() {\n        this.gameEngine.gameScript.wallGraze(this.transform, this.radius);\n    }\n\n  \n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","import {LineSprite} from \"../../../game_engine/line_sprite\";\nexport class GruntSprite extends LineSprite {\n    constructor(transform, spawningScale = 1) {\n        super(transform)\n        this.spawningScale = spawningScale\n        this.stretchScale_L = 1\n        this.stretchScale_W = 0.7\n    }\n\n    draw(ctx) {\n        if(!this.visible) return;\n        const pos = this.transform.absolutePosition();\n    \n        const spawningScale = this.spawningScale;\n        const shipLength = 10 * 2.2 * spawningScale * this.stretchScale_L;\n        const shipWidth = 10 * 2.2 * spawningScale * this.stretchScale_W;\n        const l = shipLength;\n        const w = shipWidth;\n\n        const r = 0;\n        const g = 57;\n        const b = 230;\n\n        ctx.save();\n        ctx.translate(pos[0], pos[1]);\n\n        const blurFactor = 0.5\n\n        ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n        ctx.shadowBlur = 10\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n        ctx.lineWidth = 7.5 * blurFactor;\n        this.drawDiamond(ctx, l, w);\n        ctx.lineWidth = 6 // * blurFactor;\n        this.drawDiamond(ctx, l, w);\n        ctx.lineWidth = 4.5 // * blurFactor;\n        this.drawDiamond(ctx, l, w);\n        ctx.lineWidth = 3 // * blurFactor;\n        this.drawDiamond(ctx, l, w);\n        ctx.strokeStyle = 'rgb(255, 255, 255)';\n        ctx.lineWidth = 1.5 // * blurFactor;\n        this.drawDiamond(ctx, l, w);\n    \n        ctx.restore();\n    }\n\n    drawDiamond(ctx, l, w) {\n        ctx.beginPath();\n        ctx.moveTo(0, -l / 2); //1\n        ctx.lineTo(w / 2, 0); //2\n        ctx.lineTo(0, l / 2); //3\n        ctx.lineTo(-w / 2, -0); //4\n        ctx.closePath();\n        ctx.stroke();\n    }\n\n\n\n\n}\n","import {Sound} from \"../../../game_engine/sound\";\nimport {Util} from \"../../../game_engine/util\";\nimport {GameObject} from \"../../../game_engine/game_object\";\nimport {EnemySpawn} from \"../../particles/enemy_spawn\";\nimport {PinwheelSprite} from \"./pinwheel_sprite\";\n\nexport class Pinwheel extends GameObject {\n    constructor(engine, pos) {\n        super(engine);\n        this.rotation_speed = 0.05;\n        const speed = 1;\n        this.points = 20;\n        this.transform.pos = pos;\n        this.transform.vel = Util.randomVec(speed);\n        this.spawnSound = new Sound(\"sounds/Enemy_spawn_blue.wav\", 0.5);\n        this.playSound(this.spawnSound);\n        this.addLineSprite(new PinwheelSprite(this.transform));\n        this.addChildGameObject(new EnemySpawn(this.gameEngine));\n        this.radius = 5;\n    }\n  \n    exist() {\n    // leaving off subscriptions means that things will subscribe to it\n        this.addCollider(\"General\", this, this.radius);\n        // now it will move\n        this.addPhysicsComponent();\n    }\n\n    animate(deltaTime) {\n        const rotationSpeedScale = deltaTime / NORMAL_FRAME_TIME_DELTA;\n        this.transform.angle = (this.transform.angle + this.rotation_speed * rotationSpeedScale) % (Math.PI * 2);\n    }\n\n    update(deltaTime){\n        this.animate(deltaTime);\n        if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\n            this.gameEngine.gameScript.bounce(this.transform, this.radius); // HARD CODED\n        }\n    }\n\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","import { LineSprite } from \"../../../game_engine/line_sprite\";\nexport class PinwheelSprite extends LineSprite {\n    constructor(transform, spawningScale = 1) {\n        super(transform);\n        this.spawningScale = spawningScale;\n    }\n\n    draw(ctx) {\n        if(!this.visible) return;\n        \n        const spawningScale = this.spawningScale || 1;\n        const pos = this.transform.absolutePosition();\n        const angle = this.transform.absoluteAngle();\n\n        const shipWidth = 18 * spawningScale;\n        const s = shipWidth / 2;\n\n        const r = 59;\n        const g = 10;\n        const b = 87;\n\n        ctx.save();\n        ctx.translate(pos[0], pos[1]);\n        ctx.rotate(angle);\n\n        const blurFactor = 0.5;\n        ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n        ctx.shadowBlur = 10 * blurFactor * blurFactor;\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n        ctx.lineWidth = 7.5 * blurFactor * blurFactor;\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n        this.drawPinwheel(ctx, s);\n        ctx.lineWidth = 6 * blurFactor;\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.6)\";\n        this.drawPinwheel(ctx, s);\n        ctx.lineWidth = 4.5;\n        this.drawPinwheel(ctx, s);\n        ctx.lineWidth = 3;\n        this.drawPinwheel(ctx, s);\n        ctx.strokeStyle = 'rgb(200, 100, 255)';\n        ctx.lineWidth = 1.5;\n        this.drawPinwheel(ctx, s);\n\n        // ctx.strokeStyle = \"#971adf\";\n        // ctx.lineWidth = 1.8;\n\n        ctx.restore();\n    }\n\n    drawPinwheel(ctx, s) {\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(0, 0); //1\n        ctx.lineTo(-s, -s); //2\n        ctx.lineTo(0, -s); //3\n        ctx.lineTo(0, 0); //1\n        ctx.lineTo(s, -s); //4\n        ctx.lineTo(s, 0); //5\n        ctx.lineTo(0, 0); //1\n        ctx.lineTo(s, s); //6\n        ctx.lineTo(0, s); //7\n        ctx.lineTo(0, 0); //1\n        ctx.lineTo(-s, s); //8\n        ctx.lineTo(-s, 0); //9\n        // ctx.lineTo(); //1\n\n        ctx.closePath();\n        ctx.stroke();\n    }\n\n\n\n\n}\n","import { GameObject } from \"../../game_engine/game_object\";\nimport { LineSprite } from \"../../game_engine/line_sprite\";\nexport class RandomRandom extends GameObject {\n    constructor(engine, pos) {\n        super(engine);\n        this.transform.pos = pos;\n        this.addLineSprite(new RandomRandomSprite(this.transform));\n    }\n}\nexport class RandomRandomSprite extends LineSprite {\n    constructor(transform) {\n        super(transform);\n        this.widthHeight = [20,20];\n        this.spawningScale = 1;\n        // center is in the corning since I don't want to deal   \n    }\n\n    draw(ctx) {\n        if(!this.visible) return;\n        const pos = this.transform.absolutePosition();\n        ctx.save();\n        ctx.translate(pos[0], pos[1]);\n\n        this.drawRandomRandom(ctx, this.radius);\n        \n        ctx.restore();\n    }\n\n    drawRandomRandom(ctx) {\n        const h = this.widthHeight[1] * this.spawningScale;\n        const w = this.widthHeight[0] * this.spawningScale;\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = \"#FFFFFF\";\n        ctx.beginPath();\n        ctx.moveTo(-w/2,-h/2);\n        ctx.lineTo(w/2,-h/2);\n        ctx.lineTo(w/2,h/2);\n        ctx.lineTo(-w/2,h/2);\n        ctx.closePath();\n        ctx.stroke();\n    }\n}","import { GameObject } from \"../../../game_engine/game_object\";\nimport { Sound } from \"../../../game_engine/sound\";\nimport { Util } from \"../../../game_engine/util\";\nimport { AlienShipSprite } from \"./alien_ship_sprite\";\n\nexport class AlienShip extends GameObject {\n    constructor(engine, pos, velocity, shipTransform) {\n        super(engine);\n        this.transform.pos[0] = pos[0];\n        this.transform.pos[1] = pos[1];\n        this.transform.vel[0] = velocity[0];\n        this.transform.vel[1] = velocity[1];\n\n        this.shipTransform = shipTransform;\n        this.radius = 4;\n        this.points = 120;\n        this.chaseSpeed = 3.5;\n        this.chaseAcceleration = 0.125 / 3;\n        this.addLineSprite(new AlienShipSprite(this.transform));\n        this.addCollider(\"General\", this, this.radius);\n        this.addPhysicsComponent();\n    }\n\n    // change to acceleration\n   \n\n    update(timeDelta) {\n        // console.log(this.transform.pos)\n        this.chase();\n\n        if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\n            this.bounce();\n        }\n    }\n\n    bounce() {\n        this.gameEngine.gameScript.bounce(this.transform, this.radius);\n    }\n\n    chase() {\n        // take current velocity\n        // find ideal velocity using max speed, current position, and ship position\n        // get unit vector of current position - ship position\n        // take difference\n        // apply acceleration in that direction\n\n        // get dV\n        //    mV => max speed in the direction it should be moving\n        //    Vo => current velocity\n        //    dV =  mV - Vo\n        //    alpha = dV angle\n\n        const speed = this.chaseSpeed;\n\n        const shipPos = this.shipTransform.absolutePosition();\n        const pos = this.transform.absolutePosition();\n        const deltaPosition = [shipPos[0] - pos[0], shipPos[1] - pos[1]];\n        let chaseDirection = Math.atan2(deltaPosition[1], deltaPosition[0]);\n\n        // Math.atan2 was giving me negative numbers.... when it shouldn't\n        if (chaseDirection < 0) {\n            chaseDirection = 2 * Math.PI + chaseDirection;\n        }\n        // console.log(chaseDirection / (2 * Math.PI) * 360)\n        const Vm = [speed * Math.cos(chaseDirection), speed * Math.sin(chaseDirection)];\n        const Vo = this.transform.vel;\n\n        const dV = [Vm[0] - Vo[0], Vm[1] - Vo[1]];\n        const accelerationDirection = Math.atan2(dV[1], dV[0]);\n        this.transform.acc[0] += this.chaseAcceleration * Math.cos(accelerationDirection);\n        this.transform.acc[1] += this.chaseAcceleration * Math.sin(accelerationDirection);\n        // console.log(this.transform.acc)\n    }\n\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","import { LineSprite } from \"../../../game_engine/line_sprite\";\n\nexport class AlienShipSprite extends LineSprite {\n    constructor(transform) {\n        super(transform);\n        this.radius = 4;\n    }\n\n    draw(ctx) {\n        ctx.strokeStyle = 'rgb(255, 255, 255)';\n        const r = 180;\n        const g = 180;\n        const b = 255;\n\n        ctx.save();\n\n        // ctx.strokeStyle = \"#4286f4\";\n        // ctx.lineWidth = 4;\n        const blurFactor = 0.5;\n\n        ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n        ctx.lineWidth = 4;\n        this.drawAlienShip(ctx, this.radius);\n        ctx.lineWidth = 3;\n        this.drawAlienShip(ctx, this.radius);\n        ctx.lineWidth = 2;\n        this.drawAlienShip(ctx, this.radius);\n        ctx.lineWidth = 1;\n        this.drawAlienShip(ctx, this.radius);\n        ctx.strokeStyle = 'rgb(255, 255, 255)';\n        ctx.lineWidth = 0.75;\n        this.drawAlienShip(ctx, this.radius);\n        ctx.restore();\n    }\n\n    drawAlienShip(ctx, radius) {\n        ctx.beginPath();\n        const pos = this.transform.absolutePosition();\n        ctx.arc(pos[0], pos[1], radius, 0, 2 * Math.PI, true);\n        ctx.stroke();\n    }\n}","import { GameObject } from \"../../../game_engine/game_object\";\nimport { Sound } from \"../../../game_engine/sound\";\nimport { Util } from \"../../../game_engine/util\";\nimport { ParticleExplosion } from \"../../particles/particle_explosion\";\nimport { SingularityHitExplosion } from \"../../particles/singularity_hit_explosion\";\nimport { EnemySpawn } from \"../../particles/enemy_spawn\";\nimport { SingularitySprite } from \"./singularity_sprite\";\nimport { SingularityParticles } from \"../../particles/singularity_particles\";\nimport { AlienShip } from \"./alien_ship\";\nimport { GridPoint } from \"../../particles/Grid/grid_point\";\nexport class Singularity extends GameObject {\n    constructor(engine, pos) {\n        super(engine);\n        this.transform.pos = pos;\n        this.transform.pos[2] = 0;\n        this.gravityWellSize = 1000;\n        this.gravityConstant = 1000 * 0.5;\n        this.radius = 15;\n        this.points = 100;\n        this.throbbingCycleSpeed = 0.002;\n        this.numberAbsorbed = 0;\n        this.alienSpawnAmount = 10;\n        this.alienSpawnSpeed = 1.5;\n        this.gravityPulsateScale = 1;\n        this.deathSound = new Sound(\"sounds/Gravity_well_die.wav\");\n        this.gravityWellHitSound = new Sound(\"sounds/Gravity_well_hit.wav\", 0.5);\n        this.openGateSound = new Sound(\"sounds/Gravity_well_explode.wav\");\n        // this.id = options.id\n        this.spawnSound = new Sound(\"sounds/Enemy_spawn_red.wav\", 1);\n        this.playSound(this.spawnSound);\n\n        this.increasing = true;\n        this.addLineSprite(new SingularitySprite(this.transform));\n        this.addChildGameObject(new EnemySpawn(this.gameEngine));\n        this.lineSprite.throbbingScale = 1;\n        this.lives = 5;\n    }\n\n    exist() {\n    // leaving off subscriptions means that things will subscribe to it\n        this.addCollider(\"General\", this, this.radius);\n        this.addCollider(\"GravityWell\", this, this.gravityWellSize, [\"Grunt\", \"Pinwheel\", \"Bullet\", \"Ship\", \"BoxBox\", \"Arrow\", \"Singularity\", \"Weaver\", \"Particle\", \"SingularityParticle\", \"GridPoint\"],  [\"General\"]);\n        this.addCollider(\"Absorb\", this, this.radius, [\"Grunt\", \"Pinwheel\", \"BoxBox\", \"Arrow\", \"Weaver\"],  [\"General\"]);\n        // now it will move\n        this.addPhysicsComponent();\n        this.lineSprite.spawned = true;\n        this.addChildGameObject(new SingularityParticles(this.gameEngine, this.transform));\n    }\n\n    onCollision(collider, type){\n        if (type === \"GravityWell\"){\n            this.influenceAcceleration(collider.gameObject);\n        } else if (type === \"Absorb\") {\n            const hitObjectTransform = collider.gameObject.transform;\n            const pos = hitObjectTransform.absolutePosition();\n            const vel = hitObjectTransform.absoluteVelocity();\n            const explosion = new ParticleExplosion(this.gameEngine, pos);\n            collider.gameObject.remove();\n\n            this.throbbingCycleSpeed *= 1.2;\n            this.numberAbsorbed += 1; // put back to 1 \n        }\n    }\n\n    bulletHit(){\n        this.lives -= 1;\n        const pos = this.transform.absolutePosition();\n        const vel = this.transform.absoluteVelocity();\n        if (this.lives <= 0) {\n            const explosion = new ParticleExplosion(this.gameEngine, pos);\n            this.gameEngine.gameScript.tallyScore(this);\n            this.playSound(this.deathSound);\n            this.remove();\n        } else {\n            const explosion = new SingularityHitExplosion(this.gameEngine, pos);\n            this.playSound(this.gravityWellHitSound);\n            this.throbbingCycleSpeed /= 1.2;\n            this.numberAbsorbed -= 1;\n        }\n    }\n\n    wallGraze() {\n        this.gameEngine.gameScript.wallGraze(this.transform, this.radius);\n    }\n  \n\n    update(deltaTime) {\n\n        if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\n            this.wallGraze();\n        }\n        if (this.numberAbsorbed === 5) {\n            this.soundAlarm(deltaTime);\n        }\n\n        this.animate(deltaTime);\n        if (this.numberAbsorbed >= 6) {\n            this.openGate();\n        }\n    }\n\n    soundAlarm(deltaTime){\n\n    }\n\n    animate(timeDelta) {\n\n        const cycleSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n        const cycleSpeed = this.throbbingCycleSpeed;\n        // increase scale until 1.2, decrease until 0.8\n\n        if (this.increasing) {\n            this.lineSprite.throbbingScale += cycleSpeed * cycleSpeedScale;\n            this.gravityPulsateScale += cycleSpeed * 2 * cycleSpeedScale;\n            if (this.lineSprite.throbbingScale > 1.2) {\n                this.increasing = !this.increasing;\n            }\n        } else {\n            this.lineSprite.throbbingScale -= cycleSpeed * cycleSpeedScale;\n            this.gravityPulsateScale -= cycleSpeed * 2 * cycleSpeedScale;\n            if (this.lineSprite.throbbingScale < 0.8) {\n                this.increasing = !this.increasing;\n            }\n        }\n    }\n\n    influenceAcceleration(object) {\n        const pos = this.transform.absolutePosition();\n\n        if(object instanceof GridPoint) {\n            // let's try moving their original position in the z direction \n            // depending on strength of gravity influence\n            const objectPos3D = [object.transform.pos[0], object.transform.pos[1], object.transform.pos[2]];\n            const dVector = [pos[0] - objectPos3D[0], pos[1] - objectPos3D[1], -200 - objectPos3D[2]]; // -200 is the z position of the gravity well for the grid\n            const dVectorZOrigin = [pos[0] - objectPos3D[0], pos[1] - objectPos3D[1],0]; // -200 is the z position of the gravity well for the grid\n            let r = Util.dist([0,0,0], dVector);\n            let rZOrigin = Util.dist([0,0,0], dVectorZOrigin);\n            \n            if(r < 25) r = 25;\n            if(rZOrigin < 25) rZOrigin = 25;\n            // I think I can use both effects, but this one should be a lot smaller\n            // and then tuning it would be harder\n                \n            // I really like the wave effect that happens with z acceleration being 25, and the spring -0.0025 + dampening -0.04\n            // but Z's effect distends too far\n            const unitVector3D = Util.scale(dVector, 1/r);\n            const accContribution= [\n                unitVector3D[0] * this.gravityConstant * 20 * this.gravityPulsateScale / (r * r),\n                unitVector3D[1] * this.gravityConstant * 20 * this.gravityPulsateScale / (r * r),\n                unitVector3D[2] * this.gravityConstant * 10 * this.gravityPulsateScale / (r * r)\n            ];\n\n            // *************\n            // will need to multiply this a good amount\n            // if(r < 25) r=25;\n            const zContribution = this.gravityConstant * 20 * this.gravityPulsateScale / (rZOrigin ** 2) * 150;\n            //// ************\n\n            object.transform.acc[0] += accContribution[0];\n            object.transform.acc[1] += accContribution[1];\n            object.transform.acc[2] += accContribution[2];\n            object.originalPosition[2] += zContribution;\n        } else {\n            const objectPos = object.transform.absolutePosition();\n            const dVector2D = [pos[0] - objectPos[0], pos[1] - objectPos[1]];\n            const r = Util.dist([0,0], dVector2D);\n            if (!(r > this.gravityWellSize * 7 / 8 || r < this.radius * 2)){\n                const unitVector = Util.scale(dVector2D, 1/r);\n                const accContribution= [\n                    unitVector[0] * this.gravityConstant / (r * r),\n                    unitVector[1] * this.gravityConstant / (r * r)\n                ];\n                object.transform.acc[0] += accContribution[0];\n                object.transform.acc[1] += accContribution[1];\n            }\n        }\n        \n    }\n\n    openGate(){\n        this.playSound(this.openGateSound);\n        for (let i = 0; i < this.alienSpawnAmount; i++) {\n            const angle = Math.random() * Math.PI * 2;\n            const velocity = [this.alienSpawnSpeed * Math.cos(angle), this.alienSpawnSpeed * Math.sin(angle)];\n            new AlienShip(this.gameEngine, this.transform.pos, velocity, this.gameEngine.gameScript.ship.transform);\n        }\n        this.remove();\n\n    }\n\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","\nimport { LineSprite } from \"../../../game_engine/line_sprite\";\nexport class SingularitySprite extends LineSprite {\n    constructor(transform, spawningScale = 1) {\n        super(transform);\n        this.spawningScale = spawningScale;\n        this.throbbingScale = 1;\n        this.radius = 15;\n        this.spawned = false;\n    }\n\n    draw(ctx) {\n        if(!this.visible) return;\n        let spawningScale = this.spawningScale;\n        if (this.spawned) {\n            spawningScale = this.throbbingScale;\n        }\n\n        ctx.strokeStyle = \"#F173BA\";\n\n        const r = 95;\n        const g = 45;\n        const b = 73;\n\n        ctx.save();\n        // ctx.translate(pos[0], pos[1]);\n\n        // ctx.strokeStyle = \"#4286f4\";\n        // ctx.lineWidth = 4;\n        const blurFactor = 0.5;\n\n        ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n        ctx.lineWidth = 7.5;\n        this.drawSingularity(ctx, this.radius * spawningScale);\n        ctx.lineWidth = 6;\n        this.drawSingularity(ctx, this.radius * spawningScale);\n        ctx.lineWidth = 4.5;\n        this.drawSingularity(ctx, this.radius * spawningScale);\n        ctx.lineWidth = 3;\n        this.drawSingularity(ctx, this.radius * spawningScale);\n        ctx.strokeStyle = 'rgb(255, 255, 255)';\n        ctx.lineWidth = 1.5;\n        this.drawSingularity(ctx, this.radius * spawningScale);\n        ctx.restore();\n    // ctx.lineWidth = 2;\n    // drawSingularity(ctx, this.radius * spawningScale);\n    }\n\n    drawSingularity(ctx, radius) {\n        ctx.beginPath();\n        const pos = this.transform.absolutePosition();\n        ctx.arc(pos[0], pos[1], radius, 0, 2 * Math.PI, true);\n        ctx.stroke();\n    }\n}","import { GameObject } from \"../../../game_engine/game_object\";\nimport { Sound } from \"../../../game_engine/sound\";\nimport { Util } from \"../../../game_engine/util\";\nimport { EnemySpawn } from \"../../particles/enemy_spawn\";\nimport { WeaverSprite } from \"./weaver_sprite\";\n\n\nexport class Weaver extends GameObject {\n    constructor(engine, pos, shipTransform) {\n        super(engine);\n        this.rotation_speed = 0.075;\n        this.transform.pos[0] = pos[0];\n        this.transform.pos[1] = pos[1];\n        this.speed = 3;\n        \n        this.points = 80;\n        this.radius = 5;\n        this.weaverCloseHitBox = 30;\n        this.shipTransform = shipTransform;\n\n        this.bulletDirectionInfluenced = false;\n        this.bumpDirectionInfluenced = false;\n        this.bulletInfluencers = [];\n        this.bumpInfluencers = [];\n        this.bumpAcceleration = 1.5;\n        this.bulletDodgeSpeed = 4;\n\n        this.spawnSound = new Sound(\"sounds/Enemy_spawn_green.wav\", 0.5);\n        this.playSound(this.spawnSound);\n        this.addLineSprite(new WeaverSprite(this.transform));\n        this.addChildGameObject(new EnemySpawn(this.gameEngine));\n        this.exists = false;\n    \n    }\n\n    exist() {\n    // leaving off subscriptions means that things will subscribe to it\n        this.addCollider(\"General\", this, this.radius);\n        this.addCollider(\"BulletDodge\", this, this.weaverCloseHitBox, [\"Bullet\"], [\"General\"]);\n        this.addCollider(\"Bump\", this, this.radius, [\"Grunt\", \"Weaver\"], [\"General\"]);\n        // now it will move\n        this.addPhysicsComponent();\n        this.exists = true;\n    }\n\n\n    onCollision(collider, type){\n        if (type === \"BulletDodge\") {\n            this.acceptBulletDirection(collider.gameObject.transform.pos);\n        }\n        if(type === \"Bump\" && collider.gameObject !== this) {\n            this.acceptBumpDirection(collider.gameObject.transform.pos);\n        }\n    }\n\n    acceptBumpDirection(source) {\n        this.bumpDirectionInfluenced = true;\n        const dy = this.transform.pos[1] - source[1];\n        const dx = this.transform.pos[0] - source[0];\n        const unitVector = Util.dir([dx, dy]);\n        this.bumpInfluencers.push(unitVector);\n    }\n\n    influenceDirection(influencers) {\n        let directionVector = [0, 0];\n\n        influencers.forEach((influencer) => {\n            const dx = directionVector[0] + influencer[0];\n            const dy = directionVector[1] + influencer[1];\n            const newVector = [dx, dy];\n            directionVector = Util.dir(newVector);\n        });\n        const influencedDirection = Math.atan2(directionVector[1], directionVector[0]);\n        return influencedDirection;\n    }\n\n    acceptBulletDirection(source) {\n        this.bulletDirectionInfluenced = true;\n        const dy = this.transform.pos[1] - source[1];\n        const dx = this.transform.pos[0] - source[0];\n        const unitVector = Util.dir([dx, dy]);\n        this.bulletInfluencers.push(unitVector);\n    // first \n    }\n\n    animate(timeDelta) {\n        const rotationSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n        this.transform.angle = (this.transform.angle + this.rotation_speed * rotationSpeedScale) % (Math.PI * 2);\n    }\n\n    update(timeDelta){\n        if(this.exists){\n            const bumpAcceleration = this.bumpAcceleration;\n\n            const velocityScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n\n            this.animate(timeDelta);\n\n            if(this.bulletDirectionInfluenced) {\n                const direction = this.influenceDirection(this.bulletInfluencers);\n                this.transform.pos[0] += this.bulletDodgeSpeed * Math.cos(direction) * velocityScale;\n                this.transform.pos[1] += this.bulletDodgeSpeed * Math.sin(direction) * velocityScale;\n            } else {\n                this.chase(timeDelta);\n            }\n            if (this.bumpDirectionInfluenced) {\n                const direction = this.influenceDirection(this.bumpInfluencers);\n                this.transform.acc[0] += bumpAcceleration * Math.cos(direction) / 100;\n                this.transform.acc[1] += bumpAcceleration * Math.sin(direction) / 100;\n            } \n  \n            this.bumpDirectionInfluenced = false;\n            this.bulletDirectionInfluenced = false;\n            this.bumpInfluencers = [];\n            this.bulletInfluencers = [];\n  \n            if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\n                this.wallGraze();\n            }\n        }\n    \n    }\n\n    wallGraze() {\n        this.gameEngine.gameScript.wallGraze(this.transform, this.radius);\n    }\n\n    chase(timeDelta) {\n        const speed = 2;\n        const shipPos = this.shipTransform.pos;\n        const dy = shipPos[1] - this.transform.pos[1];\n        const dx = shipPos[0] - this.transform.pos[0];\n\n        const velocityScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n        const direction = Math.atan2(dy, dx);\n\n        this.transform.pos[0] += speed * Math.cos(direction) * velocityScale;\n        this.transform.pos[1] += speed * Math.sin(direction) * velocityScale;\n    }\n\n}\n\nWeaver.BOX_SIZE = 10;\nWeaver.COLOR = \"#3cff0b\";\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","import { LineSprite } from \"../../../game_engine/line_sprite\";\n\nexport class WeaverSprite extends LineSprite {\n    constructor(transform, spawningScale = 1) {\n        super(transform);\n        this.spawningScale = spawningScale;\n    }\n\n    draw(ctx) {\n        if(!this.visible) return;\n        // drawing this guy is taking waaay too much time.\n        // I took out the blurr factor and it's way better.\n        // doesn't look as nice, but it's a starting point\n        const pos = this.transform.absolutePosition();\n        const angle = this.transform.absoluteAngle();\n        const spawningScale = this.spawningScale;\n        const shipLength = 10 * 2.2 * spawningScale;\n        const shipWidth = 10 * 2.2 * spawningScale;\n        const s = shipWidth / 2;\n\n        const r = 24;\n        const g = 255;\n        const b = 4;\n\n        ctx.save();\n        ctx.translate(pos[0], pos[1]);\n        ctx.rotate(angle);\n    \n        const blurFactor = 0.5;\n        ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n        // ctx.shadowBlur = 10 * blurFactor\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n        ctx.lineWidth = 7.5;\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n        this.drawWeaver(ctx, s);\n        ctx.lineWidth = 6;\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.6)\";\n        this.drawWeaver(ctx, s);\n        // ctx.lineWidth = 4.5;\n        // this.drawWeaver(ctx, s)\n        // ctx.lineWidth = 3;\n        // this.drawWeaver(ctx, s)\n        ctx.strokeStyle = 'rgb(255, 255, 255)';\n        ctx.lineWidth = 1.5;\n        this.drawWeaver(ctx, s);\n\n        ctx.restore();\n    }\n\n    drawWeaver(ctx, s) {\n\n        ctx.beginPath();\n        // ctx.strokeStyle = \"#3cff0b\";\n        ctx.lineWidth = 2;\n        ctx.moveTo(0, -s); //1\n        ctx.lineTo(s, 0); //2\n        ctx.lineTo(0, s); //3\n        ctx.lineTo(-s, 0); //4\n        ctx.lineTo(0, -s); //1\n        ctx.lineTo(-s / 2, -s / 2); //5\n        ctx.lineTo(s / 2, -s / 2); //6\n        ctx.lineTo(s / 2, s / 2); //7\n        ctx.lineTo(-s / 2, s / 2); //8\n        ctx.lineTo(-s / 2, -s / 2); //5\n        // ctx.closePath();\n        ctx.stroke();\n    }\n}","\nimport { GameObject } from \"../../../game_engine/game_object\";\nimport { GridPoint } from \"./grid_point\";\nimport { GridSprite } from \"./grid_sprite\";\nimport { Util } from \"../../../game_engine/util\";\nexport class Grid extends GameObject {\n    constructor(engine, gameScript, cameraTransform) {\n        super(engine);\n\n        this.transform.pos = [0,0];\n\n        this.arenaDimensions = [gameScript.DIM_X, gameScript.DIM_Y];\n        this.elasticity = 0.1; // force provided to pull particle back into place\n        this.dampening = 0.1; // force produced from velocity (allows things to eventuall fall to rest)\n\n        this.gridPoints = this.createGridPoints(cameraTransform);\n\n        this.addLineSprite(new GridSprite(this.transform, this.gridPoints, cameraTransform));\n        // this.addPhysicsComponent()\n        // this.addCollider(\"General\", this, this.radius)\n    }\n\n    Playerdies(location) {\n        this.gridPoints.forEach((row) => {\n            row.forEach((gridPoint) => {\n                this.deathPerterb(gridPoint, location);\n            });\n        });\n    }\n\n    Explosion(location) {\n        this.gridPoints.forEach((row) => {\n            row.forEach((gridPoint) => {\n                this.explosionPerterb(gridPoint, location);\n            });\n        });\n    }\n\n    explosionPerterb(gridPoint, location){\n        // pushes outward upon explosion. 1/r^2\n        const pushConstant = 1250 / 2;\n\n        const pos = location;\n        const objectPos = gridPoint.transform.absolutePosition();\n        const dy = pos[1] - objectPos[1];\n        const dx = pos[0] - objectPos[0];\n        const unitVector = Util.dir([dx, dy]);\n        let r = Math.sqrt(dy * dy + dx * dx);\n        if ( r < 15 ) r = 15; // I think I need a bit more dampening for this to work\n        gridPoint.transform.vel[0] += -unitVector[0] * pushConstant / (r * r * 2);\n        gridPoint.transform.vel[1] += -unitVector[1] * pushConstant / (r * r * 2);\n        gridPoint.transform.vel[2] += +pushConstant * 5 / (r * r);\n    }\n\n\n    deathPerterb(gridPoint, location){\n        // pulls inward upon death. 1/r^2\n        const pullConstant = 1250 * 5;\n\n        const pos = location;\n        const objectPos = gridPoint.transform.absolutePosition();\n        const dy = pos[1] - objectPos[1];\n        const dx = pos[0] - objectPos[0];\n        const unitVector = Util.dir([dx, dy]);\n        let r = Math.sqrt(dy * dy + dx * dx);\n        if ( r < 20 ) r = 20; // I think I need a bit more dampening for this to work\n        const velContribution = [\n            unitVector[0] * pullConstant / (r),\n            unitVector[1] * pullConstant / (r)\n        ];\n        // const velContribution = [\n        //     0,0, pullConstant * 50 / (r ** 2)\n        // ];\n        gridPoint.transform.vel[0] = velContribution[0];\n        gridPoint.transform.vel[1] = velContribution[1];\n        // gridPoint.transform.vel[2] = velContribution[2];\n    }\n\n    createGridPoints(cameraTransform){\n        const columnCount = 90; // 40\n        const rowCount = 45; // 24\n        const gridPoints = [];\n        let gridRow = [];\n        for (let yPosition = 0; yPosition <= this.arenaDimensions[1]; yPosition += this.arenaDimensions[1] / rowCount) {\n            for (let xPosition = 0; xPosition <= this.arenaDimensions[0]; xPosition += this.arenaDimensions[0] / columnCount) {\n                if(\n                    (xPosition === 0 && (yPosition === 0 || yPosition === this.arenaDimensions[1])) || \n                   (xPosition == this.arenaDimensions[0] && (yPosition === 0 || yPosition === this.arenaDimensions[1])) \n                ){\n                    continue;\n                }\n                const position = [xPosition, yPosition, 0];\n                gridRow.push(new GridPoint(this.gameEngine, position, cameraTransform));\n            }\n            \n            gridPoints.push(gridRow.slice());\n            gridRow = [];\n        }\n        return gridPoints;\n    }\n\n    update(deltaTime) {\n\n    }\n\n}","import {GameObject} from \"../../../game_engine/game_object\";\n\n\nexport class GridPoint extends GameObject {\n    constructor(engine, pos, cameraTransform) {\n        super(engine);\n        this.originalPosition = [];\n        this.originalPosition[0] = pos[0];\n        this.originalPosition[1] = pos[1];\n        this.originalPosition[2] = pos[2];\n        this.transform.pos = pos;\n        this.transform.cameraTransform = cameraTransform;\n        this.radius = 2;\n        this.elasticity = -0.0025; // force provided to pull particle back into place\n        this.dampening = -0.04; // force produced from velocity (allows things to eventuall fall to rest)\n\n        this.addPhysicsComponent();\n        this.addCollider(\"General\", this, this.radius);\n    }\n\n    // let's try moving their original position in the z direction \n    // depending on strength of gravity influence\n\n    // will need to reset z position to 0 after each update... not sure how yet\n    // ...maybe just set it to 0 after each update lolz\n\n    update(deltaTime) {\n        this.transform.acc[0] += this.transform.vel[0] * this.dampening + (this.transform.pos[0] - this.originalPosition[0]) * this.elasticity;\n        this.transform.acc[1] += this.transform.vel[1] * this.dampening + (this.transform.pos[1] - this.originalPosition[1]) * this.elasticity;\n        this.transform.acc[2] += this.transform.vel[2] * this.dampening + (this.transform.pos[2] - this.originalPosition[2]) * this.elasticity;\n\n        this.originalPosition[2] = 0;\n    }\n\n}\n","import { LineSprite } from \"../../../game_engine/line_sprite\";\nimport { Color } from \"../../../game_engine/color\";\n\nexport class GridSprite extends LineSprite {\n    constructor(transform, gridPoints, cameraTransform) {\n        super(transform);\n        this.gridPoints = gridPoints;\n        this.cameraTransform = cameraTransform;\n\n        this.color = new Color({\n            \"hsla\": [202, 100, 70, 0.2]\n        });\n    }\n\n    draw(ctx) {\n        ctx.save();\n        ctx.strokeStyle = this.color.evaluateColor();\n        ctx.lineWidth = 2;\n        this.drawRows(ctx);\n        this.drawColumns(ctx);\n        ctx.restore();\n    }\n\n    drawRows(ctx) {\n        const gridPoints = this.gridPoints;\n\n        for (let i = 1; i < gridPoints.length - 1; i++) {\n            ctx.beginPath();\n            const firstPosition = gridPoints[i][0].transform.absolutePosition();\n            ctx.moveTo(firstPosition[0], firstPosition[1]);\n            for (let j = 1; j < gridPoints[i].length; j++) {\n                const nextPosition = gridPoints[i][j].transform.absolutePosition();\n                ctx.lineTo(nextPosition[0], nextPosition[1]);\n            }\n\n            ctx.stroke();\n        }\n    }\n\n    drawColumns(ctx) {\n        const gridPoints = this.gridPoints;\n        ctx.beginPath();\n\n        for (let j = 1; j < gridPoints[1].length - 1; j++) {\n            ctx.beginPath();\n            for (let i = 0; i < gridPoints.length; i++) {\n                let nextPosition = [];\n                if( i === 0 || i === 0) {\n                    nextPosition = gridPoints[i][j - 1].transform.absolutePosition();\n                    ctx.moveTo(nextPosition[0], nextPosition[1]);\n                } else {\n                    if ( i === gridPoints.length - 1) {\n                        nextPosition = gridPoints[i][j - 1].transform.absolutePosition();\n                    } else {\n                        nextPosition = gridPoints[i][j].transform.absolutePosition();\n                    }\n                    ctx.lineTo(nextPosition[0], nextPosition[1]);\n                }\n\n            }\n            ctx.stroke();\n        }\n    }\n}","// direction of the particle is the direction of the velocity vector\n// the direction of the \n// the particle dies when the hue reaches 0 \n\n// random movement angle created\n// initial speed (scale)\n// vel = Util.vectorCartesian(angle, scale)\n//\n// \n\n// because the particle is drawn the correct way now, \n// from position out, the particle's center is located \n// far from the center of the particle\n\nimport {ParticleSprite} from \"./particle_sprite\";\nimport { Util } from \"../../../game_engine/util\";\nimport { GameObject } from \"../../../game_engine/game_object\";\n\n\n\nexport class Particle extends GameObject{\n    constructor(engine, pos, initialSpeed, color, wallHit) {\n        super(engine);\n        this.transform.pos[0] = pos[0];\n        this.transform.pos[1] = pos[1];\n        this.transform.pos[2] = pos[2];\n        this.transform.cameraTransform = engine.gameScript.ship.cameraTransform;\n        this.color = color;\n        this.movementAngle = this.createMovementAngle(wallHit); // [plane, out of plane]\n        this.transform.movementAngle = this.movementAngle;\n        this.transform.vel = Util.vector3Cartesian(this.movementAngle, initialSpeed);\n        this.radius = 3;\n        this.explosionDeceleration = -0.004; // in the direction the particle is moving\n        this.transform.acc = Util.vector3Cartesian(this.movementAngle, -this.explosionDeceleration);\n        this.addLineSprite(new ParticleSprite(this.transform, this.color));\n        this.addPhysicsComponent();\n        this.dampening = -0.045;\n        // this.addCollider(\"General\", this, this.radius)\n    }\n\n    createMovementAngle(wallHit) {\n        if (!wallHit){ \n            return [(Math.random() * Math.PI * 2), Math.random() * Math.PI * 2];\n        } else {\n            if (wallHit === \"BOTTOM\") {\n                // need to give second angle still\n                return [Math.random() * Math.PI + Math.PI, Math.random() * Math.PI * 2];\n            } else if (wallHit === \"RIGHT\") {\n                return [Math.random() * Math.PI + Math.PI / 2, Math.random() * Math.PI * 2];\n            } else if (wallHit === \"TOP\") {\n                return [Math.random() * Math.PI, Math.random() * Math.PI * 2];\n            } else if (wallHit === \"LEFT\") {\n                return [Math.random() * Math.PI + 3 * Math.PI / 2, Math.random() * Math.PI * 2];\n            }\n        }\n    }\n  \n\n    update(deltaTime){\n        // this.lineSprite.rectLength -= 0.01 * deltaTime;\n        this.lineSprite.color.a -= 0.0005 * deltaTime;\n        if (this.lineSprite.hue < 0.06 || this.lineSprite.rectLength < 0.25 || ((Math.abs(this.transform.vel[0]) + Math.abs(this.transform.vel[1]) + Math.abs(this.transform.vel[2])) < 0.15)) {\n            this.remove();\n        }\n        this.checkBounds();\n        // acc is influenced by singularities, then changed to usual acc\n        this.movementAngle = [Math.atan2(this.transform.vel[1], this.transform.vel[0]), Math.atan2(this.transform.vel[2], Math.sqrt(this.transform.vel[0] ** 2 + this.transform.vel[1] ** 2)/this.transform.vel[2])];\n        // this.transform.acc = Util.vector3Cartesian(this.movementAngle, -this.explosionDeceleration);\n        this.transform.acc[0] += this.transform.vel[0] * this.dampening\n        this.transform.acc[1] += this.transform.vel[1] * this.dampening\n        this.transform.acc[2] += this.transform.vel[2] * this.dampening\n    }\n\n    checkBounds() {\n        if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), -0.5)) {\n            this.remove();\n        }\n    }\n\n}","import { LineSprite } from \"../../../game_engine/line_sprite\";\nimport { Util } from \"../../../game_engine/util\";\n\nexport class ParticleSprite extends LineSprite {\n    constructor(transform, color) {\n        super(transform);\n        this.rectLength = 15;\n        this.rectWidth = 2;\n        this.color = color;\n        // test\n    }\n\n    drawTwoDimensionNoParallax(ctx) {\n        const pos = this.transform.absolutePosition();\n        const vel = this.transform.absoluteVelocity();\n        const l = this.rectLength;\n        const w = this.rectWidth;\n        const movementDirection = Math.atan2(vel[0], -vel[1]);\n\n        ctx.save();\n        ctx.translate(pos[0], pos[1]);\n        ctx.rotate(movementDirection - Math.PI);\n\n        ctx.beginPath();\n        ctx.strokeStyle = this.color.evaluateColor();\n        ctx.lineWidth = w;\n\n        ctx.moveTo(0, 0); //1\n        // ctx.lineTo(0, l * Math.cos(this.transform.movementAngle[1])); //2\n        ctx.beginPath();\n        const r = 1;\n        ctx.arc(0, 0, r, 0, 2 * Math.PI, true);\n        ctx.fill();\n        // \n        ctx.closePath();\n        // ctx.stroke();\n        ctx.restore();\n    }\n\n    draw(ctx) {\n        const pos = this.transform.absolutePosition();\n        const r = this.transform.absoluteLength(3);\n        const vel = this.transform.absoluteVelocity();\n        const l = this.rectLength;\n        const w = this.transform.absoluteLength(this.rectWidth);\n\n        const movementDirection = Math.atan2(vel[0], -vel[1]);\n\n        // calculate x, y, z of second point of line\n        // use same calc, then add to current pos to get second point\n        // const point2Position = Util.vector3Add(this.transform.pos, Util.vector3Cartesian(this.transform.movementAngle, l));\n\n        // const Xc = this.transform.cameraTransform.pos[0];\n        // const Yc = this.transform.cameraTransform.pos[1];\n        // const Zc = this.transform.cameraTransform.pos[2];\n        // const X1 = this.transform.pos[0];\n        // const Y1 = this.transform.pos[1];\n        // const Z1 = this.transform.pos[2];\n\n        // const X2 = point2Position[0];\n        // const Y2 = point2Position[1];\n        // const Z2 = point2Position[2];\n\n        // const Yp1 = Yc + (Y1-Yc)/(Z1-Zc) * (0 - Zc);\n        // const Xp1 = Xc + (X1-Xc)/(Z1-Zc) * (0 - Zc);\n\n        // const Yp2 = Yc + (Y2-Yc)/(Z2-Zc) * (0 - Zc);\n        // const Xp2 = Xc + (X2-Xc)/(Z2-Zc) * (0 - Zc);\n\n        \n\n        ctx.save();\n        ctx.translate(pos[0], pos[1]);\n        ctx.rotate(movementDirection - Math.PI);\n        ctx.strokeStyle  = this.color.evaluateColor();\n        ctx.fillStyle = this.color.evaluateColor();\n\n        // the length and width should be closer as the particle gets closer to the camera\n        \n        ctx.fillRect(0,0,r, r*3);\n        // ctx.beginPath();\n        // ctx.arc(0, 0, r, 0, 2 * Math.PI, true);\n        // ctx.fill();\n        // ctx.strokeStyle = this.color.evaluateColor();\n        // ctx.lineWidth = w;\n\n        // ctx.moveTo(Xp1, Yp1); //1\n        // ctx.lineTo(Xp2, Yp2); //2\n        // ctx.stroke();\n\n        ctx.restore();\n    }\n}\n","// direction of the particle is the direction of the velocity vector\n// the direction of the \n// the particle dies when the hue reaches 0 \n\n// random movement angle created\n// initial speed (scale)\n// vel = Util.vectorCartesian(angle, scale)\n//\n\nimport {Particle} from \"../Particle/particle\";\n\nexport class SingularityParticle extends Particle {\n    constructor(engine, pos, vel, color) {\n        super(engine, pos, 0, color);\n\n        this.transform.vel[0] = vel[0];\n        this.transform.vel[1] = vel[1];\n        this.transform.vel[2] = 0;\n\n        this.color = color;\n        this.addCollider(\"General\", this, this.radius);\n        this.checkBounds();\n    }\n\n    update(deltaTime) {\n    \n        this.lineSprite.rectLength -= 0.25;\n        this.lineSprite.color.a -= 0.01;\n        if (this.lineSprite.color.a < 0.06 || this.lineSprite.rectLength < 0.25) {\n            this.parentObject.currentParticleCount -= 1;\n            this.remove();\n        }\n        // acc is influenced by singularities, then changed to usual acc\n        this.movementAngle = Math.atan2(this.transform.vel[1], this.transform.vel[0]);\n        this.transform.acc = [0,0,0];\n        this.checkBounds();\n    }\n    checkBounds() {\n        if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), -0.5)) {\n            this.remove();\n        }\n    }\n\n}\n","\n\nimport {Particle} from \"./Particle/particle\";\nimport {GameObject} from \"../../game_engine/game_object\";\nimport {Sound} from \"../../game_engine/sound\";\nimport {Color} from \"../../game_engine/color\";\nexport class BulletWallExplosion extends GameObject{\n    constructor(engine, pos) {\n        super(engine);\n        this.transform.pos[0] = pos[0];\n        this.transform.pos[1] = pos[1];\n        const startingH = (this.gameEngine.gameScript.explosionColorWheel + 180 + Math.random() * 60) % 360;\n        const opacity = Math.random() * 0.35 + 0.6;\n        this.currentColor = new Color({\n            \"hsla\": [startingH, 100, 50, opacity]\n        });\n        this.particleNum = 20;\n        const bulletWallHit = new Sound(\"sounds/bullet_hitwall.wav\", 0.1);\n        this.wallHit = this.whichWall();\n        this.playSound(bulletWallHit);\n        this.createParticles();\n    }\n\n    whichWall() {\n        const pos = this.transform.pos;\n\n        const max = [this.gameEngine.gameScript.DIM_X, this.gameEngine.gameScript.DIM_Y];\n        if (pos[0] <= 0) {\n            return \"LEFT\";\n        } else if (pos[0] >= max[0]) {\n            return \"RIGHT\";\n        } else if (pos[1] <= 0) {\n            return \"TOP\";\n        } else if (pos[1] >= max[1]) {\n            return \"BOTTOM\";\n        }\n\n    }\n\n    createParticles(){\n        for (var i = 0; i < this.particleNum; i++) {\n            const colorVarienceDelta = 30;\n            const speed = 1 + Math.random() * 3;\n            const colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2;\n            const color = this.currentColor.dup();\n            color.a = Math.random() * 0.35 + 0.6;\n            color.h = (color.h + colorVarience) % 360;\n\n            const x = this.transform.absolutePosition()[0];\n            const y = this.transform.absolutePosition()[1];\n            const z = 0;\n      \n            this.addChildGameObject(new Particle(this.gameEngine, [x,y,z], speed, color, this.wallHit));\n        }\n    }\n\n    update() {\n    \n        if (this.childObjects.length === 0) {\n            this.remove();\n        }\n    }\n}\n","import { GameObject } from \"../../game_engine/game_object\";\n\nexport class EnemySpawn extends GameObject{\n    constructor(engine){\n        super(engine);\n        this.initialSpawningScale = 1.5;\n        this.lifeTime = 1000;\n        this.existTime = 0;\n        // this.gameEngine.queueSound(this.parentObject.spawnSound)\n    }\n\n    update(timeDelta) {\n        this.existTime += timeDelta;\n        this.parentObject.lineSprite.spawning = true;\n        if (this.existTime >= this.lifeTime){\n            this.parentObject.lineSprite.spawningScale = 1;\n            this.parentObject.exist();\n            this.parentObject.lineSprite.spawning = false;\n            this.remove();\n        }\n\n        const cycleSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n        const cycleSpeed = 0.1;\n    \n        if (this.parentObject.lineSprite.spawningScale < 0.7){\n            this.parentObject.lineSprite.spawningScale = this.initialSpawningScale;\n        } else {\n            this.parentObject.lineSprite.spawningScale -= cycleSpeed * cycleSpeedScale;\n        }\n    }\n}\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","import {Particle} from \"./Particle/particle\";\nimport {GameObject} from \"../../game_engine/game_object\";\nimport {Sound} from \"../../game_engine/sound\";\nimport {Color} from \"../../game_engine/color\";\n\nexport class ParticleExplosion extends GameObject{\n    constructor(engine, pos){\n        super(engine);\n        this.transform.pos[0] = pos[0];\n        this.transform.pos[1] = pos[1];\n        this.cameraTransform = engine.gameScript.ship.cameraTransform;\n        const startingH = (this.gameEngine.gameScript.explosionColorWheel + Math.random() * 60)% 360;\n        const opacity = Math.random() * 0.35 + 0.6;\n        this.currentColor = new Color({\n            \"hsla\": [startingH, 100, 50, opacity]\n        });\n        if (engine.graphicQuality === 1) {\n            // console.log(\"best\")\n            this.particleNum = 120; // was 80\n        } else if (engine.graphicQuality === 2){\n            // console.log(\"medium\")\n            this.particleNum = 40;\n        } else {\n            // console.log(\"potato\")\n            this.particleNum = 20;\n        }\n\n        const explosionSound = new Sound(\"sounds/Enemy_explode.wav\", 0.2);\n        this.playSound(explosionSound);\n        this.createExplosionParticles();\n        engine.gameScript.grid.Explosion(pos);\n    }\n\n    createExplosionParticles(){\n        for (var i = 0; i < this.particleNum; i++) {\n            const speed = Math.random() * 4 + 15;\n      \n            const colorVarienceDelta = 40;\n            const colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2;\n            const color = this.currentColor.dup();\n            color.a = Math.random() * 0.15 + 0.80;\n            color.h = (color.h + colorVarience) % 360;\n\n            const x = this.transform.absolutePosition()[0];\n            const y = this.transform.absolutePosition()[1];\n            const z = 0;\n            this.addChildGameObject(new Particle(this.gameEngine, [x,y,z], speed, color));\n        }\n    }\n\n    update(){\n        if (this.childObjects.length === 0){\n            this.remove();\n        }\n    }\n}\n","import { Particle } from \"./Particle/particle\";\nimport { GameObject } from \"../../game_engine/game_object\";\nimport { Sound } from \"../../game_engine/sound\";\nimport { Color } from \"../../game_engine/color\";\nexport class ShipExplosion extends GameObject {\n    constructor(engine, pos) {\n        super(engine);\n        this.transform.pos[0] = pos[0];\n        this.transform.pos[1] = pos[1];\n        const startingH = (this.gameEngine.gameScript.explosionColorWheel + Math.random() * 60) % 360;\n        const opacity = Math.random() * 0.35 + 0.6;\n        this.currentColor = new Color({\n            \"hsla\": [startingH, 100, 50, opacity]\n        });\n        this.particleNum = 400;\n        const explosionSound = new Sound(\"sounds/Enemy_explode.wav\", 0.2);\n        this.playSound(explosionSound);\n        this.createExplosionParticles();\n    }\n\n    // create explosion lines that pop out of here\n    // they dissipate over time\n    // they should depend on the object that's destroyed to\n    // that means I should have a death animation for each\n\n    createExplosionParticles() {\n        for (var i = 0; i < this.particleNum; i++) {\n            const speed = Math.random() * 10 + 4;\n\n            const colorVarienceDelta = 30;\n            const colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2;\n            const color = this.currentColor.dup();\n            // color.a = Math.random() * 0.35 + 0.6\n            // color.h = (color.h + colorVarience) % 360\n\n            this.addChildGameObject(new Particle(this.gameEngine, this.transform.absolutePosition(), speed, color));\n        }\n    }\n\n    update() {\n        if (this.childObjects.length === 0) {\n            this.remove();\n        }\n    }\n}\n","import { Particle } from \"./Particle/particle\";\nimport { GameObject } from \"../../game_engine/game_object\";\nimport { Sound } from \"../../game_engine/sound\";\nimport { Color } from \"../../game_engine/color\";\nexport class SingularityHitExplosion extends GameObject {\n    constructor(engine, pos) {\n        super(engine);\n        this.transform.pos[0] = pos[0];\n        this.transform.pos[1] = pos[1];\n        const startingH = (this.gameEngine.gameScript.explosionColorWheel + Math.random() * 60 + 180) % 360;\n        const opacity = Math.random() * 0.35 + 0.3;\n        this.currentColor = new Color({\n            \"hsla\": [startingH, 100, 50, opacity]\n        });\n        if (engine.graphicQuality === 1) {\n            // console.log(\"best\")\n            this.particleNum = 50;\n        } else if (engine.graphicQuality === 2) {\n            // console.log(\"medium\")\n            this.particleNum = 30;\n        } else {\n            // console.log(\"potato\")\n            this.particleNum = 15;\n        }\n        // find singularity hit sound\n        const explosionSound = new Sound(\"sounds/Enemy_explode.wav\", 0.2);\n        this.playSound(explosionSound);\n        this.createExplosionParticles();\n    }\n\n    createExplosionParticles() {\n        for (var i = 0; i < this.particleNum; i++) {\n            // adjust speed\n            const speed = Math.random() * 3 + 2.5;\n\n            const colorVarienceDelta = 30;\n            const colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2;\n            const color = this.currentColor.dup();\n            color.a = Math.random() * 0.35 + 0.6;\n            color.h = (color.h + colorVarience) % 360;\n\n            this.addChildGameObject(new Particle(this.gameEngine, this.transform.absolutePosition(), speed, color));\n        }\n    }\n\n    update() {\n        if (this.childObjects.length === 0) {\n            this.remove();\n        }\n    }\n}\n","import { GameObject } from \"../../game_engine/game_object\";\nimport { Util } from \"../../game_engine/util\";\nimport { SingularityParticle } from \"./Singularity_Particle/singularity_particle\";\nimport { Color } from \"../../game_engine/color\";\n\nexport class SingularityParticles extends GameObject {\n    constructor(engine, transform) {\n        super(engine);\n        this.transform = transform;\n        const startingH = Math.random() * 360;\n        const opacity = Math.random() * 0.35 + 0.6;\n        this.frequencyParticleCreation = 10;\n        this.particleCreationTime = 0;\n        this.currentColor = new Color({\n            \"hsla\": [startingH, 100, 50, opacity]\n        });\n\n        this.particleNum = 80;\n        this.currentParticleCount = 0;\n        // let explosionSound = new Sound(\"sounds/Enemy_explode.wav\", 0.2)\n        this.createSingularityParticles();\n    \n    }\n\n    createSingularityParticles() {\n    \n        for (var i = 0; i < this.particleNum; i++) {\n            this.addSingularityParticle();\n            this.currentParticleCount++;\n        }\n    }\n\n    addSingularityParticle(){\n        const L = 70;\n        const length = 0;\n        const baseSpeed = 3;\n\n        const distanceVarienceDelta = 15;\n        const colorVarienceDelta = 10;\n        const angleVarienceDelta = Math.PI / 4;\n        const speedVarienceDelta = 2;\n\n        const distanceVarience = distanceVarienceDelta * Math.random() - distanceVarienceDelta / 2;\n        const colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2;\n        const angleVarience = angleVarienceDelta * Math.random() - angleVarienceDelta / 2;\n        const speedVarience = speedVarienceDelta * Math.random() - speedVarienceDelta / 2;\n\n        const r = L + distanceVarience;\n        const theta = Math.random() * 2 * Math.PI;\n        const alpha = theta + Math.PI / 2 +  angleVarience;\n        const speed = baseSpeed + speedVarience;\n\n        const pos = [r * Math.cos(theta) + this.transform.pos[0], r * Math.sin(theta) + this.transform.pos[1]];\n        const vel = [speed * Math.cos(alpha) + this.transform.vel[0], speed * Math.sin(alpha) + this.transform.vel[1]];\n        const color = this.currentColor.dup();\n\n        color.a = Math.random() * 0.19 + 0.8;\n        color.h = (color.h + colorVarience) % 360;\n\n        this.addChildGameObject(new SingularityParticle(this.gameEngine, pos, vel, color));\n    }\n\n    changeCurrentColor(){\n        this.currentColor.h += 1 / 2;\n        this.currentColor.h = this.currentColor.h % 360;\n    }\n\n    update(timeDelta) {\n        this.particleCreationTime += timeDelta;\n        if (this.particleCreationTime > this.frequencyParticleCreation){\n            this.particleCreationTime = 0;\n            if (this.currentParticleCount < 60){\n                this.addSingularityParticle();\n            }\n        }\n        this.changeCurrentColor();\n    }\n}\n","import { GameObject } from \"../../game_engine/game_object\";\nimport { LineSprite } from \"../../game_engine/line_sprite\";\n\nexport class Star extends GameObject {\n    constructor(engine, pos = [0,0,0], cameraTransform) {\n        super(engine);\n        this.transform.pos[0] = pos[0];\n        this.transform.pos[1] = pos[1];\n        this.transform.pos[2] = pos[2];\n        this.transform.cameraTransform = cameraTransform;\n        this.addLineSprite(new StarSprite(this.transform));\n        // add random good colors\n    }\n}\n\nexport class StarSprite extends LineSprite {\n    constructor(transform) {\n        super(transform);\n        this.radius = Math.random() * 2 + 0.25; // 1 - 3\n    }\n    draw(ctx) {\n        const pos = this.transform.absolutePosition();\n        const radius = this.transform.absoluteLength(this.radius);\n        const r = 255;\n        const g = 255;\n        const b = 255;\n        ctx.save();\n        ctx.translate(pos[0], pos[1]);\n        ctx.strokeStyle = \"rgb(255, 255, 255)\";\n        ctx.fillStyle = \"rgb(255, 255, 255)\";\n        this.drawStar(ctx, radius, pos);\n        ctx.restore();\n    }\n    drawStar(ctx, radius, pos) {\n        const r = radius;\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.arc(pos[0], pos[1], r, 0, 2 * Math.PI, true);\n        ctx.fill();\n    }\n}","import { GameObject } from \"../../game_engine/game_object\";\nimport { Sound } from \"../../game_engine/sound\";\nimport { ShipSprite } from \"./ship_sprite\";\nimport { Bullet } from \"../Bullet/bullet\";\nimport { Transform } from \"../../game_engine/transform\";\n\nexport class Ship extends GameObject {\n    constructor(engine, pos, initialCameraZPos) { \n        super(engine);\n        this.transform.pos = pos;\n        this.transform.pos[2] = [0];\n        this.cameraTransform = new Transform();\n        this.cameraTransform.pos = [pos[0], pos[1], initialCameraZPos];\n        this.addPhysicsComponent();\n        this.addMousePosListener();\n        this.addLeftControlStickListener();\n        this.addRightControlStickListener();\n        this.addStartButtonListener();\n        this.radius = 10;\n        this.addCollider(\"General\", this, this.radius);\n        this.addCollider(\"ShipDeath\", this, this.radius, [\"BoxBox\", \"Singularity\", \"Weaver\", \"Grunt\", \"Arrow\", \"Pinwheel\", \"AlienShip\"], [\"General\"]);\n        this.addLineSprite(new ShipSprite(this.transform));\n        this.maxSpeed = 2.5; // 2.5\n        this.mousePos = [0,0];\n        this.fireAngle = 0;\n        this.bulletSound = new Sound(\"sounds/Fire_normal.wav\", 0.2);\n        this.upgradeBulletsSound = new Sound(\"sounds/Hi_Score_achieved.wav\");\n        this.bulletTimeCheck = 0;\n        this.bulletInterval = 120;\n        this.controlsDirection = [0,0];\n        this.powerLevel = 1;\n        this.bulletNumber = 0;\n        this.controlsPointing = true;\n        this.speed;\n        this.shipEngineAcceleration = 0.5; // 0.125\n        this.dontShoot = false;\n\n        this.keysPressed = [];\n        this.pauseKeyedUp = true;\n        this.zooming = true;\n\n        this.spawning = true;\n        this.spawningTime = 0;\n        this.flashingTime = 0;\n        this.flashTime = 1000 / 8;\n        this.flashing = true;\n        this.flashIntervalTime = 0;\n        this.flashInterval = 250 - 1000 / 8;\n        this.spawnTime = 2500;\n        this.lineSprite.flashHide = true;\n        this.controllerInUse = false;\n        this.gameEditorHasBeenOpened = false;\n    // 1/8 of a second flash every half second\n    }\n\n  \n    update(deltaTime){\n        if(this.gameEngine.gameEditorOpened) {\n            if(!this.gameEditorHasBeenOpened) {\n                const _width = this.gameEngine.gameScript.DIM_X;\n                const _height = this.gameEngine.gameScript.DIM_Y;\n                const _zoomScale = this.gameEngine.zoomScale;\n                const _yPosition = this.transform.pos[1];\n                const _xPosition = this.transform.pos[0];\n                console.log({_width, _height, _zoomScale, _xPosition, _yPosition});\n                this.gameEngine.ctx.translate(\n                    ((_xPosition*_zoomScale - _width/(2))) ,\n                    ((_yPosition*_zoomScale - _height/(2)))\n                );\n                this.gameEngine.zoomScale = 1;\n            }\n            this.gameEditorHasBeenOpened = true;\n            return;\n        } else {\n            this.gameEditorHasBeenOpened = false;\n        }\n        this.bulletTimeCheck += deltaTime;\n\n        // game state stuff that doesn't belong in the ship #gamestate\n        if (this.bulletTimeCheck >= this.bulletInterval && !this.spawning && this.controlsPointing && !this.dontShoot) {\n            this.bulletNumber += 1;\n            this.bulletTimeCheck = 0;\n            this.fireBullet();\n        } \n\n        if (this.spawning){\n\n            this.spawningTime += deltaTime;\n            if (this.flashing) {\n                this.flashingTime += deltaTime;\n                if (this.flashingTime > this.flashTime) {\n                    this.flashingTime = 0;\n                    this.flashing = false;\n                    this.lineSprite.flashHide = false;\n                } \n            } else {\n                this.flashIntervalTime += deltaTime;\n                if (this.flashIntervalTime > this.flashInterval) {\n                    this.flashIntervalTime = 0;\n                    this.flashing = true;\n                    this.lineSprite.flashHide = true;\n                } \n            }\n\n            if (this.spawningTime > this.spawnTime) {\n                this.spawning = false;\n                this.flashing = false;\n                this.lineSprite.flashHide = false;\n                this.spawningTime = 0;\n                this.flashIntervalTime = 0;\n                this.flashingTime = 0;\n            }\n      \n        }\n\n        // this.moveInControllerDirection(deltaTime)\n\n        if (this.isOutOfBounds()) {\n            this.wallGraze();\n        } else {\n            this.movementMechanics(deltaTime);\n      \n        }\n        // if ship is out of x bounds, maintain y speed, keep x at edge value\n\n        this.updateZoomScale();\n\n        // stuff that belongs in camera #camera\n        this.gameEngine.ctx.restore();\n        this.gameEngine.ctx.save();\n        const shipXPos = this.transform.pos[0];\n        const shipYPos = this.transform.pos[1];\n        const zoomScale = this.gameEngine.zoomScale;\n        const width = this.gameEngine.gameScript.DIM_X;\n        const height = this.gameEngine.gameScript.DIM_Y;\n\n        this.cameraTransform.pos[0] = shipXPos;\n        this.cameraTransform.pos[1] = shipYPos;\n        // this.cameraTransform.pos[2] = based on zoomScale\n\n        this.gameEngine.ctx.translate(\n            -shipXPos * zoomScale + width / 2,\n            -shipYPos * zoomScale + height / 2\n        );\n    }\n\n    upgradeBullets() {\n        this.powerLevel += 1;\n        this.playSound(this.upgradeBulletsSound);\n    }\n  \n    findSmallestDistanceToAWall(){\n        const pos = this.transform.pos;\n        const leftDistance = pos[0] - 0;\n        const rightDistance = this.gameEngine.gameScript.DIM_X - pos[0];\n        const upDistance = pos[1] - 0;\n        const downDistance = this.gameEngine.gameScript.DIM_Y - pos[1];\n        const distances = [leftDistance, rightDistance, upDistance, downDistance];\n        return Math.min.apply(null, distances); \n    }\n\n    updateZoomScale(){\n        const distanceToZoomChange = 100;\n        const smallestZoomScale = 0.75; // of the origional zoomscale\n        const smallest = this.findSmallestDistanceToAWall();\n        if (smallest < distanceToZoomChange) {\n            this.gameEngine.zoomScale = this.gameEngine.defaultZoomScale * (smallest / distanceToZoomChange * (1 - smallestZoomScale) + smallestZoomScale);\n        } else {\n            this.gameEngine.zoomScale = this.gameEngine.defaultZoomScale;\n        }\n\n        // this should also update the camera's Z position\n    }\n\n    // \n    calcControlsDirection(){\n    \n        this.controlsDirection = [0,0];\n        this.keysPressed.forEach((key) => {\n            this.controlsDirection[0] += Ship.MOVES[key][0];\n            this.controlsDirection[1] += Ship.MOVES[key][1];\n        });\n    }\n\n    movementMechanics(deltaTime) {\n    // get dV\n    //    mV => max speed in the direction of the controller\n    //    Vo => current velocity\n    //    dV~ =  mV - Vo\n    // if dv~ > 0.2 (or something)\n    //    a = ma~ \n        if (!this.controllerInUse) {\n            this.calcControlsDirection();\n        }\n\n        const movementAngle = Math.atan2(this.controlsDirection[1], this.controlsDirection[0]);\n        const Vo = this.transform.absoluteVelocity();\n        let mV = [];\n\n        if(this.controlsDirection[0] == 0 && this.controlsDirection[1] == 0){\n            mV = [0, 0];\n        } else {\n            mV = [this.maxSpeed * Math.cos(movementAngle), this.maxSpeed * Math.sin(movementAngle)];\n            this.transform.angle = movementAngle;\n        }\n\n        const dV = [mV[0] - Vo[0], mV[1] - Vo[1]];\n        const alpha = Math.atan2(dV[1], dV[0]);\n\n        this.transform.acc[0] += this.shipEngineAcceleration * Math.cos(alpha);\n        this.transform.acc[1] += this.shipEngineAcceleration * Math.sin(alpha);\n    }\n\n    isOutOfBounds(){\n        return this.gameEngine.gameScript.isOutOfBounds(this.transform.pos, this.radius);\n    }\n\n    updateMousePos(mousePos){\n        this.setFireAngle(mousePos);\n    }\n\n    updateRightControlStickInput(vector) {\n        if (Math.abs(vector[0]) + Math.abs(vector[1]) > 0.10) {\n            this.dontShoot = false;\n            this.fireAngle = Math.atan2(vector[1], vector[0]);\n        } else {\n            this.dontShoot = true;\n        }\n    }\n\n    updateLeftControlStickInput(key, down = true) {\n        if(typeof key === \"string\"){\n            // accelerates to V = [0,0] when not pressed\n            if (down) {\n                if (!this.keysPressed.includes(key)) {\n                    this.keysPressed.push(key);\n                }\n\n                // this.controlsDirection[0] += unitVector[0]\n                // this.controlsDirection[1] += unitVector[1]\n            } else {\n                if (this.keysPressed.includes(key)) {\n                    const index = this.keysPressed.indexOf(key);\n                    if (index !== -1) this.keysPressed.splice(this.keysPressed.indexOf(key), 1);\n                }\n\n                // this.controlsDirection[0] -= unitVector[0]\n                // this.controlsDirection[1] -= initVector[1]\n            }\n        } else {\n            this.controllerInUse = true;\n            if (Math.abs(key[0]) + Math.abs(key[1]) > 0.10) {\n                this.controlsDirection = key;\n            } else {\n                this.controlsDirection = [0,0];\n            }\n        }\n    } \n    // Refactor into game engine and game script\n    updateStartButtonListener(key, down){\n        if (typeof key === \"string\"){\n            if(down){\n                if(this.pauseKeyedUp){\n                    this.pauseKeyedUp = false;\n                    if (this.gameEngine.paused && !this.gameEngine.muted) {\n                        this.gameEngine.gameScript.theme.play();\n                    }\n                    this.gameEngine.togglePause();\n                }\n            } else {\n                this.pauseKeyedUp = true;\n            }\n        } else if(key[0]) {\n            if (this.pauseKeyedUp){\n                this.pauseKeyedUp = false;\n                if (this.gameEngine.paused && !this.gameEngine.muted) {\n                    this.gameEngine.gameScript.theme.play();\n                }\n                this.gameEngine.togglePause();\n            }\n        } else {\n            this.pauseKeyedUp = true;\n        }\n    }\n\n    wallGraze() {\n        this.gameEngine.gameScript.wallGraze(this.transform, this.radius * 2);\n    }\n\n    onCollision(collider, type) {\n        if (type === \"ShipDeath\") {\n  \n            this.gameEngine.gameScript.death();\n            this.deathflash();\n        }\n    }\n\n    deathflash() {\n        this.spawning = true;\n        this.flashing = true;\n    }\n\n    setFireAngle(mousePos) {\n    \n        if (mousePos === undefined){\n            mousePos = this.mousePos;\n        } else {\n            this.mousePos = mousePos;\n        }\n        const shipXPos = this.transform.pos[0];\n        const shipYPos = this.transform.pos[1];\n        const zoomScale = this.gameEngine.zoomScale;\n        const width = this.gameEngine.gameScript.DIM_X;\n        const height = this.gameEngine.gameScript.DIM_Y;\n\n        const mouseX = mousePos[0] / zoomScale + shipXPos  - width / (2 * zoomScale);\n        const mouseY = mousePos[1] / zoomScale + shipYPos  - height / (2 * zoomScale);\n        // SCALE NUMBER\n        const dy =  mouseY - this.transform.pos[1];\n        const dx =  mouseX - this.transform.pos[0];\n        this.fireAngle =  Math.atan2(dy, dx);\n    }\n\n    fireBullet() {\n    \n        this.gameEngine.queueSound(this.bulletSound);\n        const shipvx = this.transform.vel[0];\n        const shipvy = this.transform.vel[1];\n\n        const relBulletVelX1 = Bullet.SPEED * Math.cos(this.fireAngle);\n        const relBulletVelY1 = Bullet.SPEED * Math.sin(this.fireAngle);\n\n        const bulletVel1 = [shipvx + relBulletVelX1, shipvy + relBulletVelY1];\n        this.addChildGameObject(new Bullet(this.gameEngine, this.transform.pos, bulletVel1, this.bulletNumber));\n\n        if (this.powerLevel >= 2) {\n            const relBulletVelX2 = (Bullet.SPEED - 0.5) * Math.cos(this.fireAngle + Math.PI / 32);\n            const relBulletVelY2 = (Bullet.SPEED - 0.5) * Math.sin(this.fireAngle + Math.PI / 32);\n            const relBulletVelX3 = (Bullet.SPEED - 0.5) * Math.cos(this.fireAngle - Math.PI / 32);\n            const relBulletVelY3 = (Bullet.SPEED - 0.5) * Math.sin(this.fireAngle - Math.PI / 32);\n\n            const bulletVel2 = [shipvx + relBulletVelX2, shipvy + relBulletVelY2];\n            const bulletVel3 = [shipvx + relBulletVelX3, shipvy + relBulletVelY3];\n            // doesn't support parent transformations... yet\n            this.addChildGameObject(new Bullet(this.gameEngine, this.transform.pos, bulletVel2, this.bulletNumber, 'left', this.powerLevel));\n            this.addChildGameObject(new Bullet(this.gameEngine, this.transform.pos, bulletVel3, this.bulletNumber,  'right', this.powerLevel));\n        }\n    }\n\n\n    // implement threshold so it's not too sensitive\n\n  \n\n    relocate() {\n    // this.GameScript.die();\n    // this.transform.pos = this.game.randomPosition();\n    // this.vel = [0, 0];\n    // this.acc = [0, 0];\n    }\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n\nShip.MOVES = {\n    s: [0, 1],\n    a: [-1, 0],\n    w: [0, -1],\n    d: [1, 0],\n};\n\n","import { LineSprite } from \"../../game_engine/line_sprite\";\n\nexport class ShipSprite extends LineSprite {\n    constructor(transform, spawningScale = 1) {\n        super(transform);\n        this.spawningScale = spawningScale;\n        this.flashHide = false;\n    }\n\n    draw(ctx) {\n        if (!this.flashHide) {\n            const pos = this.transform.absolutePosition();\n            const shipWidth = 10;\n            const vel = this.transform.absoluteVelocity();\n            // let movementDirection = Math.atan2(vel[0], -vel[1])\n            ctx.save();\n            ctx.beginPath();\n            ctx.translate(pos[0], pos[1]);\n            ctx.rotate(this.transform.angle + Math.PI / 4);\n            ctx.translate(-shipWidth / 2, shipWidth / 2);\n\n            ctx.strokeStyle = \"#ffffff\";\n            const r = 255;\n            const g = 255;\n            const b = 255;\n\n            const blurFactor = 0.5;\n            ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n            ctx.shadowBlur = 10 * blurFactor * blurFactor;\n            ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.1)\";\n            ctx.lineWidth = 7.5 * blurFactor * blurFactor;\n            ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.1)\";\n            this.drawShip(ctx, shipWidth);\n            ctx.lineWidth = 6 * blurFactor;\n            ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.1)\";\n            this.drawShip(ctx, shipWidth);\n            ctx.lineWidth = 4.5;\n            this.drawShip(ctx, shipWidth);\n            ctx.lineWidth = 3;\n            this.drawShip(ctx, shipWidth);\n            ctx.strokeStyle = 'rgb(255, 255, 255)';\n            ctx.lineWidth = 1.5;\n            this.drawShip(ctx, shipWidth);\n\n            ctx.restore();\n        }\n    \n    }\n\n    drawShip(ctx, shipWidth) {\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(0, -shipWidth);\n        ctx.lineTo(2 / 3 * shipWidth, -(1 + 1 / 6) * shipWidth); //1\n        ctx.lineTo(1 / 3 * shipWidth, -5 / 6 * shipWidth); // 2\n        ctx.lineTo(1 / 3 * shipWidth, -1 / 3 * shipWidth); // 2.5\n        ctx.lineTo(5 / 6 * shipWidth, -1 / 3 * shipWidth); // 3\n        ctx.lineTo((1 + 1 / 6) * shipWidth, -2 / 3 * shipWidth); // 4\n        ctx.lineTo(shipWidth, 0); // 5\n        ctx.closePath();\n        ctx.stroke();\n    }\n}","import { Sound } from \"./game_engine/sound\";\nimport { Ship } from \"./game_objects/ship/ship\";\nimport { Walls } from \"./game_objects/Walls/walls\";\nimport { Overlay } from \"./game_objects/Overlay/overlay\";\nimport { Grid } from \"./game_objects/particles/Grid/grid\";\nimport { BoxBox } from \"./game_objects/enemies/BoxBox/boxbox\";\nimport { Pinwheel } from \"./game_objects/enemies/Pinwheel/pinwheel\";\nimport { Arrow } from \"./game_objects/enemies/Arrow/arrow\";\nimport { Grunt } from \"./game_objects/enemies/Grunt/grunt\";\nimport { Weaver } from \"./game_objects/enemies/Weaver/weaver\";\nimport { Singularity } from \"./game_objects/enemies/Singularity/singularity\";\nimport { AlienShip } from \"./game_objects/enemies/Singularity/alien_ship\";\nimport { ParticleExplosion } from \"./game_objects/particles/particle_explosion\";\nimport { ShipExplosion } from \"./game_objects/particles/ship_explosion\";\nimport {Star} from \"./game_objects/particles/star\";\n\nimport { Scene } from \"./game_engine/Levels/DesignElements/Scene\";\nimport { Event } from \"./game_engine/Levels/DesignElements/Event\";\nimport { Time } from \"./game_engine/Levels/DesignElements/Time\";\nimport { LoopBeginning, LoopEnd } from \"./game_engine/Levels/DesignElements/Loop\";\nimport {Operation} from \"./game_engine/Levels/DesignElements/Operation\";\n\nexport class GameScript {\n    constructor(engine) {\n        this.serializedGame = \"\";\n        this.theme = new Sound(\"sounds/Geometry_OST.mp3\", 1);\n        this.gameOverSound = new Sound(\"sounds/Game_over.wav\");\n        this.gameStartSound = new Sound(\"sounds/Game_start.wav\");\n        this.shipDeathSound = new Sound(\"sounds/Ship_explode.wav\");\n        this.DIM_X = 1000;\n        this.DIM_Y = 600;\n        this.BG_COLOR = \"#000000\";\n        this.gameTime = 0;\n        this.score = 0;\n        this.engine = engine;\n        this.arrowAdded = false;\n        this.startPosition = [500, 300, 0];\n        this.initialCameraZPos = -1000;\n        this.ship = this.createShip();\n        this.createStars();\n        this.walls = this.createWalls();\n        this.grid = this.createGrid(this.ship.cameraTransform);\n        this.overlay = this.createOverlay();\n        this.enemyCreatorList = this.createEnemyCreatorList();\n        this.engine.addxButtonListener(this);\n        this.aliveEnemies = [];\n        this.sequenceTypes = this.addSequenceTypes();\n        this.spawnStateMachine = this.createSpawnStateMachine();\n        this.deathPausedTime = 0;\n        this.deathPaused = true;\n        this.deathPauseTime = 2500;\n        // this.deathSound = new Audio(\"sounds/Enemy_explode.wav\")\n        // this.deathSound.volume = 0.5;\n\n        this.intervalTiming = 1;\n        this.intervalTime = 0;\n        this.hugeSequenceTime = 0;\n        this.sequenceCount = 0; // START GAME HERE\n        this.lives = 3;\n        this.soundsToPlay = {};\n        this.scoreMultiplier = 1;\n\n        this.spawnthing = false;\n        this.explosionColorWheel = 0;\n\n        this.playFromRootScene = false;\n    }\n\n    nextElement() {\n        this.rootScene.currentElementIndex = 0;\n    }\n\n    startGame(serializedGame) {\n        this.serializedGame = serializedGame;\n        const game = JSON.parse(serializedGame);\n        this.rootScene = new Scene(this, \"Root\");\n        this.rootScene.gameElements = this.loadGameElements(game.gameElements, this.rootScene);\n        this.playFromRootScene = true;\n        this.intervalTime = 0;\n        this.ship.transform.pos = [this.startPosition[0], this.startPosition[1], this.startPosition[2]];\n    }\n\n    // will need to duck type what happens when the scene is done and the game is over\n\n    loadGameElements(gameElements, parentScene) {\n        return gameElements.map((element) => {\n            if(element.type === \"Scene\") {\n                const newScene = new Scene(parentScene, element.name);\n                newScene.gameElements = this.loadGameElements(element.gameElements, newScene) || [];\n                return newScene;\n            } else if(element.type === \"Event\") {\n                return new Event(element.spawns, parentScene, element.isShipRelative ,this.engine);\n            } else if(element.type === \"Time\") {\n                return new Time(parentScene, element.waitTime, parentScene);\n            } else if(element.type === \"LoopBeginning\") {\n                return new LoopBeginning(parentScene);\n            } else if (element.type === \"LoopEnd\") {\n                return new LoopEnd({loopIdx: element.loopIdx || 0, repeatTimes: element.repeatTimes}, parentScene);\n            } else if (element.type === \"Operation\") {\n                return new Operation(element.operand, parentScene, this.engine, this);\n            }\n        });\n    }\n\n    createStars() {\n        const runoffFactor = 1.5;\n        for(let i = 0; i < 900; i++) {\n            const X = (runoffFactor * Math.random() - runoffFactor/2) * this.DIM_X; // based on zoom scale and eventually camera position\n            const Y = (runoffFactor * Math.random() - runoffFactor/2) * this.DIM_Y;\n            // const Z = -this.initialCameraZPos * 0.25 + -this.initialCameraZPos * 2 * Math.random();\n            const Z = -this.initialCameraZPos * (0.5 + 2* Math.random());\n            new Star(this.engine, [X, Y, Z], this.ship.cameraTransform);\n        }\n    }\n\n    updatexButtonListener(xButton) {\n        if (xButton[0]) {\n            if (this.engine.paused) {\n                var modal = document.getElementById(\"endModal\");\n\n                modal.style.display = \"none\";\n                this.engine.paused = false;\n                if (!this.engine.muted) {\n                    this.engine.gameScript.theme.play();\n                }\n            }\n        }\n    }\n\n    update(deltaTime) {\n        if (this.deathPaused) {\n            this.deathPausedTime += deltaTime;\n            if (this.deathPausedTime > this.deathPauseTime) {\n                this.deathPausedTime = 0;\n                this.deathPaused = false;\n            } else {\n                deltaTime = 0;\n            }\n        } \n\n        if(this.playFromRootScene) {\n            this.rootScene.update(deltaTime);\n        } else {\n            this.spawnSequence(deltaTime);\n        }\n        this.changeExplosionColor();\n    }\n\n    changeExplosionColor() {\n        this.explosionColorWheel += 1 / 2;\n        this.explosionColorWheel = this.explosionColorWheel % 360;\n    }\n\n    tallyScore(gameObject) {\n        this.score += gameObject.points * this.scoreMultiplier;\n        if (this.score) {\n        }\n    }\n\n    resetGame() {\n        this.deathPaused = true;\n        this.desplayEndScore = this.score;\n        this.score = 0;\n        this.lives = 3;\n        this.ship.transform.pos = this.startPosition;\n        this.sequenceCount = 0;\n        this.deathPauseTime = 2500;\n        this.ship.powerLevel = 1;\n        this.intervalTiming = 1;\n        this.intervalTime = 0;\n        this.hugeSequenceTime = 0;\n        this.lives = 3;\n        this.scoreMultiplier = 1;\n        this.spawnthing = false;\n        this.engine.paused = true;\n        var modal = document.getElementById(\"endModal\");\n        modal.style.display = \"block\";\n        var scoreDisplay = document.getElementById(\"score\");\n        scoreDisplay.innerHTML = `score: ${this.desplayEndScore}`;\n\n        // Get the button that opens the modal\n        // var btn = document.getElementById(\"myBtn\");\n\n        // Get the <span> element that closes the modal\n        var xclose = document.getElementsByClassName(\"endClose\")[0];\n\n        // When the user clicks on <span> (x), close the modal\n        xclose.onclick = (e) => {\n            e.stopPropagation();\n            modal.style.display = \"none\";\n            this.engine.paused = false;\n            window.removeEventListener(\"click\", closeModalWithClick, false);\n            if (!this.engine.muted) {\n                this.engine.gameScript.theme.play();\n                this.engine.gameScript.gameStartSound.play();\n            }\n        };\n\n        const closeModalWithClick = (e) => {\n            if (e.target == modal) {\n                this.engine.paused = false;\n                if (!this.engine.muted) {\n                    this.engine.gameScript.theme.play();\n                    this.engine.gameScript.gameStartSound.play();\n                }\n                modal.style.display = \"none\";\n                window.removeEventListener(\"click\", closeModalWithClick, false);\n            }\n        };\n\n        // When the user clicks anywhere outside of the modal, close it\n        window.addEventListener(\"click\", closeModalWithClick, false);\n    }\n\n    death() {\n        this.lives -= 1;\n        this.deathPaused = true;\n        this.explodeEverything();\n        this.deathPauseTime = 4000;\n        if (!this.engine.muted) {\n            this.engine.gameScript.shipDeathSound.play();\n        }\n        this.grid.Playerdies(this.ship.transform.absolutePosition());\n        if (this.lives === 0) {\n            try {\n                this.theme.pause();\n            } catch (err) {}\n            if (!this.engine.muted) {\n                this.engine.gameScript.gameOverSound.play();\n            }\n            // this.playSound(this.gameOverSound)\n            window.setTimeout(this.resetGame.bind(this), 2000);\n        }\n    }\n\n    gameOver() {\n    // end the game here\n    }\n\n    explodeEverything() {\n        const removeList = [];\n        const typesToRemove = [\n            \"Grunt\",\n            \"Pinwheel\",\n            \"BoxBox\",\n            \"Arrow\",\n            \"Singularity\",\n            \"Weaver\",\n            \"AlienShip\",\n        ];\n        this.engine.gameObjects.forEach((object) => {\n            if (object.constructor.name === \"Ship\") {\n                const objectTransform = object.transform;\n                const pos = objectTransform.absolutePosition();\n                new ShipExplosion(this.engine, pos, [0, 0]);\n            } else if (object.constructor.name === \"Bullet\") {\n                removeList.push(object);\n            } else if (typesToRemove.includes(object.constructor.name)) {\n                const objectTransform = object.transform;\n                const pos = objectTransform.absolutePosition();\n                const vel = objectTransform.absoluteVelocity();\n                new ParticleExplosion(this.engine, pos);\n                removeList.push(object);\n            }\n        });\n        removeList.forEach((removeThis) => {\n            removeThis.remove();\n        });\n    }\n\n    // levelDesigner() {\n    //     const modal = document.getElementById(\"levelDesignerModal\");\n    // }\n\n    onPause() {\n        try {\n            this.theme.pause();\n        } catch (error) {}\n\n        var modal = document.getElementById(\"pauseModal\");\n        modal.style.display = \"block\";\n    }\n\n    onUnPause() {\n        try {\n            this.theme.unPause();\n        } catch (error) {}\n\n        var modal = document.getElementById(\"pauseModal\");\n        modal.style.display = \"none\";\n    }\n\n    randomArrowDirection() {\n        const angles = [0, Math.PI / 2, Math.PI, (Math.PI * 3) / 2];\n        return angles[Math.floor(Math.random() * angles.length) % angles.length];\n    }\n\n    createEnemyCreatorList() {\n        const engine = this.engine;\n        return {\n            BoxBox: (pos, angle) => new BoxBox(engine, pos),\n            Pinwheel: (pos, angle) => new Pinwheel(engine, pos),\n            Arrow: (pos, angle) => new Arrow(engine, pos, angle),\n            Grunt: (pos, angle) => new Grunt(engine, pos, this.ship.transform),\n            Weaver: (pos, angle) => new Weaver(engine, pos, this.ship.transform),\n            Singularity: (pos, angle) => new Singularity(engine, pos),\n            AlienShip: (pos, angle) =>\n                new AlienShip(engine, pos, [0, 0], this.ship.transform),\n        };\n    }\n\n    randomSpawnEnemy(enemy) {\n        const pos = this.randomPosition();\n        const enemyCreators = Object.values(this.enemyCreatorList);\n        enemyCreators[\n            Math.floor(Math.random() * enemyCreators.length) % enemyCreators.length\n        ](pos);\n    // this.enemyCreatorList[\"BoxBox\"](pos)\n    }\n\n    addSequenceTypes() {\n        return {\n            BoxBoxesEverywhere: () => {\n                const randomPositions = [];\n                for (let i = 0; i < 50; i++) {\n                    const pos = this.randomPosition(10);\n                    randomPositions.push(pos);\n                }\n                randomPositions.forEach((pos) => {\n                    this.enemyCreatorList[\"BoxBox\"](pos);\n                });\n            },\n            Singularity: () => {\n                this.enemyCreatorList[\"Singularity\"]([700, 300]);\n            },\n            EasyGroups: () => {\n                const randomPositions = [];\n                for (let i = 0; i < 5; i++) {\n                    const pos = this.randomPosition();\n                    randomPositions.push(pos);\n                }\n                randomPositions.forEach((pos) => {\n                    const possibleSpawns = [\"BoxBox\", \"Pinwheel\"]; //, \"Singularity\"]\n                    this.enemyCreatorList[\n                        possibleSpawns[\n                            Math.floor(Math.random() * possibleSpawns.length) %\n                possibleSpawns.length\n                        ]\n                    ](pos);\n                });\n            },\n            EasyGroupsArrows: () => {\n                const randomPositions = [];\n                for (let i = 0; i < 5; i++) {\n                    const pos = this.randomPosition();\n                    randomPositions.push(pos);\n                }\n                randomPositions.forEach((pos) => {\n                    const possibleSpawns = [\"BoxBox\", \"Pinwheel\", \"Arrow\", \"Singularity\"];\n                    this.enemyCreatorList[\n                        possibleSpawns[\n                            Math.floor(Math.random() * possibleSpawns.length) %\n                possibleSpawns.length\n                        ]\n                    ](pos);\n                });\n            },\n            ArrowsAttack: () => {\n                const somePositions = [\n                    [200, 300],\n                    [1000, 300],\n                    [600, 100],\n                ];\n                const pos =\n                    somePositions[\n                        Math.floor(Math.random() * somePositions.length) %\n                        somePositions.length\n                    ];\n                for (let i = 0; i < 5; i++) {\n                    pos[1] += i * 80;\n                    this.enemyCreatorList[\"Arrow\"](pos);\n                }\n            },\n            GruntGroups: () => {\n                const randomPos = this.randomPosition(50);\n                for (let i = 0; i < 3; i++) {\n                    for (let j = 0; j < 3; j++) {\n                        this.enemyCreatorList[\"Grunt\"]([\n                            i * 40 + randomPos[0],\n                            j * 40 + randomPos[1],\n                        ]);\n                    }\n                }\n            },\n            GreenGroups: () => {\n                const randomPos = this.randomPosition(50);\n                for (let i = 0; i < 3; i++) {\n                    for (let j = 0; j < 3; j++) {\n                        this.enemyCreatorList[\"Weaver\"]([\n                            i * 40 + randomPos[0],\n                            j * 40 + randomPos[1] - 50,\n                        ]);\n                    }\n                }\n            },\n        };\n    }\n\n    createSpawnStateMachine() {\n    // let events = this.sequenceTypes\n    // let stateIndex = {i: 0}\n    // // these are the events\n    // // times will be hard coded for each state in the queue\n    // let spawnQueue = []\n    // let singularityState = new StateMachine(this.engine, {stateIndex, event: events.Singularity})\n    // let easyGroupsState = new StateMachine(this.engine, undefined)\n    }\n\n    randomPosition(radius) {\n        if(!radius) {\n            radius = 40;\n        }\n        return [\n            (this.DIM_X - radius * 4) * Math.random() + radius * 4,\n            (this.DIM_Y - radius * 4) * Math.random() + radius * 4,\n            // 1000,600\n        ];\n    }\n\n    spawnSequence(delta) {\n        this.intervalTime += delta;\n\n        this.gameTime += delta;\n\n        if (this.sequenceCount === 1) {\n            this.enemyCreatorList[\"Singularity\"]([700, 300]);\n            this.sequenceCount += 1;\n        }\n\n        // wait time              //parentIndex   // repeat count\n        if (\n            this.intervalTime > 2500 * this.intervalTiming &&\n        this.sequenceCount < 5\n        ) {\n            this.intervalTime = 0;\n            this.sequenceTypes[\"EasyGroups\"](); // event\n            // this.randomSpawnEnemy();\n            this.sequenceCount += 1;\n        } else if (this.sequenceCount === 5 && this.intervalTime > 5000) {\n            this.sequenceCount += 1;\n        } else if (\n            this.intervalTime > 2500 * this.intervalTiming &&\n        this.sequenceCount > 5 &&\n        this.sequenceCount < 10\n        ) {\n            this.sequenceCount += 1;\n            this.intervalTime = 0;\n            this.sequenceTypes[\"EasyGroupsArrows\"]();\n        } else if (this.sequenceCount === 10 && this.intervalTime > 5000) {\n            this.sequenceCount += 1;\n        } else if (\n            this.intervalTime > 1500 * this.intervalTiming &&\n        this.sequenceCount > 10 &&\n        this.sequenceCount < 15\n        ) {\n            this.sequenceCount += 1;\n            this.intervalTime = 0;\n            this.sequenceTypes[\"GruntGroups\"]();\n        } else if (this.sequenceCount === 15 && this.intervalTime > 2000) {\n            this.sequenceCount += 1;\n        } else if (\n            this.intervalTime > 2000 * this.intervalTiming &&\n        this.sequenceCount > 15 &&\n        this.sequenceCount < 20\n        ) {\n            this.sequenceCount += 1;\n            this.intervalTime = 0;\n            this.sequenceTypes[\"GreenGroups\"]();\n        } else if (this.sequenceCount === 20 && this.intervalTime > 3000) {\n            this.sequenceCount += 1;\n        }\n        // else if (this.intervalTime > (2500 * this.intervalTiming) && this.sequenceCount === 10 && this.hugeSequenceTime % 2 === 1) {\n        //   this.intervalTime = 0\n        //   this.sequenceCount += 1\n        //   let enemies_to_spawn = []\n        //   let randomPos = this.randomPosition();\n        //   for (let i = 0; i < 2; i++) {\n        //     for (let j = 0; j < 2; j++) {\n        //       this.enemyCreatorList[\"Weaver\"]([i * 40 + randomPos[0], j * 40 + randomPos[1]])\n        //     }\n        //   }\n\n        // } else if (this.intervalTime > (5000 * this.intervalTiming) && this.sequenceCount === 11) {\n        //   this.intervalTime = 0;\n        //   this.sequenceCount += 1;\n        //}\n        else if (\n            this.intervalTime > 375 &&\n        this.sequenceCount > 20 &&\n        this.sequenceCount < 30 &&\n        this.hugeSequenceTime % 2 === 0\n        ) {\n            this.ship.upgradeBullets();\n            this.intervalTime = 0;\n            this.sequenceCount += 1;\n\n            const fourCorners = [\n                [40, 40],\n                [GameScript.DIM_X - 40, 40],\n                [40, GameScript.DIM_Y - 40],\n                [GameScript.DIM_X - 40, GameScript.DIM_Y - 40],\n            ];\n            fourCorners.forEach((corner) => {\n                this.enemyCreatorList[\"Grunt\"](corner);\n            });\n        } else if (\n            this.intervalTime > 375 &&\n        this.sequenceCount > 20 &&\n        this.sequenceCount < 30 &&\n        this.hugeSequenceTime % 2 === 1\n        ) {\n            this.intervalTime = 0;\n            this.sequenceCount += 10;\n            const arrowWallPositions = [];\n            const arrowDirection = (Math.PI * 3) / 2 + Math.PI;\n            for (let i = 40; i < GameScript.DIM_X; i += 40) {\n                arrowWallPositions.push([i, 50]);\n            }\n\n            arrowWallPositions.forEach((position) => {\n                this.enemyCreatorList[\"Arrow\"](position, arrowDirection);\n            });\n        }\n        // this is the spawner event.\n        // it runs through all the child states\n        // for the event to be triggered\n        else if (this.sequenceCount >= 30) {\n            this.sequenceCount = 0;\n            if (!(this.intervalTiming < 0.5)) {\n                this.intervalTiming *= 0.9;\n            }\n            this.hugeSequenceTime += 1;\n        }\n\n    // if (this.gameTime % 2000 === 0){\n    //   this.spawned = false\n    // }\n    }\n\n    createShip() {\n        return new Ship(this.engine, this.startPosition, this.initialCameraZPos);\n    }\n\n    createWalls() {\n        return new Walls(this.engine, this);\n    }\n\n    createGrid(cameraTransform) {\n        return new Grid(this.engine, this, cameraTransform);\n    }\n\n    createOverlay() {\n        return new Overlay(this.engine, this, this.ship.transform);\n    }\n\n    isOutOfBounds(pos, radius) {\n        const max = [GameScript.DIM_X - radius, GameScript.DIM_Y - radius];\n        if (radius) {\n            return (\n                pos[0] <= radius ||\n        pos[0] >= max[0] ||\n        pos[1] <= radius ||\n        pos[1] >= max[1]\n            );\n        } else {\n            return (\n                pos[0] < 0 ||\n        pos[1] < 0 ||\n        pos[0] > GameScript.DIM_X ||\n        pos[1] > GameScript.DIM_Y\n            );\n        }\n    }\n\n    updateShipFireAngle() {\n        this.ships[0].setFireAngle();\n    }\n\n    // bounce(pos){\n    //   return [\n    //     Util.bounce(pos[0], GameScript.DIM_X), Util.bounce(pos[1], GameScript.DIM_Y)\n    //   ];\n    // }\n\n    bounce(transform, radius = 0) {\n        const max = [this.DIM_X - radius, this.DIM_Y - radius];\n        const pos = transform.absolutePosition();\n        if (pos[0] <= radius || pos[0] >= max[0]) {\n            transform.vel[0] = -transform.vel[0];\n        }\n        if (pos[1] <= radius || pos[1] >= max[1]) {\n            transform.vel[1] = -transform.vel[1];\n        }\n    }\n\n    wallGraze(transform, radius = 0) {\n        const max = [this.DIM_X - radius, this.DIM_Y - radius];\n        const pos = transform.absolutePosition();\n        const vel = transform.absoluteVelocity();\n\n        // X bounds, left right\n        if (pos[0] <= radius && vel[0] < 0) {\n            transform.vel[0] = 0.1;\n        } else if (pos[0] >= max[0] && vel[0] > 0) {\n            transform.vel[0] = -0.1;\n        }\n\n        // Y bounds, top bottom\n        if (pos[1] <= radius && vel[1] < 0) {\n            transform.vel[1] = 0.1;\n        } else if (pos[1] >= max[1] && vel[1] > 0) {\n            transform.vel[1] = -0.1;\n        }\n    }\n\n    redirect(transform) {\n        const max = [this.DIM_X, this.DIM_Y];\n        const pos = transform.absolutePosition();\n\n        if (pos[0] <= 0 || pos[0] >= max[0]) {\n            if (pos[0] <= 0) {\n                pos[0] = 1;\n            }\n            if (pos[0] >= max[0]) {\n                pos[0] = max[0] - 1;\n            }\n        }\n        if (pos[1] <= 0 || pos[1] >= max[1]) {\n            if (pos[1] <= 0) {\n                pos[1] = 1;\n            }\n            if (pos[1] >= max[1]) {\n                pos[1] = max[1] - 1;\n            }\n        }\n\n        transform.vel[0] = -transform.vel[0];\n        transform.vel[1] = -transform.vel[1];\n    }\n}\n\nGameScript.BG_COLOR = \"#000000\";\n\nGameScript.DIM_X = 1000;\nGameScript.DIM_Y = 600;\n// GameScript.FPS = 32;\n// GameScript.NUM_BOXES = 10;\n// GameScript.NUM_PINWHEELS = 0;\n// GameScript.NUM_ARROWS = 0;\n// GameScript.NUM_GRUNTS = 0;\n// GameScript.NUM_WEAVERS = 0;\n// GameScript.NUM_SINGULARITIES = 1;\n\nGameScript.Spawn1 = {\n    BoxBox: 50,\n};\n\nGameScript.spawnListList = [GameScript.Spawn1];\n\n\n\n// 2D \nconst performance2D = {\n    collisionTime: 0.12846034227596656,\n    frameRate: 117.86903385504282,\n    physicsCalcTime: 0.2529761062793578,\n    renderTime: 0.9149865687913138,\n    scriptTime: 0.00835571889659564,\n    updateTime: 0.1869786510739892,\n};\n\n// 3D\nconst performance3D = {\n    collisionTime: 0.0705062137856271,\n    frameRate: 54.9810552849427,\n    physicsCalcTime: 0.16501970291499046,\n    renderTime: 1.1280691114636254,\n    scriptTime: 0.008426796002401008,\n    updateTime: 0.177841770708579,\n};\n","export class GameView {\n    constructor(engine, ctx, canvasEl, levelDesigner, animationView) {\n        this.ctx = ctx;\n        this.engine = engine;\n        // this.ship = this.game.addShip(); belongs in game script\n        this.canvasEl = canvasEl;\n        this.initialUnmute = true;\n        this.gameStarted = false;\n        this.modelClosed = false;\n        this.levelDesigner = levelDesigner;\n        this.animationView = animationView;\n        this.bindKeyboardKeys = this.bindKeyboardKeys.bind(this);\n        this.gameEditorOpened = false;\n        this.lastTime = 0;\n        this.animate = this.animate.bind(this);\n        this.levelDesignLoaded = false;\n    }\n\n    bindKeyboardKeys() {\n        window.addEventListener(\"keydown\", this.doKeyEvent(true), true);\n        window.addEventListener(\"keyup\", this.doKeyEvent(false), true);\n    }\n\n    updateMovementDirection(move, down) {\n        if (!this.gameEditorOpened) {\n            this.engine.gameScript.ship.updateLeftControlStickInput(move, down);\n        }\n    }\n\n    /*\n    if true, change movement direction to the direction\n    if false, remove movement direction if it's the \n    same as the current movement direction\n  */\n\n    doKeyEvent(down) {\n        return (e) => {\n            // if (e.key === \"p\"){\n            //   this.engine.togglePause()\n            // }\n            if (e.key === \"m\" && this.initialUnmute) {\n                this.initialUnmute = false;\n                this.engine.gameScript.theme.play();\n            }\n\n            if (e.key === \"m\" && down) {\n                this.engine.toggleMute();\n                if (this.engine.muted) {\n                    this.engine.gameScript.theme.mute();\n                } else {\n                    this.engine.gameScript.theme.unmute();\n                }\n            }\n\n            const unitVector = GameView.MOVES[e.key];\n            if (unitVector) {\n                this.updateMovementDirection(e.key, down);\n            }\n            if (e.key === \"p\") {\n                this.engine.updateStartButtonListeners(e.key, down);\n            }\n        };\n    }\n\n    bindKeyHandlers() {\n        const engine = this.engine;\n        // Object.keys(GameView.MOVES).forEach((k) => {\n        //   const move = GameView.MOVES[k];\n        //   key(k, () => {\n        //     this.engine.gameScript.ship.updateLeftControlStickInput(move);\n        //   });\n        // });\n\n        // key(\"m\", () => {\n        //   engine.muted = !engine.muted;\n        //   if (engine.muted) {\n        //     this.theme.pause();\n        //   } else {\n        //     this.theme.play();\n        //   }\n        // })\n\n        window.addEventListener(\"mousemove\", (e) => {\n            const x = { x: e.layerX };\n            const y = { y: e.layerY };\n            const mousePos = [e.layerX, e.layerY];\n            this.engine.updateMousePos(mousePos);\n            this.levelDesigner.mouseMoveEvent(e);\n            // ship.setFireAngle(mousePos); add to game script event listener thing\n        });\n\n        window.addEventListener(\"click\", (e) => {\n            this.engine.mouseClicked(e);\n        });\n\n        window.addEventListener(\"mousedown\", (e) => {\n            this.engine.mouseDown(e);\n        });\n\n        window.addEventListener(\"mouseup\", (e) => {\n            this.engine.mouseUnClicked(e);\n        });\n\n        window.addEventListener(\"dblclick\", (e) => {\n            this.engine.mouseDoubleClicked(e);\n        });\n\n        // function preventDefault(e) {\n        //   e = e || window.event;\n        //   if (e.preventDefault)\n        //     e.preventDefault();\n        //   e.returnValue = false;\n        // }\n\n        // function disableScroll() {\n        //   if (window.addEventListener) // older FF\n        //     window.addEventListener('DOMMouseScroll', preventDefault, false);\n        //   // window.onwheel = preventDefault; // modern standard\n        //   // window.onmousewheel = document.onmousewheel = preventDefault; // older browsers, IE\n        //   // window.ontouchmove = preventDefault; // mobile\n        //   // document.onkeydown = preventDefaultForScrollKeys;\n        // }\n\n    // if (window.addEventListener) // older FF\n    //   window.addEventListener('DOMMouseScroll', preventDefault, false);\n    // window.onwheel = preventDefault; // modern standard\n    // window.onmousewheel = document.onmousewheel = preventDefault; // older browsers, IE\n    // window.ontouchmove = preventDefault; // mobile\n    }\n\n    end() {\n        var endModal = document.getElementById(\"endModal\");\n    }\n\n    start() {\n        this.lastTime = 0;\n        this.bindKeyHandlers();\n\n        // Get the modal\n        const modal = document.getElementById(\"myModal\");\n\n        // Get the button that opens the modal\n        // var btn = document.getElementById(\"myBtn\");\n\n        // Get the <span> element that closes the modal\n        // const xclose = document.getElementsByClassName(\"close\")[0];\n\n        // When the user clicks on <span> (x), close the modal\n        // xclose.onclick = (e) => {\n        //     e.stopPropagation();\n        //     modal.style.display = \"none\";\n        //     this.modelClosed = true;\n        // };\n\n        // When the user clicks anywhere outside of the modal, close it\n        //  window.addEventListener('click', (e) => {\n        // window.onclick = (event) => {\n        //     if (this.modelClosed && !this.gameStarted) {\n        //         this.gameStarted = true;\n        //         this.bindKeyboardKeys();\n        //         requestAnimationFrame(this.animate);\n        //     }\n        //     if (event.target == modal) {\n        //         this.modelClosed = true;\n        //         modal.style.display = \"none\";\n        //     }\n        // };\n\n        // add listeners to buttons on the modal\n        // have them do the same things they do now.. \n        // but without the strange order that's required \n        // for starting the game after loading one, or starting the default one\n        const startButtonModal = document.getElementById(\"startGameModal\");\n        // open the level editor\n        const levelEditorButton = document.getElementById(\"LevelEditorModal\");\n        \n        // load a level either for level editor or for starting the game\n        const loadGameDesignButtonModal = document.getElementById(\"loadGameDesignModal\");\n        // get the text from element: loadGameDesignInputModal\n\n        startButtonModal.onclick = (e) => {\n            e.stopPropagation();\n            this.gameStarted = true;\n            this.bindKeyboardKeys();\n            if(this.levelDesignLoaded){\n                this.levelDesigner.startGame();\n            }\n            requestAnimationFrame(this.animate);\n            modal.style.display = \"none\";\n        };\n\n        levelEditorButton.onclick = (e) => {\n            e.stopPropagation();\n            this.gameStarted = true;\n            this.gameEditorOpened = true;\n            this.bindKeyboardKeys();\n            requestAnimationFrame(this.animate);\n            modal.style.display = \"none\";\n            this.modelClosed = true;\n            setTimeout(() => {\n                this.levelDesigner.gameEditorOpened = true;\n                this.engine.gameEditorOpened = true;\n            },50);\n        };\n\n        loadGameDesignButtonModal.onclick = (e) => {\n            e.stopPropagation();\n            const json = document.getElementById(\"loadGameDesignInputModal\").value;\n            this.levelDesigner.loadGameDesign(json);\n            this.levelDesignLoaded = true;\n        };\n\n    }\n\n    animate(time) {\n        const timeDelta = time - this.lastTime;\n        this.engine.tick(timeDelta);\n        this.levelDesigner.animate(timeDelta);\n        this.animationView.animate(timeDelta);\n        this.lastTime = time;\n        // every call to animate requests causes another call to animate\n        requestAnimationFrame(this.animate);\n    }\n}\n\nconst KEYMAP = {\n    87: \"W\",\n    82: \"R\",\n    90: \"Z\",\n    88: \"X\",\n    67: \"C\",\n    70: \"F\",\n    83: \"S\",\n    69: \"E\",\n    65: \"D\",\n    68: \"A\",\n};\n\nGameView.MOVES = {\n    s: [0, 1],\n    a: [-1, 0],\n    w: [0, -1],\n    d: [1, 0],\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { GameScript } from \"./game_script\";\nimport { GameView } from \"./game_view\";\nimport { GameEngine } from \"./game_engine/game_engine\";\nimport { LevelDesigner } from \"./game_engine/Levels/levelDesigner\";\nimport { AnimationView } from \"./AnimationView\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    const canvasEl = document.getElementsByTagName(\"canvas\")[0];\n    canvasEl.width = GameScript.DIM_X;\n    canvasEl.height = GameScript.DIM_Y;\n\n    const ctx = canvasEl.getContext(\"2d\");\n    const gameEngine = new GameEngine(ctx);\n    const animationWindow = document.getElementsByTagName(\"canvas\")[1].getContext(\"2d\");\n    const levelDesignerCanvas = document.getElementsByTagName(\"canvas\")[2];\n    const levelDesignerCtx = levelDesignerCanvas.getContext(\"2d\");\n    const animationView = new AnimationView(animationWindow);\n    const levelDesigner = new LevelDesigner(gameEngine, animationView, levelDesignerCtx);\n    gameEngine.levelDesigner = levelDesigner;\n\n    const gameView = new GameView(gameEngine, ctx, canvasEl, levelDesigner, animationView).start();\n    levelDesigner.gameView = gameView;\n});\n"],"names":[],"sourceRoot":""}