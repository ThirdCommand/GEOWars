{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/GEOWars.js","webpack:///./lib/game_engine/collider.js","webpack:///./lib/game_engine/color.js","webpack:///./lib/game_engine/game_engine.js","webpack:///./lib/game_engine/game_object.js","webpack:///./lib/game_engine/line_sprite.js","webpack:///./lib/game_engine/physics_component.js","webpack:///./lib/game_engine/sound.js","webpack:///./lib/game_engine/state_machine.js","webpack:///./lib/game_engine/transform.js","webpack:///./lib/game_engine/util.js","webpack:///./lib/game_objects/Bullet/bullet.js","webpack:///./lib/game_objects/Bullet/bullet_sprite.js","webpack:///./lib/game_objects/Overlay/overlay.js","webpack:///./lib/game_objects/Overlay/overlay_sprite.js","webpack:///./lib/game_objects/Walls/walls.js","webpack:///./lib/game_objects/Walls/walls_sprite.js","webpack:///./lib/game_objects/enemies/Arrow/arrow.js","webpack:///./lib/game_objects/enemies/Arrow/arrow_sprite.js","webpack:///./lib/game_objects/enemies/BoxBox/boxbox.js","webpack:///./lib/game_objects/enemies/BoxBox/boxbox_sprite.js","webpack:///./lib/game_objects/enemies/Grunt/grunt.js","webpack:///./lib/game_objects/enemies/Grunt/grunt_sprite.js","webpack:///./lib/game_objects/enemies/Pinwheel/pinwheel.js","webpack:///./lib/game_objects/enemies/Pinwheel/pinwheel_sprite.js","webpack:///./lib/game_objects/enemies/Singularity/alien_ship.js","webpack:///./lib/game_objects/enemies/Singularity/alien_ship_sprite.js","webpack:///./lib/game_objects/enemies/Singularity/singularity.js","webpack:///./lib/game_objects/enemies/Singularity/singularity_sprite.js","webpack:///./lib/game_objects/enemies/Weaver/weaver.js","webpack:///./lib/game_objects/enemies/Weaver/weaver_sprite.js","webpack:///./lib/game_objects/particles/Grid/grid.js","webpack:///./lib/game_objects/particles/Grid/grid_point.js","webpack:///./lib/game_objects/particles/Grid/grid_sprite.js","webpack:///./lib/game_objects/particles/Particle/particle.js","webpack:///./lib/game_objects/particles/Particle/particle_sprite.js","webpack:///./lib/game_objects/particles/Singularity_Particle/singulairty_particle_sprite.js","webpack:///./lib/game_objects/particles/Singularity_Particle/singularity_particle.js","webpack:///./lib/game_objects/particles/bullet_wall_explosion.js","webpack:///./lib/game_objects/particles/enemy_spawn.js","webpack:///./lib/game_objects/particles/particle_explosion.js","webpack:///./lib/game_objects/particles/ship_explosion.js","webpack:///./lib/game_objects/particles/singularity_hit_explosion.js","webpack:///./lib/game_objects/particles/singularity_particles.js","webpack:///./lib/game_objects/ship/ship.js","webpack:///./lib/game_objects/ship/ship_sprite.js","webpack:///./lib/game_script.js","webpack:///./lib/game_view.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;ACnEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACZD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,cAAc;;AAEd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,G;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,K;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO,GAAG,OAAO,GAAG,OAAO;AAC/C,KAAK;AACL,oBAAoB,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,OAAO;AACzD,KAAK;AACL,oBAAoB,OAAO,GAAG,OAAO,IAAI,OAAO;AAChD,KAAK;AACL,qBAAqB,OAAO,IAAI,OAAO,KAAK,OAAO,KAAK,OAAO;AAC/D;AACA;AACA;AACA;;AAEA,uB;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qE;;;;;;;;;;;AC5XA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4B;;;;;;;;;;;ACjBA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uB;;;;;;;;;;;ACjDA;;AAEA;AACA,0BAA0B;AAC1B;AACA,iDAAiD;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,8B;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,O;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,2B;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;;;AAIH;;AAEA;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;;AAIA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA,0C;;;;;;;;;;;AC9EA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B;AAC9B,0BAA0B;AAC1B,6BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA,6B;;;;;;;;;;;ACrCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wB;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8B;;;;;;;;;;;AChCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,sB;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,4B;;;;;;;;;;;ACtDA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uB;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,6BAA6B;AAC7B,6BAA6B;AAC7B,yBAAyB;AACzB,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;;AAEA,6B;;;;;;;;;;;AC5DA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wB;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA,8B;;;;;;;;;;;ACxEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA,0C;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,yBAAyB;AACzB,yBAAyB;AACzB,2BAA2B;AAC3B;AACA;AACA;;;;;AAKA;;AAEA,6B;;;;;;;;;;;AC5DA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA,0B;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB,uBAAuB;AACvB,sBAAsB;AACtB,qBAAqB;AACrB,sBAAsB;AACtB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,sBAAsB;AACtB,sBAAsB;AACtB,oBAAoB;;AAEpB;AACA;AACA;;;;;AAKA;;AAEA,gC;;;;;;;;;;;ACzEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,0C;;;;;;;;;;;AC/EA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gC;;;;;;;;;;;AC5CA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,0C;;;;;;;;;;;AC7JA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kC;;;;;;;;;;;ACxDA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,0C;;;;;;;;;;;ACjHA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB,qBAAqB;AACrB,qBAAqB;AACrB,sBAAsB;AACtB,sBAAsB;AACtB,+BAA+B;AAC/B,8BAA8B;AAC9B,6BAA6B;AAC7B,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA,6B;;;;;;;;;;;ACpEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,8BAA8B;AAC9B,6BAA6B;;AAE7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sCAAsC;AACrE,mCAAmC,sCAAsC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,sB;;;;;;;;;;;;AChFA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,+BAA+B;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,2B;;;;;;;;;;;AC1BA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,8BAA8B;AACrD;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2B;;;;;;;;;;;AC/DA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,kB;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0B;;;;;;;;;;;AC5EA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA,gC;;;;;;;;;;;AClCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA,2C;;;;;;;;;;;ACpCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qC;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oC;;;;;;;;;;;AC1DA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4B;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA,mC;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,sBAAsB;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA,+B;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA,yC;;;;;;;;;;;ACxDA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA,sC;;;;;;;;;;;ACnFA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,K;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,S;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,S;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;ACvVA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4B;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB;;;AAG5D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,W;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB,OAAO;AAC9B,yBAAyB,OAAO;AAChC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB,OAAO;AAC9B,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,6DAA6D,sCAAsC;AACnG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,K;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,0BAA0B,OAAO;AACjC;AACA;AACA;;AAEA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;;AAEA;AACA;AACA,OAAO;;AAEP,K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;AAKA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;ACtjBA;AACA;AACA,mB;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;;AAER;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;;AAER;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA,qCAAqC;AACrC,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,4CAA4C;AAC5C,yEAAyE;AACzE,gDAAgD;AAChD;AACA;;;;;;;AAOA;AACA;AACA,uCAAuC;AACvC,oEAAoE;AACpE,2CAA2C;;AAE3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/GEOWars.js\");\n","const GameScript = require(\"./game_script\");\nconst GameView = require(\"./game_view\");\nconst GameEngine = require(\"./game_engine/game_engine\");\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvasEl = document.getElementsByTagName(\"canvas\")[0];\n  canvasEl.width = GameScript.DIM_X;\n  canvasEl.height = GameScript.DIM_Y;\n\n  const ctx = canvasEl.getContext(\"2d\");\n  const gameEngine = new GameEngine(ctx);\n  new GameView(gameEngine, ctx, canvasEl).start();\n});\n\n","// engine takes in collider with gameobject type as string\n// this way subscriptions can be done via string names\n// enemy is subscribed to bullets..\n// each enemy will check every bullet\n// convert gameobject type to string\n// colliders can be added without subscriptions\n// subscriptions are an array of strings stored with the collider\n\n// collider: object absolute transform\n// collider { gameObject gameObject, \"subscriptions\" [\"name\", \"name\"] }\n// colliders {\"BoxBox\" [collider, collider]}\n\nconst Util = require(\"./util\")\n\nclass Collider {\n  constructor(type, gameObject, radius = 5, subscriptions, subscribedColliderTypes) {\n    this.objectType = gameObject.constructor.name\n    this.type = type\n    this.subscriptions = subscriptions\n    this.subscribedColliderTypes = subscribedColliderTypes\n    this.radius = radius\n    this.gameObject = gameObject\n  }\n  // wondering if collision should cascade up the parent objects\n  // nope not yet anyway\n\n  collisionCheck(otherCollider) {\n    const centerDist = Util.dist(this.gameObject.transform.pos, otherCollider.gameObject.transform.pos)\n    if (centerDist < (this.radius + otherCollider.radius)){\n      this.gameObject.onCollision(otherCollider, this.type)\n    }\n  } \n}\n\nmodule.exports = Collider;\n\n// on\n\n// When you add new things that effect other things\n// like a new type of bullet, singularity effect, etc\n// you just have to add that functionality to the bullet\n// add the things it effects as things \n// the collider subscribes to\n// this way you don't have to edit every object type\n// that is effected\n\n// singularity has two colliders\n// outer one for gravity effects \n// inner one for actual hits\n// it's subscribed to everything\n// on collision it changes that object properties either \n// directly or with a object method... preferably","\nclass Color {\n  constructor(colorSpec){\n    this.colorType = Object.keys(colorSpec)[0]\n    this.creationErrorCheck(colorSpec)\n    this.extractColorInfo(colorSpec)\n  }\n\n  creationErrorCheck(colorSpec){\n    if (Object.keys(colorSpec).length !== 1) {\n      new Error(\"Color object accepts one color type\")\n    }\n    if (!Color.COLOR_TYPES.includes(this.colorType)) {\n      new Error(\"Color Object given unsupported color type\")\n    }\n  }\n\n  dup(){\n    let dupSpec = {}\n    if (this.colorType === \"rgb\") {\n      dupSpec[\"rgb\"]  = [this.r, this.g, this.b]\n    } else if (this.colorType === \"rgba\") {\n      dupSpec[\"rgba\"] = [this.r, this.g, this.b, this.a]\n    } else if (this.colorType === \"hsl\") {\n      dupSpec[\"hsl\"]  = [this.h, this.s, this.l]\n    } else if (this.colorType === \"hsla\") {\n      dupSpec[\"hsla\"] = [this.h, this.s, this.l, this.a]\n    }\n    let newColor = new Color(dupSpec)\n    return newColor\n  }\n\n  extractColorInfo(colorSpec){\n    if (this.colorType === \"rgb\"){\n      this.r = colorSpec[this.colorType][0]\n      this.g = colorSpec[this.colorType][1]\n      this.b = colorSpec[this.colorType][2]\n    } else if (this.colorType === \"rgba\"){\n      this.r = colorSpec[this.colorType][0]\n      this.g = colorSpec[this.colorType][1]\n      this.b = colorSpec[this.colorType][2]\n      this.a = colorSpec[this.colorType][3]\n    } else if (this.colorType === \"hsl\"){\n      this.h = colorSpec[this.colorType][0]\n      this.s = colorSpec[this.colorType][1]\n      this.l = colorSpec[this.colorType][2]\n    } else if (this.colorType === \"hsla\"){\n      this.h = colorSpec[this.colorType][0]\n      this.s = colorSpec[this.colorType][1]\n      this.l = colorSpec[this.colorType][2]\n      this.a = colorSpec[this.colorType][3]\n    } \n    colorSpec[this.colorType]\n  }\n\n  evaluateColor(){\n    if (this.colorType === \"rgb\"){\n      return `rbg(${this.r},${this.g},${this.b},)`\n    } else if (this.colorType === \"rgba\"){\n      return `rbg(${this.r},${this.g},${this.b},${this.a})`\n    } else if (this.colorType === \"hsl\"){\n      return `hsl(${this.h},${this.s}%,${this.l}%`\n    } else if (this.colorType === \"hsla\") {\n      return `hsla(${this.h}, ${this.s}%, ${this.l}%, ${this.a}`\n    }\n  }\n}\nColor.COLOR_TYPES = [\"rgb\", \"rgba\", \"hsl\", \"hsla\"]\n\nmodule.exports = Color;","const GameScript = require(\"../game_script\");\n// const GameObject = require(\"./game_boject\");\n// const LineRenderer = require(\"./line_renderer\");\n// const PhysicsComponent = require(\"./physics_component\")\n// const Sound = require(\"./sound\")\n// const Transform = require(\"./transform\")\n// const Util = require(\"./util\")\n\nclass GameEngine {\n  constructor(ctx) {\n    this.ctx = ctx\n    this.gameObjects = [];\n    this.physicsComponents = [];\n    this.lineSprites = [];\n    this.soundsToPlay = {};\n    this.colliders = {};\n    this.subscribers = [];\n    this.muted = true;\n    this.mouseListeners = [];\n    this.leftControlStickListeners = [];\n    this.rightControlStickListeners = [];\n    this.xButtonListeners = [];\n    this.startButtonListeners = [];\n    this.gameScript = new GameScript(this);\n    this.toRemoveQueue = []\n    this.paused = false;\n    this.currentCamera = null;\n    this.defaultZoomScale = 1.30;\n    this.zoomScale = 1.30;\n    this.graphicQuality = 1;\n    this.setupController()\n    this.setupPerformance()\n    window.engine = this\n\n  }\n\n  setupPerformance(){\n    this.collisionTime = 0\n    this.physicsCalcTime = 0\n    this.updateTime = 0\n    this.renderTime = 0\n    this.scriptTime = 0\n    this.timePassed = 0\n  }\n\n  setupController(){\n     window.addEventListener(\"gamepadconnected\", function (e) {\n       window.controller = e.gamepad\n       window.engine.controller = e.gamepad\n       // Gamepad connected\n       console.log(\"Gamepad connected\", e.gamepad);\n     });\n\n     window.addEventListener(\"gamepaddisconnected\", function (e) {\n       // Gamepad disconnected\n       window.engine.controller = null\n       console.log(\"Gamepad disconnected\", e.gamepad);\n     });\n  }\n\n  updateGraphicSetting(delta){\n    if (delta > 50) {\n      // console.log(\"worst\")\n      this.graphicQuality = 3\n    }else if(delta > 25){\n      this.graphicQuality = 2\n    } else {\n      this.graphicQuality = 1\n    }\n  }\n\n  tick(delta) {\n    // debugger\n    this.updateGraphicSetting(delta)\n    if(this.paused){\n      this.updateControlListeners()\n      return\n    }\n    // console.log(delta)\n    if(delta > 125){\n      delta = 125\n    }\n    let beforeCollisionTime = performance.now()\n    this.checkCollisions()\n    let beforePhysicsCalcs = performance.now()\n    let collisionTime = beforeCollisionTime - beforePhysicsCalcs\n    this.movePhysicsComponents(delta)\n    let beforeUpdate = performance.now()\n    let physicsCalcTime = beforePhysicsCalcs - beforeUpdate\n    this.updateGameObjects(delta)\n    let beforeRender = performance.now()\n    let updateTime = beforeUpdate - beforeRender\n    this.clearCanvas()\n    this.renderLineSprites(this.ctx)\n    let beforeScriptUpdate = performance.now()\n    let renderTime = beforeRender - beforeScriptUpdate\n    this.updateControlListeners()\n    this.updateGameScript(delta)\n    let scriptTime = beforeScriptUpdate - performance.now()\n    this.playSounds()\n\n    this.collectPerformanceData(delta, collisionTime, physicsCalcTime, updateTime, renderTime, scriptTime)\n  }\n\n  collectPerformanceData(delta, collisionTime, physicsCalcTime, updateTime, renderTime, scriptTime) {\n    this.collisionTime += collisionTime\n    this.physicsCalcTime += physicsCalcTime\n    this.updateTime += updateTime\n    this.renderTime += renderTime\n    this.scriptTime += scriptTime\n\n    this.timePassed += delta\n    if (this.timePassed > 1000 * 60) {\n      let totalTime = this.collisionTime + this.physicsCalcTime + this.updateTime + this.renderTime + this.scriptTime\n      let timeData = {\n        \"collisionTime\": (100 * this.collisionTime / totalTime),\n        \"physicsCalcTime\": (100 * this.physicsCalcTime / totalTime),\n        \"updateTime\": (100 * this.updateTime / totalTime),\n        \"renderTime\": (100 * this.renderTime / totalTime),\n        \"scriptTime\": (100 * this.scriptTime / totalTime),\n      }\n      console.log(timeData)\n\n      this.setupPerformance()\n    }\n  }\n\n  pause(){\n    this.paused = true\n    this.gameScript.onPause()\n\n  }\n\n  unPause(){\n    this.paused = false\n    this.gameScript.onUnPause()\n  }\n\n  togglePause(){\n    // console.log(\"pausetoggle\")\n    this.paused ? this.unPause() : this.pause()\n  }\n\n  clearCanvas(){\n    this.ctx.clearRect( -this.gameScript.DIM_X, -this.gameScript.DIM_Y, this.gameScript.DIM_X * this.zoomScale * 4, this.gameScript.DIM_Y * this.zoomScale * 4);\n    this.ctx.fillStyle = this.gameScript.BG_COLOR;\n    this.ctx.fillRect( -this.gameScript.DIM_X, -this.gameScript.DIM_Y, this.gameScript.DIM_X * this.zoomScale * 4, this.gameScript.DIM_Y * this.zoomScale * 4);\n  }\n\n  addLeftControlStickListener(object){\n    this.leftControlStickListeners.push(object)\n  }\n\n  addRightControlStickListener(object){\n    this.rightControlStickListeners.push(object)\n  }\n\n  addxButtonListener(object){\n    this.xButtonListeners.push(object)\n  }\n\n  addStartButtonListener(object) {\n    this.startButtonListeners.push(object)\n  }\n\n  updateLeftControlStickListeners(unitVector){\n    this.leftControlStickListeners.forEach((listener) => {\n      listener.updateLeftControlStickInput(unitVector)\n    })\n  }\n\n  updateRightControlStickListeners(unitVector){\n    this.rightControlStickListeners.forEach((listener) => {\n      listener.updateRightControlStickInput(unitVector)\n    })\n  }\n\n  updatexButtonListeners(xButton){\n    this.xButtonListeners.forEach((listener) => {\n      listener.updatexButtonListener(xButton)\n    })\n  }\n\n  updateStartButtonListeners(startButton, down){\n    // console.log([startButton, down])\n    this.startButtonListeners.forEach((listener) => {\n      listener.updateStartButtonListener(startButton, down)\n    })\n  }\n\n  updateMousePos(mousePos){\n    this.mouseListeners.forEach((object) => {\n      object.updateMousePos(mousePos)\n    })\n  }\n\n  updateControlListeners(){\n    navigator.getGamepads()\n    if(this.controller) {\n      let leftAxis = [window.controller.axes[0], window.controller.axes[1]]\n      let rightAxis = [window.controller.axes[2], window.controller.axes[3]]\n      let xButton = [window.controller.buttons[0].pressed]\n      let startButton = [window.controller.buttons[9].pressed]\n      this.updatexButtonListeners(xButton)\n      this.updateLeftControlStickListeners(leftAxis)\n      this.updateRightControlStickListeners(rightAxis)\n      this.updateStartButtonListeners(startButton)\n    }\n  }\n\n  movePhysicsComponents(delta) {\n    this.physicsComponents.forEach((component) => {\n      component.move(delta)\n    })\n  }\n\n  addCollider(collider){\n    if (collider.subscriptions) {\n      this.subscribers.push(collider)\n    }\n    let colliders = this.colliders\n    // collider: object absolute transform\n    // collider {\"objectType\": \"Bullet\", \"type\": \"general\", \"subscriptions\": [\"BoxBox\", \"Arrow\"], \"subscribedColliderTypes\": [\"General\"]}\n    // colliders {\"Singularity\": {\"General\": [collider, collider], \"GravityWell\": [collider, collider]}}\n    if (!colliders[collider.objectType]) {\n      let collidersSameTypeAndObject = {}\n      collidersSameTypeAndObject[collider.type] = [collider]\n      colliders[collider.objectType] = collidersSameTypeAndObject\n    } else {\n      if (!colliders[collider.objectType][collider.type]){\n        colliders[collider.objectType][collider.type] = [collider]\n      } else {\n        colliders[collider.objectType][collider.type].push(collider)\n      }\n    }\n  }\n\n  // must be a way to only retrieve \n  // the data for subscribed colliders once\n\n  checkCollisions() {\n// colliders{\n// \"Arrow\": [collider, collider]\n// }\n\n// collider {\n//   \"objectType\": \"Bullet\",\n//   \"type\": \"general\",\n//   \"subscriptions\": [\"BoxBox\", \"Arrow\"],\n//   \"subscribedColliderTypes\": [\"general\"]\n// }\n    let subscribers = this.subscribers\n    let colliders = this.colliders\n    this.stillCanDie = false;\n    // console.log(this.subscribers)\n    subscribers.forEach((subscriber) => {\n      if (subscriber.type === \"ShipDeath\") {\n        this.stillCanDie = true\n        // console.log(\"CAN DIE\")\n      }\n      subscriber.subscriptions.forEach((subscription) => {\n        colliders[subscription] = colliders[subscription] || {}\n        subscriber.subscribedColliderTypes.forEach((colliderType) => {\n          colliders[subscription][colliderType] = colliders[subscription][colliderType] || []\n          colliders[subscription][colliderType].forEach((subscribedCollider) => {\n            subscriber.collisionCheck(subscribedCollider)\n          })\n        })\n      })\n    })\n    if (!this.stillCanDie) {\n      // console.log(this.gameScript.ship.collider)\n      this.gameScript.ship.addCollider(\"General\", this.gameScript.ship, this.gameScript.ship.radius)\n      this.gameScript.ship.addCollider(\"ShipDeath\", this.gameScript.ship, this.gameScript.ship.radius, [\"BoxBox\", \"Singularity\", \"Weaver\", \"Grunt\", \"Arrow\", \"Pinwheel\"], [\"General\"])\n    }\n  }\n\n  updateGameObjects(delta) {\n    \n    this.gameObjects.forEach((object) => {\n      object.update(delta)\n    })\n  }\n\n  toggleMute(){\n    this.muted = !this.muted\n  }\n\n  playSounds(){\n    Object.values(this.soundsToPlay).forEach((sound) => {\n      sound.play();\n    })\n    this.soundsToPlay = {};\n  }\n\n  renderLineSprites(ctx) {\n    // ctx.scale = gameEngine.currentCamera.zoomScale\n    this.ctx.save()\n    \n    this.ctx.scale(this.zoomScale, this.zoomScale)\n    this.lineSprites.forEach((sprite) => {\n      sprite.draw(ctx)\n    })\n    this.ctx.restore()\n    // ctx.scale(1,1)\n  }\n\n  addMouseListener(object){\n    this.mouseListeners.push(object)\n  }\n  \n\n  updateGameScript(delta) {\n    this.gameScript.update(delta)\n  }\n\n  addGameObject(object) {\n    this.gameObjects.push(object)\n  }\n\n  addPhysicsComponent(physicsComponent){\n    this.physicsComponents.push(physicsComponent)\n  }\n\n  addLineSprite(lineSprite) {\n    this.lineSprites.push(lineSprite)\n  }\n\n  queueSound(sound){\n    if (!this.muted){\n      this.soundsToPlay[sound.url] = sound\n    }\n  }\n\n  // remove(gameObject){\n  //   this.toRemoveQueue.push(gameObject)\n  // }\n\n  // emptyRemoveQueue(){\n  //   this.toRemoveQueue.forEach((gameObject) => {\n  //     this.removeAction(gameObject)\n  //   })\n  // }\n\n  remove(gameObject) {\n    if (gameObject.physicsComponent) {\n      this.physicsComponents.splice(this.physicsComponents.indexOf(gameObject.physicsComponent), 1)\n    }\n    if (gameObject.lineSprite){\n      this.lineSprites.splice(this.lineSprites.indexOf(gameObject.lineSprite), 1)\n    }\n    this.removeColliders(gameObject.colliders)\n\n    this.gameObjects.splice(this.gameObjects.indexOf(gameObject), 1);\n  }\n\n  removeColliders(colliders){\n    colliders.forEach((collider) => {\n\n      if (collider.subscriptions) {\n        this.subscribers.splice(this.subscribers.indexOf(collider), 1)\n      }\n\n      let objectAndColliderTypeList = this.colliders[collider.objectType][collider.type]\n      objectAndColliderTypeList.splice(objectAndColliderTypeList.indexOf(collider), 1)\n\n\n    })\n  }\n}\n\nmodule.exports = GameEngine;\n\n    // the idea:\n    // engine takes in collider with gameobject type as string\n    // this way subscriptions can be done via string names\n    // enemy is subscribed to bullets..\n    // each enemy will check every bullet\n    // convert gameobject type to string\n    // colliders can be added without subscriptions\n    // subscriptions are an array of strings stored with the collider","const Util = require(\"./util\");\nconst Sound = require(\"./sound\")\n\nconst Transform = require( \"./transform\")\nconst PhysicsComponent = require(\"./physics_component\")\nconst LineSprite = require(\"./line_sprite\")\nconst Collider = require(\"./collider\")\n\nclass GameObject {\n  constructor(engine) {\n    this.gameEngine = engine\n    this.gameEngine.addGameObject(this)\n    this.transform = new Transform()\n    this.childObjects = []\n    this.physicsComponent = null \n    this.lineSprite = null\n    this.parentObject = null\n    this.colliders = []\n  }\n\n  addPhysicsComponent() {\n    this.physicsComponent = new PhysicsComponent(this.transform)\n    this.gameEngine.addPhysicsComponent(this.physicsComponent)\n  }\n\n  addLineSprite(lineSprite) {\n    this.lineSprite = lineSprite\n    this.gameEngine.addLineSprite(this.lineSprite)\n  }\n\n  addMousePosListener(){\n    this.gameEngine.addMouseListener(this)\n  }\n\n  addLeftControlStickListener() {\n    this.gameEngine.addLeftControlStickListener(this)\n  }\n\n  addRightControlStickListener() {\n    this.gameEngine.addRightControlStickListener(this)\n  }\n\n  addxButtonListener(){\n    this.gameEngine.addxButtonListener(this)\n  }\n  \n  addStartButtonListener() {\n    this.gameEngine.addStartButtonListener(this)\n  }\n\n  updateRightControlStickInput(direction){\n\n  }\n\n  updateLeftControlStickInput(direction){\n\n  }\n\n  updatexButtonListener(){\n\n  }\n\n  updateStartButtonListener() {\n\n  }\n\n  \n\n  updateMousePos(mousePos){\n\n  }\n\n  addCollider(type, gameObject, radius, subscriptionTypes, subscriptions){\n    // game engine checks every collider with it's subscription types\n    let newCollider = new Collider(type, gameObject, radius, subscriptionTypes, subscriptions)\n    this.colliders.push(newCollider)\n    this.gameEngine.addCollider(newCollider)\n  }\n\n  // store sound in instance\n  playSound(sound){\n    this.gameEngine.queueSound(sound)\n  }\n\n\n  // relative motion needs to be fixed... FOR ANOTHER TIME\n  addChildGameObject(obj, relative){\n    this.childObjects.push(obj)\n    if(relative){\n      obj.transform.parentTransform = this.transform\n    }\n    obj.parentObject = this\n  }\n\n  update(deltaTime) {\n    // overwritten by child class for update scripts\n  }\n\n  onCollision(collider, type) {\n    // overwritten by child class for handler\n  }\n\n  // remove is the issue\n  // i need a remove queue!!!\n  // ... I think\n  remove() {\n    this.childObjects.forEach((obj) => {\n      obj.remove()\n    })\n    if(this.parentObject){\n      this.parentObject.childObjects.splice(this.parentObject.childObjects.indexOf(this), 1)\n    }\n    this.gameEngine.remove(this);\n  }\n\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n\nmodule.exports = GameObject;\n","class LineSprite {\n  constructor(transform) {\n    this.transform = transform\n    // this.drawFunction = draw\n    this.zoomScaling = 1\n  }\n\n  draw(ctx) {\n    pos = this.transform.absolutePosition()\n    angle = this.transform.abosluteAngle()\n    this.drawFunction(ctx, pos, angle)\n  }\n  drawFunction(ctx,pos,angle){\n    \n  }\n}\n\nmodule.exports = LineSprite;","const Util = require(\"./util\");\nconst Sound = require(\"./sound\")\n\nclass PhysicsComponent {\n  constructor(transform) {\n    this.transform = transform\n  }\n\n  move(timeDelta) {\n    // timeDelta is number of milliseconds since last move\n    // if the computer is busy the time delta will be larger\n    // in this case the PhysicsObject should move farther in this frame\n    const timeScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n    this.transform.pos[0] += this.transform.vel[0] * timeScale + this.transform.acc[0] * (timeScale * timeScale) / 2;\n    this.transform.pos[1] += this.transform.vel[1] * timeScale + this.transform.acc[1] * (timeScale * timeScale) / 2;\n    this.transform.vel[0] += this.transform.acc[0] * timeScale;\n    this.transform.vel[1] += this.transform.acc[1] * timeScale;\n    this.transform.angle += this.transform.aVel\n    this.transform.aVel += this.transform.aAcc\n\n    this.transform.acc = [0, 0];\n    this.transform.aAcc = 0;\n\n  }\n\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n\nmodule.exports = PhysicsComponent;\n","\nclass Sound {\n  constructor(url, volume = 1, muted = false){\n    this.url = url;\n    this.volume = volume;\n    this.muted = muted;\n  }\n\n  play() {\n    // if (this.sound) {\n    //   this.sound.play()\n    // } else {\n      this.sound = new Audio(this.url);\n      this.sound.volume = this.volume;\n      this.sound.play();\n    // }\n  }\n  toggleMute(){\n    if(this.sound){\n      this.muted ? this.unmute() : this.mute()\n    }\n  }\n\n  unmute(){\n    if(this.sound){\n      this.muted = false \n      this.sound.volume = this.volume\n    }\n  }\n\n  mute(){\n    if(this.sound){\n      this.muted = true\n      this.sound.volume = 0\n    }\n  }\n\n  pause(){\n    if(this.sound){\n      this.sound.pause()\n    } \n  }\n  unPause(){\n    if (this.sound) {\n      this.sound.play()\n    }\n  }\n}\n\nmodule.exports = Sound;","const GameObject = require(\"./game_object\")\n\nclass StateMachine extends GameObject {\n    constructor(engine, {}) {\n        super(engine)\n        this.stateIndex = options.stateIndex || {i: 0 }\n        this.parentState = options.parentState, waitTime = 0, stateQueue = [], event, timesDo = 1, endCondition = true\n        this.stateIndex = stateIndex\n        this.parentIndex = parentIndex\n        this.stateTime = 0\n\n        this.waitTime = waitTime\n        this.stateQueue = stateQueue\n        this.event = event\n        this.timesDo = timesDo\n        this.endCondition = endCondition \n        // if not null, it will repeat until the condition is met\\\n        // but it will meet the repeatcondition first. \n        // end condition returns a bool. default true\n\n        // there is no \"break\" condition yet\n\n        this.repeatCount = 1 // do something 3 times. 1 index not 0 index\n\n        // first it waits,\n        // then it runs through state queue\n        // then it runs the event\n        //      state queue and event can be empty, \n        //        which means the state was just for waiting\n        // then it checks the repeat condition\n\n        // event is something that runs in one frame\n\n    }\n\n    addChilState(state){\n        state.parentIndex = this\n    }\n\n    // state queue is now done\n    onCompletion(){\n        this.event()\n                // 1 index not 0\n        if (this.repeatCount <= this.timesDo){\n            this.stateIndex.i = 0;\n            this.currentTime = 0;\n        } else if (!this.endCondition) {\n            this.stateIndex.i = 0;\n            this.currentTime = 0;\n        } else {\n            this.parentIndex += 1\n            this.remove()\n        }\n    }\n\n    // instances vs inheritance\n    // instance is built from the ground up, \n    // starting with the lowest level of the sequence\n    // inheritance is built from the top down, \n    // allowing each custom class to build thier individual statequeues\n    // inheritance gives access to all of the gameobject functions\n    // instances are simpler, everything is fed through the constuctor\n    // User gets to choose?\n\n    // singularity\n    // EasyGroups <-- childState\n        // wait: 2500 * timeScale (user can provide timescale functionality)\n        // event: spawnEasyGroups \n        // endCondition: x4 // repeats until end condition met\n        // parentIndex\n    // waitState <--childState\n    // EasyGroupsArrows \n        // wait: 2500 * timeScale (user can provide timescale functionality)\n        // event: spawnEasyGroupsArrows\n        // endCondition: x4 // repeats until end condition met\n    // event\n    // wait\n    // event\n    // \n\n    event(){\n        this.eventCondition()\n    }\n    //spawner\n        //easy wave\n            //\n\n    updateState(intervalTime){\n        if(this.stateIndex > this.stateQueue.length){\n            this.onCompletion()\n        } else {\n            this.stateTime += intervalTime\n            if(intervalTime > this.waitTime){\n                this.stateQueue[this.stateIndex.i].updateState(intervalTime)\n            }\n        }\n    }\n\n    remove() {\n        this.childObjects.forEach((obj) => {\n            obj.remove()\n        })\n        if (this.parentObject) {\n            this.parentObject.childObjects.splice(this.parentObject.childObjects.indexOf(this), 1)\n        }\n        this.stateQueue.forEach((obj) => {\n            obj.remove()\n        })\n        \n        this.gameEngine.remove(this);\n    }\n\n}\nmodule.exports = StateMachine;","const Util = require(\"./util\");\nclass Transform {\n  constructor(pos = [0,0], vel = [0,0], acc = [0,0], angle = 0, aVel = 0, aAcc = 0, parentTransform = null){\n    this.parentTransform = parentTransform\n    this.angle = angle\n    this.aVel = aVel\n    this.aAcc = aAcc\n    this.pos = pos\n    this.vel = vel\n    this.acc = acc\n  }\n\n  // call up the tree of parent transforms until null\n  // performing the transformation each step for the absolute\n  absoluteAngle() {\n    if (this.parentTransform == null) {\n      return this.angle\n    } else {\n      return this.angleAdd(this.angle, this.parentTransform.absoluteAngle())\n    }\n  }\n\n  absolutePosition() {\n    let absPos = []\n    if (this.parentTransform == null){\n      absPos = this.pos\n      return absPos\n    } else { \n      return this.vectorAdd(this.pos, this.parentTransform.absolutePosition())\n    }\n  }\n\n  absoluteVelocity() {\n    let absVel = []\n    if (this.parentTransform == null) {\n      absVel = this.vel\n      return absVel\n    } else {\n      return this.vectorAdd(this.vel, this.parentTransform.absoluteVelocity())\n    }\n  }\n\n  absoluteAcceleration() {\n    let absAcc = []\n    if (this.parentTransform == null) {\n      absAcc = this.acc\n      return absAcc\n    } else {\n      return this.vectorAdd(this.acc, this.parentTransform.absoluteAcceleration())\n    }\n  }\n\n  vectorAdd(vector1, vector2) {\n    return [vector1[0] + vector1[0], vector1[1] + vector2[1]]\n  }\n\n  angleAdd(angle1, angle2) {\n\n    return (angle1 + angle2) % (2 * Math.PI)\n  }\n\n}\n\nmodule.exports = Transform;","\nconst Util = {\n  // Normalize the length of the vector to 1, maintaining direction.\n  dir(vec) {\n    const norm = Util.norm(vec);\n    return Util.scale(vec, 1 / norm);\n  },\n  vectorCartisian(angle,scale){\n\n    let vector = [];\n    vector = [scale * Math.cos(angle), scale * Math.sin(angle)]\n    return vector\n  },\n  // Find distance between two points.\n  dist(pos1, pos2) {\n    return Math.sqrt(\n      Math.pow(pos1[0] - pos2[0], 2) + Math.pow(pos1[1] - pos2[1], 2)\n    );\n  },\n  // Find the length of the vector.\n  norm(vec) {\n    return Util.dist([0, 0], vec);\n  },\n  // Return a randomly oriented vector with the given length.\n  randomVec(length) {\n    const deg = 2 * Math.PI * Math.random();\n    return Util.scale([Math.sin(deg), Math.cos(deg)], length);\n  },\n  // Scale the length of a vector by the given amount.\n  scale(vec, m) {\n    return [vec[0] * m, vec[1] * m];\n  },\n\n  \n \n};\n\nmodule.exports = Util;\n","const GameObject = require(\"../../game_engine/game_object\");\nconst Sound = require(\"../../game_engine/sound\")\nconst BulletWallExplosion = require(\"../particles/bullet_wall_explosion\")\nconst BulletSprite = require(\"./bullet_sprite\")\nconst ParticleExplosion = require(\"../particles/particle_explosion\")\nclass Bullet extends GameObject {\n  constructor(engine, pos, vel, bulletNumber) {\n    super(engine);\n    this.ID = bulletNumber\n    this.transform.pos[0] = pos[0]\n    this.transform.pos[1] = pos[1]\n    this.transform.vel[0] = vel[0]\n    this.transform.vel[1] = vel[1]\n    this.length = 12;\n    this.radius = this.length / 4;\n    this.wrap = false\n    this.wallhit = new Sound(\"GEOWars/sounds/bullet_hitwall.wav\", 1)\n    this.addExplosionCollider()\n    this.addPhysicsComponent()\n    this.addLineSprite(new BulletSprite(this.transform))\n    this.exploded = false;\n    this.lifeTime = 4000;\n    this.aliveTime = 0;\n  }\n\n  addExplosionCollider(){\n    let subscribers = [\"Grunt\", \"Pinwheel\", \"BoxBox\", \"Arrow\", \"Singularity\", \"Weaver\", \"AlienShip\"]\n    this.addCollider(\"bulletHit\", this, this.radius, subscribers, [\"General\"])\n    this.addCollider(\"General\", this, this.radius)\n  }\n\n  update(deltaTime){\n    this.aliveTime += deltaTime \n    if(this.aliveTime > this.lifeTime){\n      this.remove();\n    }\n    if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition()) && !this.exploded) {\n      this.exploded = true\n      new BulletWallExplosion(this.gameEngine, this.transform.pos)\n\n      this.gameEngine.queueSound(this.wallhit)\n      this.remove();\n    }\n  }\n\n  onCollision(collider, type){\n    if (type === \"bulletHit\") {\n      if (collider.objectType === \"Singularity\") {\n        collider.gameObject.bulletHit()\n        this.remove()\n      } else {\n        let hitObjectTransform = collider.gameObject.transform\n        let pos = hitObjectTransform.absolutePosition() \n        let vel = hitObjectTransform.absoluteVelocity()\n        let explosion = new ParticleExplosion(this.gameEngine, pos, vel)\n        this.gameEngine.gameScript.tallyScore(collider.gameObject)\n        collider.gameObject.remove()\n        this.remove()\n      }\n        \n    }\n    \n  }\n  \n  // move(timeDelta) {\n\n    \n\n  // }\n    \n}\n\n\nBullet.RADIUS = 3;\nBullet.SPEED = 7;\n\nmodule.exports = Bullet;\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","const LineSprite = require(\"../../game_engine/line_sprite\")\n\nclass BulletSprite extends LineSprite {\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n    this.length = 12\n  }\n\n  draw(ctx) {\n\n    let l = this.length\n    let pos = this.transform.absolutePosition();\n    let vel = this.transform.absoluteVelocity();\n    \n    let w = this.length / 2;\n    let movementDirection = Math.atan2(vel[0], -vel[1])\n    \n    ctx.save();\n    ctx.beginPath();\n    ctx.translate(pos[0], pos[1]);\n    ctx.rotate(movementDirection + 2 * Math.PI);\n\n    ctx.beginPath();\n    ctx.strokeStyle = \"#FBFBC2\";\n    ctx.lineWidth = 1;\n\n    ctx.moveTo(-l / 4, l / 2); //1\n    ctx.lineTo(0, -l / 2); //2\n    ctx.lineTo(l / 4, l / 2); //3\n\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n\n  }\n}\nmodule.exports = BulletSprite","const OverlaySprite = require(\"./overlay_sprite\")\nconst GameObject = require(\"../../game_engine/game_object\")\n\nclass Overlay extends GameObject {\n    constructor(engine, gameScript, shipTransform) {\n        super(engine);\n        this.gameScript = gameScript\n        this.shipTransform = shipTransform\n        this.transform.pos = [0, 0]\n        this.addLineSprite(new OverlaySprite(this.shipTransform, this.gameScript.DIM_X, this.gameScript.DIM_Y, this.gameEngine))\n    }\n\n    update(deltaTime) {\n        this.lineSprite.score = this.gameScript.score\n        this.lineSprite.lives = this.gameScript.lives\n    }\n}\n\nmodule.exports = Overlay","const LineSprite = require(\"../../game_engine/line_sprite\")\nconst Color = require(\"../../game_engine/color\")\nclass OverlaySprite extends LineSprite {\n    constructor(transform, DIM_X, DIM_Y, gameEngine) {\n        super(transform)\n        this.gameEngine = gameEngine\n        this.transform = transform\n        this.width = DIM_X\n        this.height = DIM_Y\n        this.score = 0;\n        this.lives = 0;\n        this.fontSize = 20;\n        this.fontStyle = \"Arial\"\n        this.shadowColor = new Color({\n            \"hsla\": [202, 100, 70, 1]\n        });\n        this.color = new Color({\n            \"hsla\": [202, 100, 70, 0.5]\n        });\n    }\n\n    draw(ctx) {\n        ctx.save()\n        ctx.scale(1 / this.gameEngine.zoomScale, 1 / this.gameEngine.zoomScale)\n        let zoomFactor = this.gameEngine.zoomScale / this.gameEngine.defaultZoomScale\n        ctx.font = this.fontSize * 1.3 + \"px \" + this.fontStyle;\n        ctx.fillStyle = this.color.evaluateColor();\n\n        ctx.fillText(\"Score: \" + this.score + \"      \" + \"Lives: \" + this.lives, (this.transform.pos[0] - 350 / zoomFactor) * this.gameEngine.zoomScale, (this.transform.pos[1] - 150 / zoomFactor )* this.gameEngine.zoomScale);\n        ctx.restore()\n    }\n}\nmodule.exports = OverlaySprite","const WallsSprite = require(\"./walls_sprite\")\nconst GameObject = require(\"../../game_engine/game_object\")\n\nclass Walls extends GameObject {\n    constructor(engine, gameScript) {\n        super(engine);\n        this.gameScript = gameScript\n        this.transform.pos = [0,0]\n        this.addLineSprite(new WallsSprite(this.transform, this.gameScript.DIM_X, this.gameScript.DIM_Y))\n    }\n\n    update(deltaTime) {\n        \n    }\n}\n\nmodule.exports = Walls","const LineSprite = require(\"../../game_engine/line_sprite\")\nconst Color = require(\"../../game_engine/color\")\nclass WallsSprite extends LineSprite {\n    constructor(transform, DIM_X, DIM_Y) {\n        super(transform)\n        this.width = DIM_X\n        this.height = DIM_Y\n        this.shadowColor = new Color({\n            \"hsla\": [202, 100, 70, 1]\n        });\n        this.color = new Color({\n            \"hsla\": [202, 100, 70, 0.2]\n        });\n    }\n\n    draw(ctx) {\n        let w = this.width\n        let h = this.height\n        let pos = this.transform.absolutePosition();\n\n        ctx.save();\n        ctx.beginPath();\n        ctx.translate(pos[0], pos[1]);\n\n        let blurFactor = 0.5\n        ctx.shadowColor = this.shadowColor.evaluateColor();\n        ctx.shadowBlur = 10;\n        ctx.strokeStyle = this.color.evaluateColor();\n        ctx.lineWidth = 7.5 * blurFactor * 2;\n        this.drawWalls(ctx, w, h)\n        ctx.lineWidth = 6 * 2// * blurFactor;\n        this.drawWalls(ctx, w, h)\n        ctx.lineWidth = 4.5 * 2 // * blurFactor;\n        this.drawWalls(ctx, w, h)\n        ctx.lineWidth = 3 * 2// * blurFactor;\n        this.drawWalls(ctx, w, h)\n        ctx.strokeStyle = 'rgb(255, 255, 255)';\n        ctx.lineWidth = 1.5 * 2// * blurFactor;\n        this.drawWalls(ctx, w, h)\n\n        ctx.restore();\n    }\n\n    drawWalls(ctx,w,h){\n        let offset = 6\n        ctx.beginPath\n        ctx.moveTo(-offset, -offset)\n        ctx.lineTo(w + offset, -offset);\n        ctx.lineTo(w + offset, h + offset); //3\n        ctx.lineTo(0 - offset, h + offset);\n        ctx.closePath();\n        ctx.stroke();\n    }\n}\nmodule.exports = WallsSprite","const GameObject = require(\"../../../game_engine/game_object\")\nconst Util = require(\"../../../game_engine/util\");\nconst Sound = require(\"../../../game_engine/sound\")\n\nconst EnemySpawn = require(\"../../particles/enemy_spawn\")\nconst ArrowSprite = require(\"./arrow_sprite\")\n \nclass Arrow extends GameObject {\n  constructor(engine, pos, angle = Math.PI / 3) {\n    super(engine)\n    this.transform.pos = pos;\n    this.transform.angle = angle;\n    this.speed = 3;\n    this.points = 50\n    this.transform.vel = Util.vectorCartisian(this.transform.angle, this.speed);\n    this.radius = 6\n    this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_purple.wav\", 0.5);\n    this.playSound(this.spawnSound)\n    this.addLineSprite(new ArrowSprite(this.transform))\n    this.addChildGameObject(new EnemySpawn(this.gameEngine))\n    this.exists = false\n  }\n  \n  exist(){\n    // leaving off subscriptions means that things will subscribe to it\n    this.addCollider(\"General\", this, this.radius)\n    // now it will move\n    this.addPhysicsComponent()\n    this.exists = true\n  }\n\n  update(delta) {\n      // ADD TO UPDATE FOR THE OBJECTS\n    let pos = this.transform.absolutePosition()\n    if (this.gameEngine.gameScript.isOutOfBounds(pos)) {\n      this.gameEngine.gameScript.redirect(this.transform)\n    }\n  }\n}\n\nmodule.exports = Arrow;","const LineSprite = require(\"../../../game_engine/line_sprite\")\nclass ArrowSprite extends LineSprite {\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n  }\n\n  draw(ctx) {\n    let pos = this.transform.absolutePosition();\n    let spawningScale = this.spawningScale || 1;\n    let shipLength = 8 * 2.2 * spawningScale;\n    let shipWidth = 6 * 2.2 * spawningScale;\n    let l = shipLength;\n    let w = shipWidth;\n    let movementDirection = Math.atan2(this.transform.vel[0], -this.transform.vel[1])\n    \n    let r = 255;\n    let g = 255;\n    let b = 50;\n\n    ctx.save();\n    ctx.beginPath();\n    ctx.translate(pos[0], pos[1]);\n    ctx.rotate(movementDirection + 2 * Math.PI);\n\n    // ctx.strokeStyle = \"#f2ff00\"; // look up rgb and put here\n    ctx.lineWidth = 2;\n\n    let blurFactor = 0.5\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    ctx.shadowBlur = 10 * blurFactor;\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    ctx.lineWidth = 7.5 * blurFactor;\n    this.drawArrow(ctx, l, w);\n    ctx.lineWidth = 6 * blurFactor;\n    this.drawArrow(ctx, l, w);\n    ctx.lineWidth = 4.5;\n    this.drawArrow(ctx, l, w);\n    ctx.lineWidth = 3;\n    this.drawArrow(ctx, l, w);\n    ctx.strokeStyle = 'rgb(255, 255, 255)';\n    ctx.lineWidth = 1.5;\n    this.drawArrow(ctx, l, w);\n\n    ctx.restore();\n  }\n\n  drawArrow(ctx, l, w) {\n    ctx.beginPath();\n    ctx.moveTo(0, -l / 2); //1\n    ctx.lineTo(w / 2, l / 4); //2\n    ctx.lineTo(w / 6, l / 2); //3\n    ctx.lineTo(0, l / 4); //4\n    ctx.lineTo(-w / 6, l / 2); //5\n    ctx.lineTo(-w / 2, l / 4); //6\n    ctx.closePath();\n    ctx.stroke();\n  }\n}\n\nmodule.exports = ArrowSprite;","const GameObject = require(\"../../../game_engine/game_object\")\nconst Util = require(\"../../../game_engine/util\")\nconst Sound = require(\"../../../game_engine/sound\")\n\nconst EnemySpawn = require(\"../../particles/enemy_spawn\")\nconst BoxBoxSprite = require(\"./boxbox_sprite\")\n\nclass BoxBox extends GameObject {\n  constructor(engine, pos) {\n    super(engine)\n    this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_blue.wav\", 0.5);\n    this.transform.pos = pos\n    this.radius = 10\n    this.points = 20\n    // this.addPhysicsComponent()\n    this.addLineSprite(new BoxBoxSprite(this.transform))\n    this.addChildGameObject(new EnemySpawn(this.gameEngine))\n    this.playSound(this.spawnSound)\n  }\n\n  exist() {\n    // leaving off subscriptions means that things will subscribe to it\n    this.addCollider(\"General\", this, this.radius)\n    // now it will move\n    this.addPhysicsComponent()\n  }\n \n  wallGraze(){\n    this.gameEngine.gameScript.wallGraze(this.transform, this.radius)\n  }\n\n  update(delta){\n    if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius * 2)) {\n      this.wallGraze() \n    }\n  }\n}\n\nmodule.exports = BoxBox;","const LineSprite = require(\"../../../game_engine/line_sprite\")\nclass BoxBoxSprite extends LineSprite{\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n  }\n\n  draw(ctx) {\n\n    let spawningScale = this.spawningScale || 1;\n    let pos = this.transform.absolutePosition()\n    let boxSize = 10 * spawningScale;\n\n    // ctx.strokeStyle = \"#F173BA\";\n\n    let r = 210;\n    let g = 75;\n    let b = 75;\n    ctx.save();\n    ctx.beginPath();\n    ctx.translate(pos[0], pos[1]);\n    let blurFactor = 0.5\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    ctx.shadowBlur = 10 * blurFactor;\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    ctx.lineWidth = 7.5 * blurFactor\n    this.drawBox1(ctx, boxSize)\n    this.drawBox2(ctx, boxSize)\n    ctx.lineWidth = 6 * blurFactor;\n    this.drawBox1(ctx, boxSize)\n    this.drawBox2(ctx, boxSize)\n    ctx.lineWidth = 4.5;\n    this.drawBox1(ctx, boxSize)\n    this.drawBox2(ctx, boxSize)\n    ctx.lineWidth = 3;\n    this.drawBox1(ctx, boxSize)\n    this.drawBox2(ctx, boxSize)\n    ctx.strokeStyle = 'rgb(255, 255, 255)';\n    ctx.lineWidth = 1.5;\n    this.drawBox1(ctx, boxSize)\n    this.drawBox2(ctx, boxSize)\n    ctx.restore();\n  }\n\n  drawBox1(ctx, boxSize) {\n    let w = boxSize\n    let slideFactor = 1.125\n    ctx.beginPath();\n    ctx.moveTo(w  / 4, -w  / 4);\n    ctx.lineTo(w  / 4, (3 * w)  / 4);\n    ctx.lineTo((-3 * w ) / 4, (3 * w ) / 4);\n    ctx.lineTo((-3 * w ) / 4, -w  / 4)\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n  drawBox2(ctx, boxSize) {\n    let w = boxSize\n    let slideFactor = 1.5\n    ctx.beginPath();\n    ctx.moveTo(-w  / 4, w  / 4);\n    ctx.lineTo(-w  / 4, (-3 * w ) / 4);\n    ctx.lineTo((3 * w ) / 4, (-3 * w ) / 4);\n    ctx.lineTo((3 * w ) / 4, w  / 4)\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n\n\n}\n\nmodule.exports = BoxBoxSprite;","const GameObject = require(\"../../../game_engine/game_object\")\nconst Sound = require(\"../../../game_engine/sound\")\nconst Util = require(\"../../../game_engine/util\")\n\nconst EnemySpawn = require(\"../../particles/enemy_spawn\")\nconst GruntSprite = require(\"./grunt_sprite\")\n\nclass Grunt extends GameObject {\n  constructor(engine, pos, shipTransform) {\n    super(engine)\n    this.transform.pos = pos\n    this.exists = false;\n    this.stretchDirection = -1;\n    this.shipTransform = shipTransform\n    this.radius = 5;\n    this.points = 70\n    this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_blue.wav\", 0.5);\n    this.playSound(this.spawnSound)\n    this.addLineSprite(new GruntSprite(this.transform))\n    this.addChildGameObject(new EnemySpawn(this.gameEngine))\n  }\n\n  exist() {\n    this.exists = true;\n    // leaving off subscriptions means that things will subscribe to it\n    this.addCollider(\"General\", this, this.radius)\n    // now it will move\n    this.addPhysicsComponent()\n  }\n\n  // ADDING MOVEMENT MECHANICS FOR GRUNT\n\n  chase(timeDelta) {\n    let speed = 1.5\n    let shipPos = this.shipTransform.absolutePosition();\n    let pos = this.transform.absolutePosition()\n    let dy = shipPos[1] - pos[1];\n    let dx = shipPos[0] - pos[0];\n\n    const velocityScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n    let direction = Math.atan2(dy, dx);\n\n    pos[0] += speed * Math.cos(direction) * velocityScale\n    pos[1] += speed * Math.sin(direction) * velocityScale\n  }\n\n  update(timeDelta) {\n    if (this.exists) {\n      this.chase(timeDelta)\n      let cycleSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n      let cycleSpeed = 0.01;\n      if (this.lineSprite.stretchScale_W < 0.7 || this.lineSprite.stretchScale_W > 1) {\n        this.stretchDirection *= -1\n      }\n\n      this.lineSprite.stretchScale_W = this.lineSprite.stretchScale_W + -this.stretchDirection * cycleSpeed * cycleSpeedScale;\n      this.lineSprite.stretchScale_L = this.lineSprite.stretchScale_L + this.stretchDirection * cycleSpeed * cycleSpeedScale;\n\n      if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\n        this.wallGraze()\n      }\n    }\n  }\n\n  wallGraze() {\n    this.gameEngine.gameScript.wallGraze(this.transform, this.radius)\n  }\n\n  \n}\n\nmodule.exports = Grunt;\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","const LineSprite = require(\"../../../game_engine/line_sprite\")\nclass GruntSprite extends LineSprite {\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n    this.stretchScale_L = 1\n    this.stretchScale_W = 0.7\n  }\n\n  draw(ctx) {\n    let pos = this.transform.absolutePosition();\n    \n    let spawningScale = this.spawningScale;\n    let shipLength = 10 * 2.2 * spawningScale * this.stretchScale_L;\n    let shipWidth = 10 * 2.2 * spawningScale * this.stretchScale_W;\n    let l = shipLength;\n    let w = shipWidth;\n\n    let r = 0;\n    let g = 57;\n    let b = 230;\n\n    ctx.save();\n    ctx.translate(pos[0], pos[1]);\n\n    let blurFactor = 0.5\n\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    ctx.shadowBlur = 10\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    ctx.lineWidth = 7.5 * blurFactor;\n    this.drawDiamond(ctx, l, w);\n    ctx.lineWidth = 6 // * blurFactor;\n    this.drawDiamond(ctx, l, w);\n    ctx.lineWidth = 4.5 // * blurFactor;\n    this.drawDiamond(ctx, l, w);\n    ctx.lineWidth = 3 // * blurFactor;\n    this.drawDiamond(ctx, l, w);\n    ctx.strokeStyle = 'rgb(255, 255, 255)';\n    ctx.lineWidth = 1.5 // * blurFactor;\n    this.drawDiamond(ctx, l, w);\n    \n    ctx.restore();\n  }\n\n  drawDiamond(ctx, l, w) {\n    ctx.beginPath();\n    ctx.moveTo(0, -l / 2); //1\n    ctx.lineTo(w / 2, 0); //2\n    ctx.lineTo(0, l / 2); //3\n    ctx.lineTo(-w / 2, -0); //4\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n\n\n\n}\n\nmodule.exports = GruntSprite;","const Sound = require(\"../../../game_engine/sound\")\nconst Util = require(\"../../../game_engine/util\")\nconst GameObject = require(\"../../../game_engine/game_object\")\n\nconst EnemySpawn = require(\"../../particles/enemy_spawn\")\nconst PinwheelSprite = require(\"./pinwheel_sprite\")\n\nclass Pinwheel extends GameObject {\n  constructor(engine, pos) {\n    super(engine)\n    this.rotation_speed = 0.05;\n    let speed = 1;\n    this.points = 20;\n    this.transform.pos = pos;\n    this.transform.vel = Util.randomVec(speed);\n    this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_blue.wav\", 0.5);\n    this.playSound(this.spawnSound)\n    this.addLineSprite(new PinwheelSprite(this.transform))\n    this.addChildGameObject(new EnemySpawn(this.gameEngine))\n    this.radius = 5;\n  }\n  \n  exist() {\n    // leaving off subscriptions means that things will subscribe to it\n    this.addCollider(\"General\", this, this.radius)\n    // now it will move\n    this.addPhysicsComponent()\n  }\n\n  update(deltaTime){\n    let rotationSpeedScale = deltaTime / NORMAL_FRAME_TIME_DELTA;\n    this.transform.angle = (this.transform.angle + this.rotation_speed * rotationSpeedScale) % (Math.PI * 2)\n    if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\n      this.gameEngine.gameScript.bounce(this.transform, this.radius) // HARD CODED\n    }\n  }\n\n}\n\n\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\nmodule.exports = Pinwheel;","const LineSprite = require(\"../../../game_engine/line_sprite\")\nclass PinwheelSprite extends LineSprite {\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n  }\n\n  draw(ctx) {\n    let spawningScale = this.spawningScale || 1\n    let pos = this.transform.absolutePosition()\n    let angle = this.transform.absoluteAngle()\n\n    let shipWidth = 12 * spawningScale\n    let s = shipWidth / 2\n\n    let r = 59;\n    let g = 10;\n    let b = 87;\n\n    ctx.save();\n    ctx.translate(pos[0], pos[1]);\n    ctx.rotate(angle);\n\n    let blurFactor = 0.5\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    ctx.shadowBlur = 10 * blurFactor * blurFactor\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    ctx.lineWidth = 7.5 * blurFactor * blurFactor\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    this.drawPinwheel(ctx, s)\n    ctx.lineWidth = 6 * blurFactor\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.6)\";\n    this.drawPinwheel(ctx, s)\n    ctx.lineWidth = 4.5;\n    this.drawPinwheel(ctx, s)\n    ctx.lineWidth = 3;\n    this.drawPinwheel(ctx, s)\n    ctx.strokeStyle = 'rgb(200, 100, 255)';\n    ctx.lineWidth = 1.5;\n    this.drawPinwheel(ctx, s)\n\n    // ctx.strokeStyle = \"#971adf\";\n    // ctx.lineWidth = 1.8;\n\n    ctx.restore();\n  }\n\n  drawPinwheel(ctx, s) {\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(0, 0); //1\n    ctx.lineTo(-s, -s); //2\n    ctx.lineTo(0, -s); //3\n    ctx.lineTo(0, 0); //1\n    ctx.lineTo(s, -s); //4\n    ctx.lineTo(s, 0); //5\n    ctx.lineTo(0, 0); //1\n    ctx.lineTo(s, s); //6\n    ctx.lineTo(0, s); //7\n    ctx.lineTo(0, 0); //1\n    ctx.lineTo(-s, s); //8\n    ctx.lineTo(-s, 0); //9\n    // ctx.lineTo(); //1\n\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n\n\n\n}\n\nmodule.exports = PinwheelSprite;","const GameObject = require(\"../../../game_engine/game_object\")\nconst Sound = require(\"../../../game_engine/sound\")\nconst Util = require(\"../../../game_engine/util\")\n\nconst AlienShipSprite = require(\"./alien_ship_sprite\")\n\nclass AlienShip extends GameObject {\n    constructor(engine, pos, velocity, shipTransform) {\n        super(engine)\n        this.transform.pos[0] = pos[0]\n        this.transform.pos[1] = pos[1]\n        this.transform.vel[0] = velocity[0]\n        this.transform.vel[1] = velocity[1]\n\n        this.shipTransform = shipTransform\n        this.radius = 4;\n        this.points = 120\n        this.chaseSpeed = 3.5;\n        this.chaseAcceleration = 0.125 / 3\n        this.addLineSprite(new AlienShipSprite(this.transform))\n        this.addCollider(\"General\", this, this.radius)\n        this.addPhysicsComponent()\n    }\n\n    // change to acceleration\n   \n\n    update(timeDelta) {\n        // console.log(this.transform.pos)\n        this.chase()\n\n        if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\n            this.bounce()\n        }\n    }\n\n    bounce() {\n        this.gameEngine.gameScript.bounce(this.transform, this.radius)\n    }\n\n    chase() {\n        // take current velocity\n        // find ideal velocity using max speed, current position, and ship position\n        // get unit vector of current position - ship position\n        // take difference\n        // apply acceleration in that direction\n\n        // get dV\n        //    mV => max speed in the direction it should be moving\n        //    Vo => current velocity\n        //    dV =  mV - Vo\n        //    alpha = dV angle\n\n        let speed = this.chaseSpeed;\n\n        let shipPos = this.shipTransform.absolutePosition();\n        let pos = this.transform.absolutePosition()\n        let deltaPosition = [shipPos[0] - pos[0], shipPos[1] - pos[1]]\n        let chaseDirection = Math.atan2(deltaPosition[1], deltaPosition[0])\n\n        // Math.atan2 was giving me negative numbers.... when it shouldn't\n        if (chaseDirection < 0) {\n            chaseDirection = 2 * Math.PI + chaseDirection\n        }\n        // console.log(chaseDirection / (2 * Math.PI) * 360)\n        let Vm = [speed * Math.cos(chaseDirection), speed * Math.sin(chaseDirection)]\n        let Vo = this.transform.vel\n\n        let dV = [Vm[0] - Vo[0], Vm[1] - Vo[1]]\n        let accelerationDirection = Math.atan2(dV[1], dV[0])\n        this.transform.acc[0] += this.chaseAcceleration * Math.cos(accelerationDirection)\n        this.transform.acc[1] += this.chaseAcceleration * Math.sin(accelerationDirection)\n        // console.log(this.transform.acc)\n    }\n\n}\n\nmodule.exports = AlienShip;\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","const LineSprite = require(\"../../../game_engine/line_sprite\")\n\nclass AlienShipSprite extends LineSprite {\n    constructor(transform) {\n        super(transform)\n        this.radius = 4;\n    }\n\n    draw(ctx) {\n        ctx.strokeStyle = 'rgb(255, 255, 255)'\n        let r = 180;\n        let g = 180;\n        let b = 255;\n\n        ctx.save();\n\n        // ctx.strokeStyle = \"#4286f4\";\n        // ctx.lineWidth = 4;\n        let blurFactor = 0.5\n\n        ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n        ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n        ctx.lineWidth = 4;\n        this.drawAlienShip(ctx, this.radius);\n        ctx.lineWidth = 3\n        this.drawAlienShip(ctx, this.radius);\n        ctx.lineWidth = 2\n        this.drawAlienShip(ctx, this.radius);\n        ctx.lineWidth = 1\n        this.drawAlienShip(ctx, this.radius);\n        ctx.strokeStyle = 'rgb(255, 255, 255)';\n        ctx.lineWidth = 0.75\n        this.drawAlienShip(ctx, this.radius);\n        ctx.restore();\n    }\n\n    drawAlienShip(ctx, radius) {\n        ctx.beginPath();\n        let pos = this.transform.absolutePosition()\n        ctx.arc(pos[0], pos[1], radius, 0, 2 * Math.PI, true);\n        ctx.stroke();\n    }\n}\n\nmodule.exports = AlienShipSprite","const GameObject = require(\"../../../game_engine/game_object\")\nconst Sound = require(\"../../../game_engine/sound\")\nconst Util = require(\"../../../game_engine/util\")\n\nconst ParticleExplosion = require(\"../../particles/particle_explosion\")\nconst SingularityHitExplosion = require(\"../../particles/singularity_hit_explosion\")\n\nconst EnemySpawn = require(\"../../particles/enemy_spawn\")\nconst SingularitySprite = require(\"./singularity_sprite\")\nconst SingularityParticles = require(\"../../particles/singularity_particles\")\nconst AlienShip = require(\"./alien_ship\")\nclass Singularity extends GameObject {\n  constructor(engine, pos) {\n    super(engine)\n    this.transform.pos = pos;\n    this.gravityWellSize = 500;\n    this.gravityConstant = 1000 * 0.5;\n    this.radius = 15\n    this.points = 100\n    this.throbbingCycleSpeed = 0.025\n    this.numberAbsorbed = 0;\n    this.alienSpawnAmount = 10;\n    this.alienSpawnSpeed = 1.5;\n    this.deathSound = new Sound(\"GEOWars/sounds/Gravity_well_die.wav\")\n    this.gravityWellHitSound = new Sound(\"GEOWars/sounds/Gravity_well_hit.wav\", 0.5)\n    this.openGateSound = new Sound(\"GEOWars/sounds/Gravity_well_explode.wav\")\n    // this.id = options.id\n    this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_red.wav\", 1);\n    this.playSound(this.spawnSound)\n\n    this.increasing = true\n    this.addLineSprite(new SingularitySprite(this.transform))\n    this.addChildGameObject(new EnemySpawn(this.gameEngine))\n    this.lineSprite.throbbingScale = 1\n    this.lives = 5\n  }\n\n  exist() {\n    // leaving off subscriptions means that things will subscribe to it\n    this.addCollider(\"General\", this, this.radius)\n    this.addCollider(\"GravityWell\", this, this.gravityWellSize, [\"Grunt\", \"Pinwheel\", \"Bullet\", \"Ship\", \"BoxBox\", \"Arrow\", \"Singularity\", \"Weaver\", \"Particle\", \"SingularityParticle\", \"GridPoint\"],  [\"General\"])\n    this.addCollider(\"Absorb\", this, this.radius, [\"Grunt\", \"Pinwheel\", \"BoxBox\", \"Arrow\", \"Weaver\"],  [\"General\"])\n    // now it will move\n    this.addPhysicsComponent()\n    this.lineSprite.spawned = true\n    this.addChildGameObject(new SingularityParticles(this.gameEngine, this.transform))\n  }\n\n  onCollision(collider, type){\n    if (type === \"GravityWell\"){\n      this.influenceAcceleration(collider.gameObject)\n    } else if (type === \"Absorb\") {\n      let hitObjectTransform = collider.gameObject.transform\n      let pos = hitObjectTransform.absolutePosition()\n      let vel = hitObjectTransform.absoluteVelocity()\n      let explosion = new ParticleExplosion(this.gameEngine, pos, vel)\n      collider.gameObject.remove()\n\n      this.throbbingCycleSpeed *= 1.2\n      this.numberAbsorbed += 1\n    }\n  }\n\n  bulletHit(){\n    this.lives -= 1\n    let pos = this.transform.absolutePosition()\n    let vel = this.transform.absoluteVelocity()\n    if (this.lives <= 0) {\n      let explosion = new ParticleExplosion(this.gameEngine, pos, vel)\n      this.gameEngine.gameScript.tallyScore(this)\n      this.playSound(this.deathSound)\n      this.remove()\n    } else {\n      let explosion = new SingularityHitExplosion(this.gameEngine, pos, vel)\n      this.playSound(this.gravityWellHitSound)\n      this.throbbingCycleSpeed /= 1.2\n      this.numberAbsorbed -= 1\n    }\n  }\n\n  wallGraze() {\n    this.gameEngine.gameScript.wallGraze(this.transform, this.radius)\n  }\n  \n\n  update(deltaTime) {\n\n    if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\n      this.wallGraze()\n    }\n    if (this.numberAbsorbed === 3) {\n      this.soundAlarm(deltaTime)\n    }\n\n    this.throb(deltaTime)\n    if (this.numberAbsorbed >= 4) {\n      this.openGate()\n    }\n  }\n\n  soundAlarm(deltaTime){\n\n  }\n\n  throb(timeDelta) {\n\n    let cycleSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n    let cycleSpeed = this.throbbingCycleSpeed;\n    // increase scale until 1.2, decrease until 0.8\n\n    if (this.increasing) {\n      this.lineSprite.throbbingScale += cycleSpeed * cycleSpeedScale\n      if (this.lineSprite.throbbingScale > 1.2) {\n        this.increasing = !this.increasing\n      }\n    } else {\n      this.lineSprite.throbbingScale -= cycleSpeed * cycleSpeedScale\n      if (this.lineSprite.throbbingScale < 0.8) {\n        this.increasing = !this.increasing\n      }\n    }\n  }\n\n  influenceAcceleration(object) {\n    let pos = this.transform.absolutePosition()\n    let objectPos = object.transform.absolutePosition()\n    let dy = pos[1] - objectPos[1];\n    let dx = pos[0] - objectPos[0];\n    let unitVector = Util.dir([dx, dy]);\n    let r = Math.sqrt(dy * dy + dx * dx);\n    if (r > this.gravityWellSize * 7 / 8 || r < this.radius * 2){\n      // object.transform.acc = [0,0];\n    } else {\n      let accContribution= [\n        unitVector[0] * this.gravityConstant / (r * r),\n        unitVector[1] * this.gravityConstant / (r * r)\n      ]\n      object.transform.acc[0] += accContribution[0];\n      object.transform.acc[1] += accContribution[1];\n    }\n  }\n\n  openGate(){\n    this.playSound(this.openGateSound)\n    for (let i = 0; i < this.alienSpawnAmount; i++) {\n      let angle = Math.random() * Math.PI * 2\n      let velocity = [this.alienSpawnSpeed * Math.cos(angle), this.alienSpawnSpeed * Math.sin(angle)]\n      new AlienShip(this.gameEngine, this.transform.pos, velocity, this.gameEngine.gameScript.ship.transform)\n    }\n    this.remove()\n\n  }\n\n}\n\nmodule.exports = Singularity;\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","const LineSprite = require(\"../../../game_engine/line_sprite\")\n\nclass SingularitySprite extends LineSprite {\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n    this.throbbingScale = 1\n    this.radius = 15;\n    this.spawned = false;\n  }\n\n  draw(ctx) {\n    let spawningScale = this.spawningScale\n    if (this.spawned) {\n      spawningScale = this.throbbingScale\n    }\n\n    ctx.strokeStyle = \"#F173BA\"\n\n    let r = 95;\n    let g = 45;\n    let b = 73;\n\n    ctx.save();\n    // ctx.translate(pos[0], pos[1]);\n\n    // ctx.strokeStyle = \"#4286f4\";\n    // ctx.lineWidth = 4;\n    let blurFactor = 0.5\n\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    ctx.lineWidth = 7.5;\n    this.drawSingularity(ctx, this.radius * spawningScale);\n    ctx.lineWidth = 6\n    this.drawSingularity(ctx, this.radius * spawningScale);\n    ctx.lineWidth = 4.5\n    this.drawSingularity(ctx, this.radius * spawningScale);\n    ctx.lineWidth = 3\n    this.drawSingularity(ctx, this.radius * spawningScale);\n    ctx.strokeStyle = 'rgb(255, 255, 255)';\n    ctx.lineWidth = 1.5\n    this.drawSingularity(ctx, this.radius * spawningScale);\n    ctx.restore();\n    // ctx.lineWidth = 2;\n    // drawSingularity(ctx, this.radius * spawningScale);\n  }\n\n  drawSingularity(ctx, radius) {\n    ctx.beginPath();\n    let pos = this.transform.absolutePosition()\n    ctx.arc(pos[0], pos[1], radius, 0, 2 * Math.PI, true);\n    ctx.stroke();\n  }\n}\n\nmodule.exports = SingularitySprite","const GameObject = require(\"../../../game_engine/game_object\")\nconst Sound = require(\"../../../game_engine/sound\")\nconst Util = require(\"../../../game_engine/util\")\n\nconst EnemySpawn = require(\"../../particles/enemy_spawn\")\nconst WeaverSprite = require(\"./weaver_sprite\")\n\nclass Weaver extends GameObject {\n  constructor(engine, pos, shipTransform) {\n    super(engine)\n    this.rotation_speed = 0.075;\n    this.transform.pos[0] = pos[0]\n    this.transform.pos[1] = pos[1]\n    this.speed = 3;\n    this.points = 80;\n    this.radius = 5;\n    this.weaverCloseHitBox = 20;\n    this.shipTransform = shipTransform\n    this.directionInfluenced = false;\n    this.influencers = [];\n    this.spawnSound = new Sound(\"GEOWars/sounds/Enemy_spawn_green.wav\", 0.5);\n    this.playSound(this.spawnSound)\n    this.addLineSprite(new WeaverSprite(this.transform))\n    this.addChildGameObject(new EnemySpawn(this.gameEngine))\n    this.exists = false;\n    \n  }\n\n  exist() {\n    // leaving off subscriptions means that things will subscribe to it\n    this.addCollider(\"General\", this, this.radius)\n    this.addCollider(\"BulletDodge\", this, this.weaverCloseHitBox, [\"Bullet\"], [\"General\"])\n    // now it will move\n    this.addPhysicsComponent()\n    this.exists = true;\n  }\n\n  onCollision(collider, type){\n    if (type === \"BulletDodge\") {\n      this.acceptBulletDirection(collider.gameObject.transform.pos)\n    }\n  }\n\n  influenceDirection() {\n    let directionVector = [0, 0]\n\n    this.influencers.forEach((influencer) => {\n      let dx = directionVector[0] + influencer[0];\n      let dy = directionVector[1] + influencer[1];\n      let newVector = [dx, dy]\n      directionVector = Util.dir(newVector);\n    })\n    let influencedDirection = Math.atan2(directionVector[1], directionVector[0]);\n    return influencedDirection\n  }\n\n  acceptBulletDirection(source) {\n    this.directionInfluenced = true;\n    let dy = this.transform.pos[1] - source[1];\n    let dx = this.transform.pos[0] - source[0];\n    let unitVector = Util.dir([dx, dy]);\n    this.influencers.push(unitVector)\n    // first \n  }\n\n  update(timeDelta){\n    if(this.exists){\n      let speed = this.speed\n      const rotationSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n      const velocityScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n      this.transform.angle = (this.transform.angle + this.rotation_speed * rotationSpeedScale) % (Math.PI * 2)\n      \n      if (!this.directionInfluenced) {\n        this.chase(timeDelta)\n      } else {\n        let direction = this.influenceDirection();\n        this.transform.pos[0] += speed * Math.cos(direction) * velocityScale\n        this.transform.pos[1] += speed * Math.sin(direction) * velocityScale\n      }\n  \n      this.directionInfluenced = false;\n  \n      if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), this.radius)) {\n        this.wallGraze()\n      }\n    }\n    \n  }\n\n  wallGraze() {\n    this.gameEngine.gameScript.wallGraze(this.transform, this.radius)\n  }\n\n  chase(timeDelta) {\n    let speed = 2\n    let shipPos = this.shipTransform.pos;\n    let dy = shipPos[1] - this.transform.pos[1];\n    let dx = shipPos[0] - this.transform.pos[0];\n\n    const velocityScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n    let direction = Math.atan2(dy, dx);\n\n    this.transform.pos[0] += speed * Math.cos(direction) * velocityScale\n    this.transform.pos[1] += speed * Math.sin(direction) * velocityScale\n  }\n\n}\n\nWeaver.BOX_SIZE = 10;\nWeaver.COLOR = \"#3cff0b\"\n\nmodule.exports = Weaver;\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;","const LineSprite = require(\"../../../game_engine/line_sprite\")\n\nclass WeaverSprite extends LineSprite {\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n  }\n\n  draw(ctx) {\n    // drawing this guy is taking waaay too much time.\n    // I took out the blurr factor and it's way better.\n    // doesn't look as nice, but it's a starting point\n    let pos = this.transform.absolutePosition();\n    let angle = this.transform.absoluteAngle();\n    let spawningScale = this.spawningScale\n    let shipLength = 10 * 2.2 * spawningScale\n    let shipWidth = 10 * 2.2 * spawningScale\n    let s = shipWidth / 2;\n\n    let r = 24;\n    let g = 255;\n    let b = 4;\n\n    ctx.save();\n    ctx.translate(pos[0], pos[1]);\n    ctx.rotate(angle);\n    \n    let blurFactor = 0.5\n    ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n    // ctx.shadowBlur = 10 * blurFactor\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    ctx.lineWidth = 7.5\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.2)\";\n    this.drawWeaver(ctx, s)\n    ctx.lineWidth = 6\n    ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.6)\";\n    this.drawWeaver(ctx, s)\n    // ctx.lineWidth = 4.5;\n    // this.drawWeaver(ctx, s)\n    // ctx.lineWidth = 3;\n    // this.drawWeaver(ctx, s)\n    ctx.strokeStyle = 'rgb(255, 255, 255)';\n    ctx.lineWidth = 1.5;\n    this.drawWeaver(ctx, s)\n\n    ctx.restore();\n  }\n\n  drawWeaver(ctx, s) {\n\n    ctx.beginPath();\n    // ctx.strokeStyle = \"#3cff0b\";\n    ctx.lineWidth = 2;\n    ctx.moveTo(0, -s); //1\n    ctx.lineTo(s, 0); //2\n    ctx.lineTo(0, s); //3\n    ctx.lineTo(-s, 0); //4\n    ctx.lineTo(0, -s); //1\n    ctx.lineTo(-s / 2, -s / 2); //5\n    ctx.lineTo(s / 2, -s / 2); //6\n    ctx.lineTo(s / 2, s / 2); //7\n    ctx.lineTo(-s / 2, s / 2); //8\n    ctx.lineTo(-s / 2, -s / 2); //5\n    // ctx.closePath();\n    ctx.stroke();\n  }\n}\n\nmodule.exports = WeaverSprite","const Util = require(\"../../../game_engine/util\")\nconst GameObject = require(\"../../../game_engine/game_object\")\n\nconst GridSprite = require(\"./grid_sprite\")\nconst GridPoint = require(\"./grid_point\")\n\nclass Grid extends GameObject {\n    constructor(engine, gameScript) {\n        super(engine)\n\n        this.transform.pos = [0,0]\n\n        this.arenaDimensions = [gameScript.DIM_X, gameScript.DIM_Y]\n        this.elasticity = 0.1; // force provided to pull particle back into place\n        this.dampening = 0.1; // force produced from velocity (allows things to eventuall fall to rest)\n\n        this.gridPoints = this.createGridPoints()\n\n        this.addLineSprite(new GridSprite(this.transform, this.gridPoints))\n        // this.addPhysicsComponent()\n        // this.addCollider(\"General\", this, this.radius)\n    }\n\n    Playerdies(location) {\n        this.gridPoints.forEach((row) => {\n            row.forEach((gridPoint) => {\n                this.deathPerterb(gridPoint, location)\n            })\n        })\n    }\n\n    deathPerterb(gridPoint, location){\n        // pulls inward upon death. 1/r^2\n        const pullConstant = 1250;\n\n        let pos = location\n        let objectPos = gridPoint.transform.absolutePosition()\n        let dy = pos[1] - objectPos[1];\n        let dx = pos[0] - objectPos[0];\n        let unitVector = Util.dir([dx, dy]);\n        let r = Math.sqrt(dy * dy + dx * dx);\n        if ( r < 20 ) {\n        } else {\n            let velContribution = [\n                unitVector[0] * pullConstant / (r ),\n                unitVector[1] * pullConstant / (r )\n            ]\n            gridPoint.transform.vel[0] = velContribution[0];\n            gridPoint.transform.vel[1] = velContribution[1];\n        }\n    }\n\n    createGridPoints(){\n        let columnCount = 20\n        let rowCount = 12\n        let gridPoints = []\n        let gridRow = []\n        for (let yPosition = 0; yPosition <= this.arenaDimensions[1]; yPosition += this.arenaDimensions[1] / rowCount) {\n            for (let xPosition = 0; xPosition <= this.arenaDimensions[0]; xPosition += this.arenaDimensions[0] / columnCount) {\n                if(\n                   (xPosition === 0 && (yPosition === 0 || yPosition === this.arenaDimensions[1])) || \n                   (xPosition == this.arenaDimensions[0] && (yPosition === 0 || yPosition === this.arenaDimensions[1])) \n                   ){\n                    continue\n                }\n                let position = [xPosition, yPosition]\n                gridRow.push(new GridPoint(this.gameEngine, position))\n            }\n            \n            gridPoints.push(gridRow.slice())\n            gridRow = []\n        }\n        return gridPoints\n    }\n\n    update(deltaTime) {\n\n    }\n\n}\n\nmodule.exports = Grid;","\nconst Util = require(\"../../../game_engine/util\")\nconst GameObject = require(\"../../../game_engine/game_object\")\n\nclass GridPoint extends GameObject {\n    constructor(engine, pos) {\n        super(engine)\n        this.origionalPosition = []\n        this.origionalPosition[0] = pos[0]\n        this.origionalPosition[1] = pos[1]\n        this.transform.pos = pos\n        this.radius = 2\n        this.elasticity = -0.0035; // force provided to pull particle back into place\n        this.dampening = -0.04; // force produced from velocity (allows things to eventuall fall to rest)\n\n        this.addPhysicsComponent()\n        this.addCollider(\"General\", this, this.radius)\n    }\n\n    update(deltaTime) {\n        this.transform.acc[0] += this.transform.vel[0] * this.dampening + (this.transform.pos[0] - this.origionalPosition[0]) * this.elasticity\n        this.transform.acc[1] += this.transform.vel[1] * this.dampening + (this.transform.pos[1] - this.origionalPosition[1]) * this.elasticity\n    }\n\n}\n\nmodule.exports = GridPoint;","const LineSprite = require(\"../../../game_engine/line_sprite\")\nconst Color = require(\"../../../game_engine/color\")\n\nclass GridSprite extends LineSprite {\n    constructor(transform, gridPoints) {\n        super(transform)\n        this.gridPoints = gridPoints\n\n        this.color = new Color({\n            \"hsla\": [202, 100, 70, 0.2]\n        });\n    }\n\n    draw(ctx) {\n        ctx.save();\n        ctx.strokeStyle = this.color.evaluateColor();\n        ctx.lineWidth = 3\n        this.drawRows(ctx)\n        this.drawColumns(ctx)\n        ctx.restore();\n    }\n\n    drawRows(ctx) {\n        let gridPoints = this.gridPoints\n\n        for (let i = 1; i < gridPoints.length - 1; i++) {\n            ctx.beginPath()\n            let firstPosition = gridPoints[i][0].transform.pos\n            ctx.moveTo(firstPosition[0], firstPosition[1])\n            for (let j = 1; j < gridPoints[i].length; j++) {\n                let nextPosition = gridPoints[i][j].transform.pos;\n                ctx.lineTo(nextPosition[0], nextPosition[1])\n            }\n\n            ctx.stroke()\n        }\n    }\n\n    drawColumns(ctx) {\n        let gridPoints = this.gridPoints\n        ctx.beginPath()\n\n        for (let j = 1; j < gridPoints[1].length - 1; j++) {\n            ctx.beginPath()\n            for (let i = 0; i < gridPoints.length; i++) {\n                let nextPosition = []\n                if( i === 0 || i === 0) {\n                    nextPosition = gridPoints[i][j - 1].transform.pos\n                    ctx.moveTo(nextPosition[0], nextPosition[1])\n                } else {\n                    if ( i === gridPoints.length - 1) {\n                        nextPosition = gridPoints[i][j - 1].transform.pos\n                    } else {\n                        nextPosition = gridPoints[i][j].transform.pos\n                    }\n                    ctx.lineTo(nextPosition[0], nextPosition[1])\n                }\n\n            }\n            ctx.stroke()\n        }\n    }\n}\nmodule.exports = GridSprite","// direction of the particle is the direction of the velocity vector\n// the direction of the \n// the particle dies when the hue reaches 0 \n\n// random movement angle created\n// initial speed (scale)\n// vel = Util.vectorCartisian(angle, scale)\n//\n// \n\n// because the particle is drawn the correct way now, \n// from position out, the particle's center is located \n// far from the center of the particle\nconst ParticleSprite = require(\"./particle_sprite\")\n\nconst Util = require(\"../../../game_engine/util\")\nconst GameObject = require(\"../../../game_engine/game_object\")\n\n\nclass Particle extends GameObject{\n  constructor(engine, pos, initialSpeed, color, wallHit) {\n    super(engine)\n\n    this.transform.pos[0] = pos[0]\n    this.transform.pos[1] = pos[1]\n    this.color = color\n    this.movementAngle = this.createMovementAngle(wallHit)\n    this.transform.vel = Util.vectorCartisian(this.movementAngle, initialSpeed)\n    this.radius = 3\n    this.explosionDeceleration = 0.1; // in the direction the particle is moving\n    this.transform.acc = [-this.explosionDeceleration * Math.cos(this.movementAngle), -this.explosionDeceleration * Math.sin(this.movementAngle)]\n    this.addLineSprite(new ParticleSprite(this.transform, this.color))\n    this.addPhysicsComponent()\n    \n    // this.addCollider(\"General\", this, this.radius)\n\n  }\n\n  createMovementAngle(wallHit) {\n    if (!wallHit){ \n      return (Math.random() * Math.PI * 2);\n    } else {\n      if (wallHit === \"BOTTOM\") {\n        return(Math.random() * Math.PI + Math.PI)\n      } else if (wallHit === \"RIGHT\") {\n        return (Math.random() * Math.PI + Math.PI / 2)\n      } else if (wallHit === \"TOP\") {\n        return (Math.random() * Math.PI)\n      } else if (wallHit === \"LEFT\") {\n        return (Math.random() * Math.PI + 3 * Math.PI / 2)\n      }\n    }\n  }\n  \n\n  update(deltaTime){\n    this.lineSprite.rectLength -= 0.1;\n    this.lineSprite.color.a -= 0.01;\n    if (this.lineSprite.hue < 0.06 || this.lineSprite.rectLength < 0.25 || ((Math.abs(this.transform.vel[0]) + Math.abs(this.transform.vel[1])) < 0.15)) {\n      \n      this.remove();\n    }\n    this.checkBounds()\n    // acc is influenced by singularities, then changed to usual acc\n    this.movementAngle = Math.atan2(this.transform.vel[1], this.transform.vel[0])\n    this.transform.acc = [-this.explosionDeceleration * Math.cos(this.movementAngle), -this.explosionDeceleration * Math.sin(this.movementAngle)]\n  }\n\n  checkBounds() {\n    if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), -0.5)) {\n      this.remove();\n    }\n  }\n\n}\n\nmodule.exports = Particle;","const LineSprite = require(\"../../../game_engine/line_sprite\")\n\nclass ParticleSprite extends LineSprite {\n  constructor(transform, color) {\n    super(transform)\n    this.rectLength = 15;\n    this.rectWidth = 2;\n    this.color = color\n  }\n\n  draw(ctx) {\n    let pos = this.transform.absolutePosition();\n    let vel = this.transform.absoluteVelocity();\n    let l = this.rectLength;\n    let w = this.rectWidth;\n    let movementDirection = Math.atan2(vel[0], -vel[1])\n\n    ctx.save();\n    ctx.translate(pos[0], pos[1]);\n    ctx.rotate(movementDirection - Math.PI);\n\n    ctx.beginPath();\n    ctx.strokeStyle = this.color.evaluateColor();\n    ctx.lineWidth = w;\n\n    ctx.moveTo(0, 0); //1\n    ctx.lineTo(0, l); //2\n\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n  }\n}\n\nmodule.exports = ParticleSprite;","const LineSprite = require(\"../../../game_engine/line_sprite\")\nconst ParticleSprite = require(\"../Particle/particle_sprite\")\n\nclass SingularityParticleSprite extends LineSprite {\n  constructor(transform, color) {\n    super(transform)\n    this.rectLength = 15;\n    this.rectWidth = 2;\n    this.color = color\n  }\n \n  draw(ctx) {\n    let pos = this.transform.absolutePosition();\n    let vel = this.transform.absoluteVelocity();\n    let l = this.rectLength;\n    let w = this.rectWidth;\n    let movementDirection = Math.atan2(vel[0], -vel[1])\n\n    ctx.save();\n    ctx.beginPath();\n    ctx.translate(pos[0], pos[1]);\n    ctx.rotate(movementDirection + 2 * Math.PI);\n\n    ctx.beginPath();\n    ctx.strokeStyle = this.color.evaluateColor();\n    ctx.lineWidth = w;\n\n    ctx.moveTo(0, 0); //1\n    ctx.lineTo(0, l); //2\n\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n  }\n}\n\nmodule.exports = SingularityParticleSprite;","// direction of the particle is the direction of the velocity vector\n// the direction of the \n// the particle dies when the hue reaches 0 \n\n// random movement angle created\n// initial speed (scale)\n// vel = Util.vectorCartisian(angle, scale)\n//\n// \nconst SingularityParticleSprite = require(\"./singulairty_particle_sprite\")\n\nconst Util = require(\"../../../game_engine/util\")\nconst GameObject = require(\"../../../game_engine/game_object\")\nconst Particle = require(\"../Particle/particle\")\n\nclass SingularityParticle extends Particle {\n  constructor(engine, pos, vel, color) {\n    super(engine, pos, 0, color)\n\n    this.transform.vel[0] = vel[0]\n    this.transform.vel[1] = vel[1]\n\n    this.color = color;\n    this.addCollider(\"General\", this, this.radius)\n    this.checkBounds()\n  }\n\n  update(deltaTime) {\n    \n    this.lineSprite.rectLength -= 0.25;\n    this.lineSprite.color.a -= 0.01;\n    if (this.lineSprite.color.a < 0.06 || this.lineSprite.rectLength < 0.25) {\n      this.parentObject.currentParticleCount -= 1;\n      this.remove();\n    }\n    // acc is influenced by singularities, then changed to usual acc\n    this.movementAngle = Math.atan2(this.transform.vel[1], this.transform.vel[0])\n    this.transform.acc = [0,0]\n    this.checkBounds()\n  }\n  checkBounds() {\n    if (this.gameEngine.gameScript.isOutOfBounds(this.transform.absolutePosition(), -0.5)) {\n      this.remove();\n    }\n  }\n\n}\n\nmodule.exports = SingularityParticle;","const Particle = require(\"./Particle/particle\")\nconst GameObject = require(\"../../game_engine/game_object\")\nconst Sound = require(\"../../game_engine/sound\")\nconst Color = require(\"../../game_engine/color\")\nclass BulletWallExplosion extends GameObject{\n  constructor(engine, pos) {\n    super(engine)\n    this.transform.pos[0] = pos[0]\n    this.transform.pos[1] = pos[1]\n    let startingH = (this.gameEngine.gameScript.explosionColorWheel + 180 + Math.random() * 60) % 360\n    let opacity = Math.random() * 0.35 + 0.6\n    this.currentColor = new Color({\n      \"hsla\": [startingH, 100, 50, opacity]\n    });\n    this.particleNum = 20;\n    let bulletWallHit = new Sound(\"GEOWars/sounds/bullet_hitwall.wav\", 0.1)\n    this.wallHit = this.whichWall()\n    this.playSound(bulletWallHit)\n    this.createParticles()\n  }\n\n  whichWall() {\n    let pos = this.transform.pos\n\n    let max = [this.gameEngine.gameScript.DIM_X, this.gameEngine.gameScript.DIM_Y]\n    if (pos[0] <= 0) {\n      return \"LEFT\"\n    } else if (pos[0] >= max[0]) {\n      return \"RIGHT\"\n    } else if (pos[1] <= 0) {\n      return \"TOP\"\n    } else if (pos[1] >= max[1]) {\n      return \"BOTTOM\"\n    }\n\n  }\n\n  createParticles(){\n    for (var i = 0; i < this.particleNum; i++) {\n      const colorVarienceDelta = 30\n      const speed = 1 + Math.random() * 3\n      let colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2\n      let color = this.currentColor.dup()\n      color.a = Math.random() * 0.35 + 0.6\n      color.h = (color.h + colorVarience) % 360\n      \n      this.addChildGameObject(new Particle(this.gameEngine, this.transform.absolutePosition(), speed, color, this.wallHit));\n    }\n  }\n\n  update() {\n    \n    if (this.childObjects.length === 0) {\n      this.remove()\n    }\n  }\n}\n\nmodule.exports = BulletWallExplosion","const GameObject = require(\"../../game_engine/game_object\")\n\nclass EnemySpawn extends GameObject{\n  constructor(engine){\n    super(engine)\n    this.initialSpawningScale = 1.5;\n    // this.spawningScale = 1.5;\n    this.lifeTime = 1000;\n    this.existTime = 0;\n    // this.gameEngine.queueSound(this.parentObject.spawnSound)\n  }\n\n  update(timeDelta) {\n    this.existTime += timeDelta;\n    if (this.existTime >= this.lifeTime){\n      \n      this.parentObject.exist()\n      this.parentObject.lineSprite.spawningScale = 1;\n      this.remove()\n    }\n\n    let cycleSpeedScale = timeDelta / NORMAL_FRAME_TIME_DELTA;\n    let cycleSpeed = 0.1;\n    \n    if (this.parentObject.lineSprite.spawningScale < 0.7){\n      this.parentObject.lineSprite.spawningScale = this.initialSpawningScale;\n    } else {\n      this.parentObject.lineSprite.spawningScale -= cycleSpeed * cycleSpeedScale;\n    }\n  }\n}\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\nmodule.exports = EnemySpawn;","\nconst Particle = require(\"./Particle/particle\")\nconst GameObject = require(\"../../game_engine/game_object\")\nconst Sound = require(\"../../game_engine/sound\")\nconst Color = require(\"../../game_engine/color\")\nclass ParticleExplosion extends GameObject{\n  constructor(engine, pos){\n    super(engine)\n    this.transform.pos[0] = pos[0]\n    this.transform.pos[1] = pos[1]\n    let startingH = (this.gameEngine.gameScript.explosionColorWheel + Math.random() * 60)% 360\n    let opacity = Math.random() * 0.35 + 0.6\n    this.currentColor = new Color({\n      \"hsla\": [startingH, 100, 50, opacity]\n    });\n    if (engine.graphicQuality === 1) {\n      // console.log(\"best\")\n      this.particleNum = 80;\n    } else if (engine.graphicQuality === 2){\n      // console.log(\"medium\")\n      this.particleNum = 40\n    } else {\n      // console.log(\"potato\")\n      this.particleNum = 20\n    }\n\n    let explosionSound = new Sound(\"GEOWars/sounds/Enemy_explode.wav\", 0.2)\n    this.playSound(explosionSound)\n    this.createExplosionParticles()\n  }\n\n  createExplosionParticles(){\n    for (var i = 0; i < this.particleNum; i++) {\n      const speed = Math.random() * 3 + 4\n      \n      const colorVarienceDelta = 30\n      let colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2\n      let color = this.currentColor.dup()\n      color.a = Math.random() * 0.35 + 0.6\n      color.h = (color.h + colorVarience) % 360\n      \n      this.addChildGameObject(new Particle(this.gameEngine, this.transform.absolutePosition(), speed, color));\n    }\n  }\n\n  update(){\n    if (this.childObjects.length === 0){\n      this.remove()\n    }\n  }\n    // ANIMATION = requestAnimationFrame(drawScene);\n}\n\n\n\n\nmodule.exports = ParticleExplosion;","const Particle = require(\"./Particle/particle\")\nconst GameObject = require(\"../../game_engine/game_object\")\nconst Sound = require(\"../../game_engine/sound\")\nconst Color = require(\"../../game_engine/color\")\nclass ShipExplosion extends GameObject {\n    constructor(engine, pos) {\n        super(engine)\n        this.transform.pos[0] = pos[0]\n        this.transform.pos[1] = pos[1]\n        let startingH = (this.gameEngine.gameScript.explosionColorWheel + Math.random() * 60) % 360\n        let opacity = Math.random() * 0.35 + 0.6\n        this.currentColor = new Color({\n            \"hsla\": [startingH, 100, 50, opacity]\n        });\n        this.particleNum = 400;\n        let explosionSound = new Sound(\"GEOWars/sounds/Enemy_explode.wav\", 0.2)\n        this.playSound(explosionSound)\n        this.createExplosionParticles()\n    }\n\n    createExplosionParticles() {\n        for (var i = 0; i < this.particleNum; i++) {\n            const speed = Math.random() * 10 + 4\n\n            const colorVarienceDelta = 30\n            let colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2\n            let color = this.currentColor.dup()\n            // color.a = Math.random() * 0.35 + 0.6\n            // color.h = (color.h + colorVarience) % 360\n\n            this.addChildGameObject(new Particle(this.gameEngine, this.transform.absolutePosition(), speed, color));\n        }\n    }\n\n    update() {\n        if (this.childObjects.length === 0) {\n            this.remove()\n        }\n    }\n    // ANIMATION = requestAnimationFrame(drawScene);\n}\n\n\n\n\nmodule.exports = ShipExplosion;","const Particle = require(\"./Particle/particle\")\nconst GameObject = require(\"../../game_engine/game_object\")\nconst Sound = require(\"../../game_engine/sound\")\nconst Color = require(\"../../game_engine/color\")\nclass SingularityHitExplosion extends GameObject {\n    constructor(engine, pos) {\n        super(engine)\n        this.transform.pos[0] = pos[0]\n        this.transform.pos[1] = pos[1]\n        let startingH = (this.gameEngine.gameScript.explosionColorWheel + Math.random() * 60 + 180) % 360\n        let opacity = Math.random() * 0.35 + 0.3\n        this.currentColor = new Color({\n            \"hsla\": [startingH, 100, 50, opacity]\n        });\n        if (engine.graphicQuality === 1) {\n            // console.log(\"best\")\n            this.particleNum = 50;\n        } else if (engine.graphicQuality === 2) {\n            // console.log(\"medium\")\n            this.particleNum = 30\n        } else {\n            // console.log(\"potato\")\n            this.particleNum = 15\n        }\n        // find singularity hit sound\n        let explosionSound = new Sound(\"GEOWars/sounds/Enemy_explode.wav\", 0.2)\n        this.playSound(explosionSound)\n        this.createExplosionParticles()\n    }\n\n    createExplosionParticles() {\n        for (var i = 0; i < this.particleNum; i++) {\n            // adjust speed\n            const speed = Math.random() * 3 + 2.5\n\n            const colorVarienceDelta = 30\n            let colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2\n            let color = this.currentColor.dup()\n            color.a = Math.random() * 0.35 + 0.6\n            color.h = (color.h + colorVarience) % 360\n\n            this.addChildGameObject(new Particle(this.gameEngine, this.transform.absolutePosition(), speed, color));\n        }\n    }\n\n    update() {\n        if (this.childObjects.length === 0) {\n            this.remove()\n        }\n    }\n    // ANIMATION = requestAnimationFrame(drawScene);\n}\n\n\n\n\nmodule.exports = SingularityHitExplosion;","const GameObject = require(\"../../game_engine/game_object\")\nconst Util = require(\"../../game_engine/util\")\nconst SingularityParticle = require(\"./Singularity_Particle/singularity_particle\")\nconst Color = require(\"../../game_engine/color\")\n\nclass SingularityParticles extends GameObject {\n  constructor(engine, transform) {\n    super(engine)\n    this.transform = transform\n    let startingH = Math.random() * 360\n    let opacity = Math.random() * 0.35 + 0.6\n    this.frequencyParticleCreation = 10;\n    this.particleCreationTime = 0;\n    this.currentColor = new Color({\n      \"hsla\": [startingH, 100, 50, opacity]\n    });\n\n    this.particleNum = 80;\n    this.currentParticleCount = 0;\n    // let explosionSound = new Sound(\"GEOWars/sounds/Enemy_explode.wav\", 0.2)\n    this.createSingularityParticles()\n    \n  }\n\n  createSingularityParticles() {\n    \n    for (var i = 0; i < this.particleNum; i++) {\n      this.addSingularityParticle()\n      this.currentParticleCount++\n    }\n  }\n\n  addSingularityParticle(){\n    const L = 70\n    const length = 0\n    const baseSpeed = 3\n\n    const distanceVarienceDelta = 15\n    const colorVarienceDelta = 10\n    const angleVarienceDelta = Math.PI / 4\n    const speedVarienceDelta = 2\n\n    let distanceVarience = distanceVarienceDelta * Math.random() - distanceVarienceDelta / 2\n    let colorVarience = colorVarienceDelta * Math.random() - colorVarienceDelta / 2\n    let angleVarience = angleVarienceDelta * Math.random() - angleVarienceDelta / 2\n    let speedVarience = speedVarienceDelta * Math.random() - speedVarienceDelta / 2\n\n    let r = L + distanceVarience\n    let theta = Math.random() * 2 * Math.PI\n    let alpha = theta + Math.PI / 2 +  angleVarience\n    let speed = baseSpeed + speedVarience\n\n    let pos = [r * Math.cos(theta) + this.transform.pos[0], r * Math.sin(theta) + this.transform.pos[1]]\n    let vel = [speed * Math.cos(alpha) + this.transform.vel[0], speed * Math.sin(alpha) + this.transform.vel[1]]\n    let color = this.currentColor.dup()\n\n    color.a = Math.random() * 0.19 + 0.8\n    color.h = (color.h + colorVarience) % 360\n\n    this.addChildGameObject(new SingularityParticle(this.gameEngine, pos, vel, color));\n  }\n\n  changeCurrentColor(){\n    this.currentColor.h += 1 / 2\n    this.currentColor.h = this.currentColor.h % 360\n  }\n\n  update(timeDelta) {\n    this.particleCreationTime += timeDelta\n    if (this.particleCreationTime > this.frequencyParticleCreation){\n      this.particleCreationTime = 0\n      if (this.currentParticleCount < 60){\n        this.addSingularityParticle()\n      }\n    }\n    this.changeCurrentColor()\n  }\n  // ANIMATION = requestAnimationFrame(drawScene);\n}\n\n\n\n\nmodule.exports = SingularityParticles;","const GameObject = require(\"../../game_engine/game_object\");\nconst Util = require(\"../../game_engine/util\");\nconst Sound = require(\"../../game_engine/sound\");\n\n// const Camera = require(\"../Camera/camera\")\nconst Bullet = require(\"../Bullet/bullet\");\nconst ShipSprite = require(\"./ship_sprite\")\n\nclass Ship extends GameObject {\n  constructor(engine, pos, gameScript) { \n    super(engine);\n    this.transform.pos = pos\n    this.addPhysicsComponent()\n    this.addMousePosListener()\n    this.addLeftControlStickListener()\n    this.addRightControlStickListener()\n    this.addStartButtonListener()\n    this.radius = 10\n    this.addCollider(\"General\", this, this.radius)\n    this.addCollider(\"ShipDeath\", this, this.radius, [\"BoxBox\", \"Singularity\", \"Weaver\", \"Grunt\", \"Arrow\", \"Pinwheel\", \"AlienShip\"], [\"General\"])\n    this.addLineSprite(new ShipSprite(this.transform))\n    this.maxSpeed = 2.5;\n    this.mousePos = [0,0];\n    this.fireAngle = 0;\n    this.bulletSound = new Sound(\"GEOWars/sounds/Fire_normal.wav\", 0.2);\n    this.upgradeBulletsSound = new Sound(\"GEOWars/sounds/Hi_Score_achieved.wav\")\n    this.bulletTimeCheck = 0;\n    this.bulletInterval = 120;\n    this.controlsDirection = [0,0];\n    this.powerLevel = 1;\n    this.bulletNumber = 0;\n    this.controlsPointing = true;\n    this.speed\n    this.shipEngineAcceleration = 0.125;\n    this.dontShoot = false\n\n    this.keysPressed = []\n    this.pauseKeyedUp = true\n    this.zooming = true\n\n    this.spawning = true\n    this.spawningTime = 0;\n    this.flashingTime = 0;\n    this.flashTime = 1000 / 8\n    this.flashing = true;\n    this.flashIntervalTime = 0;\n    this.flashInterval = 250 - 1000 / 8\n    this.spawnTime = 2500\n    this.lineSprite.flashHide = true;\n    this.controllerInUse = false;\n    // 1/8 of a second flash every half second\n  }\n  \n  update(deltaTime){\n    this.bulletTimeCheck += deltaTime\n\n    if (this.bulletTimeCheck >= this.bulletInterval && !this.spawning && this.controlsPointing && !this.dontShoot) {\n      this.bulletNumber += 1;\n      this.bulletTimeCheck = 0;\n      this.fireBullet();\n    } \n\n    if (this.spawning){\n\n      this.spawningTime += deltaTime\n      if (this.flashing) {\n        this.flashingTime += deltaTime\n        if (this.flashingTime > this.flashTime) {\n          this.flashingTime = 0\n          this.flashing = false\n          this.lineSprite.flashHide = false\n        } \n      } else {\n        this.flashIntervalTime += deltaTime\n        if (this.flashIntervalTime > this.flashInterval) {\n          this.flashIntervalTime = 0\n          this.flashing = true\n          this.lineSprite.flashHide = true;\n        } \n      }\n\n      if (this.spawningTime > this.spawnTime) {\n        this.spawning = false\n        this.flashing = false\n        this.lineSprite.flashHide = false\n        this.spawningTime = 0;\n        this.flashIntervalTime = 0;\n        this.flashingTime = 0;\n      }\n      \n    }\n\n    // this.moveInControllerDirection(deltaTime)\n\n    if (this.isOutOfBounds()) {\n      this.wallGraze();\n    } else {\n      this.movementMechanics(deltaTime)\n      // ship camera stuffs\n      \n    }\n    // if ship is out of x bounds, maintain y speed, keep x at edge value\n\n    this.updateZoomScale()\n\n    this.gameEngine.ctx.restore()\n    this.gameEngine.ctx.save()\n    let shipXPos = this.transform.pos[0]\n    let shipYPos = this.transform.pos[1]\n    let zoomScale = this.gameEngine.zoomScale\n    let width = this.gameEngine.gameScript.DIM_X\n    let height = this.gameEngine.gameScript.DIM_Y\n\n    this.gameEngine.ctx.translate(\n      -shipXPos * zoomScale + width / 2,\n      -shipYPos * zoomScale + height / 2\n    )\n  }\n\n  upgradeBullets() {\n    if (this.powerLevel != 2) {\n      this.powerLevel = 2\n      this.playSound(this.upgradeBulletsSound)\n    }\n  }\n  \n  findSmallestDistanceToAWall(){\n    let pos = this.transform.pos\n    let leftDistance = pos[0] - 0\n    let rightDistance = this.gameEngine.gameScript.DIM_X - pos[0]\n    let upDistance = pos[1] - 0\n    let downDistance = this.gameEngine.gameScript.DIM_Y - pos[1]\n    let distances = [leftDistance, rightDistance, upDistance, downDistance]\n    return Math.min.apply(null, distances) \n  }\n\n  updateZoomScale(){\n    let distanceToZoomChange = 100\n    let smallestZoomScale = 0.75 // of the origional zoomscale\n    let smallest = this.findSmallestDistanceToAWall()\n    if (smallest < distanceToZoomChange) {\n      this.gameEngine.zoomScale = this.gameEngine.defaultZoomScale * (smallest / distanceToZoomChange * (1 - smallestZoomScale) + smallestZoomScale)\n    } else {\n      this.gameEngine.zoomScale = this.gameEngine.defaultZoomScale\n    }\n  }\n\n  // \n  calcControlsDirection(){\n    \n    this.controlsDirection = [0,0]\n    this.keysPressed.forEach((key) => {\n      this.controlsDirection[0] += Ship.MOVES[key][0]\n      this.controlsDirection[1] += Ship.MOVES[key][1]\n    })\n  }\n\n  movementMechanics(deltaTime) {\n    // get dV\n    //    mV => max speed in the direction of the controller\n    //    Vo => current velocity\n    //    dV~ =  mV - Vo\n    // if dv~ > 0.2 (or something)\n    //    a = ma~ \n    if (!this.controllerInUse) {\n      this.calcControlsDirection()\n    }\n\n    let movementAngle = Math.atan2(this.controlsDirection[1], this.controlsDirection[0])\n    let Vo = this.transform.absoluteVelocity()\n    let mV = []\n\n    if(this.controlsDirection[0] == 0 && this.controlsDirection[1] == 0){\n      mV = [0, 0]\n    } else {\n      mV = [this.maxSpeed * Math.cos(movementAngle), this.maxSpeed * Math.sin(movementAngle)]\n      this.transform.angle = movementAngle\n    }\n\n    let dV = [mV[0] - Vo[0], mV[1] - Vo[1]]\n    let alpha = Math.atan2(dV[1], dV[0])\n\n    this.transform.acc[0] += this.shipEngineAcceleration * Math.cos(alpha)\n    this.transform.acc[1] += this.shipEngineAcceleration * Math.sin(alpha)\n  }\n\n  isOutOfBounds(){\n    return this.gameEngine.gameScript.isOutOfBounds(this.transform.pos, this.radius)\n  }\n\n  updateMousePos(mousePos){\n    this.setFireAngle(mousePos)\n  }\n\n  updateRightControlStickInput(vector) {\n    if (Math.abs(vector[0]) + Math.abs(vector[1]) > 0.10) {\n      this.dontShoot = false\n      this.fireAngle = Math.atan2(vector[1], vector[0])\n    } else {\n      this.dontShoot = true\n    }\n  }\n\n  updateLeftControlStickInput(key, down = true) {\n    if(typeof key === \"string\"){\n      // accelerates to V = [0,0] when not pressed\n      if (down) {\n        if (!this.keysPressed.includes(key)) {\n          this.keysPressed.push(key)\n        }\n\n        // this.controlsDirection[0] += unitVector[0]\n        // this.controlsDirection[1] += unitVector[1]\n      } else {\n        if (this.keysPressed.includes(key)) {\n          this.keysPressed.splice(this.keysPressed.indexOf(key), 1)\n        }\n\n        // this.controlsDirection[0] -= unitVector[0]\n        // this.controlsDirection[1] -= initVector[1]\n      }\n    } else {\n      this.controllerInUse = true\n      if (Math.abs(key[0]) + Math.abs(key[1]) > 0.10) {\n        this.controlsDirection = key\n      } else {\n        this.controlsDirection = [0,0]\n      }\n    }\n  } \n // Refactor into game engine and game script\n  updateStartButtonListener(key, down){\n    if (typeof key === \"string\"){\n      if(down){\n        if(this.pauseKeyedUp){\n          this.pauseKeyedUp = false\n          if (this.gameEngine.paused && !this.gameEngine.muted) {\n            this.gameEngine.gameScript.theme.play()\n          }\n          this.gameEngine.togglePause()\n        }\n      } else {\n        this.pauseKeyedUp = true\n      }\n    } else if(key[0]) {\n      if (this.pauseKeyedUp){\n        this.pauseKeyedUp = false\n        if (this.gameEngine.paused && !this.gameEngine.muted) {\n          this.gameEngine.gameScript.theme.play()\n        }\n        this.gameEngine.togglePause()\n      }\n    } else {\n      this.pauseKeyedUp = true\n    }\n  }\n\n  wallGraze() {\n    this.gameEngine.gameScript.wallGraze(this.transform, this.radius * 2)\n  }\n\n  onCollision(collider, type) {\n    if (type === \"ShipDeath\") {\n  \n      this.gameEngine.gameScript.death()\n      this.deathflash()\n    }\n  }\n\n  deathflash() {\n    this.spawning = true;\n    this.flashing = true;\n  }\n\n  setFireAngle(mousePos) {\n    \n    if (mousePos === undefined){\n      mousePos = this.mousePos;\n    } else {\n      this.mousePos = mousePos\n    }\n    let shipXPos = this.transform.pos[0]\n    let shipYPos = this.transform.pos[1]\n    let zoomScale = this.gameEngine.zoomScale\n    let width = this.gameEngine.gameScript.DIM_X\n    let height = this.gameEngine.gameScript.DIM_Y\n\n    let mouseX = mousePos[0] / zoomScale + shipXPos  - width / (2 * zoomScale)\n    let mouseY = mousePos[1] / zoomScale + shipYPos  - height / (2 * zoomScale)\n    // SCALE NUMBER\n    let dy =  mouseY - this.transform.pos[1];\n    let dx =  mouseX - this.transform.pos[0];\n    this.fireAngle =  Math.atan2(dy, dx)\n  }\n\n  fireBullet() {\n    \n    this.gameEngine.queueSound(this.bulletSound)\n    let shipvx = this.transform.vel[0];\n    let shipvy = this.transform.vel[1];\n\n    let relBulletVelX1 = Bullet.SPEED * Math.cos(this.fireAngle);\n    let relBulletVelY1 = Bullet.SPEED * Math.sin(this.fireAngle);\n\n    const bulletVel1 = [shipvx + relBulletVelX1, shipvy + relBulletVelY1];\n    this.addChildGameObject(new Bullet(this.gameEngine, this.transform.pos, bulletVel1, this.bulletNumber))\n\n    if (this.powerLevel === 2) {\n\n      let relBulletVelX2 = (Bullet.SPEED - 0.5) * Math.cos(this.fireAngle + Math.PI / 32);\n      let relBulletVelY2 = (Bullet.SPEED - 0.5) * Math.sin(this.fireAngle + Math.PI / 32);\n      let relBulletVelX3 = (Bullet.SPEED - 0.5) * Math.cos(this.fireAngle - Math.PI / 32);\n      let relBulletVelY3 = (Bullet.SPEED - 0.5) * Math.sin(this.fireAngle - Math.PI / 32);\n\n      const bulletVel2 = [shipvx + relBulletVelX2, shipvy + relBulletVelY2];\n      const bulletVel3 = [shipvx + relBulletVelX3, shipvy + relBulletVelY3];\n      // doesn't support parent transformations... yet\n      this.addChildGameObject(new Bullet(this.gameEngine, this.transform.pos, bulletVel2))\n      this.addChildGameObject(new Bullet(this.gameEngine, this.transform.pos, bulletVel3))\n    }\n  }\n\n\n  // implement threshold so it's not too sensitive\n\n  \n\n  relocate() {\n    // this.GameScript.die();\n    // this.transform.pos = this.game.randomPosition();\n    // this.vel = [0, 0];\n    // this.acc = [0, 0];\n  }\n}\n\nmodule.exports = Ship;\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n\nShip.MOVES = {\n  s: [0, 1],\n  a: [-1, 0],\n  w: [0, -1],\n  d: [1, 0],\n}","const LineSprite = require(\"../../game_engine/line_sprite\")\n\nclass ShipSprite extends LineSprite {\n  constructor(transform, spawningScale = 1) {\n    super(transform)\n    this.spawningScale = spawningScale\n    this.flashHide = false\n  }\n\n  draw(ctx) {\n    if (this.flashHide) {\n      \n    } else {\n      let pos = this.transform.absolutePosition()\n      let shipWidth = 10\n      let vel = this.transform.absoluteVelocity()\n      // let movementDirection = Math.atan2(vel[0], -vel[1])\n      ctx.save();\n      ctx.beginPath();\n      ctx.translate(pos[0], pos[1]);\n      ctx.rotate(this.transform.angle + Math.PI / 4);\n      ctx.translate(-shipWidth / 2, shipWidth / 2);\n\n      ctx.strokeStyle = \"#ffffff\";\n      let r = 255;\n      let g = 255;\n      let b = 255;\n\n      let blurFactor = 0.5\n      ctx.shadowColor = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n      ctx.shadowBlur = 10 * blurFactor * blurFactor\n      ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.1)\";\n      ctx.lineWidth = 7.5 * blurFactor * blurFactor\n      ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.1)\";\n      this.drawShip(ctx, shipWidth)\n      ctx.lineWidth = 6 * blurFactor\n      ctx.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",0.1)\";\n      this.drawShip(ctx, shipWidth)\n      ctx.lineWidth = 4.5;\n      this.drawShip(ctx, shipWidth)\n      ctx.lineWidth = 3;\n      this.drawShip(ctx, shipWidth)\n      ctx.strokeStyle = 'rgb(255, 255, 255)';\n      ctx.lineWidth = 1.5;\n      this.drawShip(ctx, shipWidth)\n\n      ctx.restore();\n    }\n    \n  }\n\n  drawShip(ctx, shipWidth) {\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(0, -shipWidth);\n    ctx.lineTo(2 / 3 * shipWidth, -(1 + 1 / 6) * shipWidth); //1\n    ctx.lineTo(1 / 3 * shipWidth, -5 / 6 * shipWidth) // 2\n    ctx.lineTo(1 / 3 * shipWidth, -1 / 3 * shipWidth) // 2.5\n    ctx.lineTo(5 / 6 * shipWidth, -1 / 3 * shipWidth) // 3\n    ctx.lineTo((1 + 1 / 6) * shipWidth, -2 / 3 * shipWidth) // 4\n    ctx.lineTo(shipWidth, 0) // 5\n    ctx.closePath();\n    ctx.stroke();\n  }\n}\n\nmodule.exports = ShipSprite;","const Ship = require(\"./game_objects/ship/ship\");\nconst Walls = require(\"./game_objects/Walls/walls\")\nconst Overlay = require(\"./game_objects/Overlay/overlay\")\nconst Grid = require(\"./game_objects/particles/Grid/grid\")\nconst BoxBox = require(\"./game_objects/enemies/BoxBox/boxbox\");\nconst Pinwheel = require(\"./game_objects/enemies/Pinwheel/pinwheel\");\nconst Arrow = require(\"./game_objects/enemies/Arrow/arrow\");\nconst Grunt = require(\"./game_objects/enemies/Grunt/grunt\");\nconst Weaver = require(\"./game_objects/enemies/Weaver/weaver\");\nconst Singularity = require(\"./game_objects/enemies/Singularity/singularity\");\nconst AlienShip = require(\"./game_objects/enemies/Singularity/alien_ship\")\nconst ParticleExplosion = require(\"./game_objects/particles/particle_explosion\")\nconst ShipExplosion = require(\"./game_objects/particles/ship_explosion\")\n\nconst Util = require(\"./game_engine/util\");\nconst Sound = require(\"./game_engine/sound\")\nconst StateMachine = require(\"./game_engine/state_machine\")\n\nclass GameScript {\n  constructor(engine) {\n    this.theme = new Sound(\"GEOWars/sounds/Geometry_OST.mp3\", 1)\n    this.gameOverSound = new Sound(\"GEOWars/sounds/Game_over.wav\")\n    this.gameStartSound = new Sound(\"GEOWars/sounds/Game_start.wav\")\n    this.shipDeathSound = new Sound(\"GEOWars/sounds/Ship_explode.wav\")\n    this.DIM_X = 1000;\n    this.DIM_Y = 600;\n    this.BG_COLOR = \"#000000\";\n    this.gameTime = 0;\n    this.score = 0;\n    this.engine = engine\n    this.arrowAdded = false\n    this.startPosition = [500,300]\n    this.ship = this.createShip();\n    this.walls = this.createWalls();\n    this.grid = this.createGrid();\n    this.overlay = this.createOverlay();\n    this.enemyCreatorList = this.createEnemyCreatorList()\n    this.engine.addxButtonListener(this)\n    this.aliveEnemies = [];\n    this.sequenceTypes = this.addSequenceTypes()\n    this.spawnStateMachine = this.createSpawnStateMachine()\n    this.deathPausedTime = 0;\n    this.deathPaused = true;\n    this.deathPauseTime = 2500;\n    // this.deathSound = new Audio(\"GEOWars/sounds/Enemy_explode.wav\")\n    // this.deathSound.volume = 0.5;\n    \n    this.intervalTiming = 1;\n    this.intervalTime = 0;\n    this.hugeSequenceTime = 0;\n    this.sequenceCount = 0;\n    this.lives = 3;\n    this.soundsToPlay = {}\n    this.scoreMultiplier = 1\n\n    this.spawnthing = false;\n    this.explosionColorWheel = 0;\n  }\n\n  updatexButtonListener(xButton) {\n    if(xButton[0]){\n\n      if(this.engine.paused){\n        var modal = document.getElementById('endModal');\n\n        modal.style.display = \"none\";\n        this.engine.paused = false;\n        if (!this.engine.muted) {\n          this.engine.gameScript.theme.play()\n        }\n      }\n    }\n  }\n\n  update(deltaTime) {\n\n    this.spawnSequence(deltaTime)\n    this.changeExplosionColor()\n  }\n\n  changeExplosionColor() {\n    this.explosionColorWheel += 1 / 2\n    this.explosionColorWheel = this.explosionColorWheel % 360\n  }\n\n  tallyScore(gameObject) {\n    this.score += gameObject.points * this.scoreMultiplier\n    if (this.score){\n    }\n  }\n\n  resetGame() {\n    this.deathPaused = true\n    this.desplayEndScore = this.score\n    this.score = 0\n    this.lives = 3\n    this.ship.transform.pos = this.startPosition\n    this.sequenceCount = 0\n    this.deathPauseTime = 2500;\n    this.ship.powerLevel = 1;\n    this.intervalTiming = 1;\n    this.intervalTime = 0;\n    this.hugeSequenceTime = 0;\n    this.lives = 3;\n    this.scoreMultiplier = 1\n    this.spawnthing = false;\n    this.engine.paused = true;\n    var modal = document.getElementById('endModal');\n    modal.style.display = \"block\";\n    var scoreDisplay = document.getElementById('score');\n    scoreDisplay.innerHTML = `score: ${this.desplayEndScore}`;\n\n\n    // Get the button that opens the modal\n    // var btn = document.getElementById(\"myBtn\");\n\n    // Get the <span> element that closes the modal\n    var xclose = document.getElementsByClassName(\"endClose\")[0];\n\n    // When the user clicks on <span> (x), close the modal\n    xclose.onclick = (e) => {\n      e.stopPropagation()\n      modal.style.display = \"none\";\n      this.engine.paused = false;\n      window.removeEventListener('click', closeModalWithClick, false)\n      if (!this.engine.muted) {\n        this.engine.gameScript.theme.play()\n        this.engine.gameScript.gameStartSound.play()\n      }\n    }\n\n    let closeModalWithClick = (e) => {\n      if (event.target == modal) {\n        this.engine.paused = false;\n        if (!this.engine.muted) {\n          this.engine.gameScript.theme.play()\n          this.engine.gameScript.gameStartSound.play()\n        }\n        modal.style.display = \"none\";\n        window.removeEventListener('click', closeModalWithClick, false)\n      }\n    }\n\n    // When the user clicks anywhere outside of the modal, close it\n     window.addEventListener('click', closeModalWithClick, false)\n\n  }\n\n  death() { \n\n    this.lives -= 1\n    this.deathPaused = true\n    this.explodeEverything()\n    this.deathPauseTime = 4000;\n    if (!this.engine.muted) {\n      this.engine.gameScript.shipDeathSound.play()\n    }\n    this.grid.Playerdies(this.ship.transform.absolutePosition())\n    if(this.lives === 0){\n      try {\n        this.theme.pause()\n\n      } catch(err) {\n\n      }\n      if (!this.engine.muted) {\n        this.engine.gameScript.gameOverSound.play()\n      }\n      // this.playSoundthis.gameOverSound\n      window.setTimeout(this.resetGame.bind(this), 2000)\n    }\n\n  }\n\n  gameOver() {\n    // end the game here\n  }\n\n  explodeEverything(){\n    let removeList = []\n    let typesToRemove = [\"Grunt\", \"Pinwheel\", \"BoxBox\", \"Arrow\", \"Singularity\", \"Weaver\", \"AlienShip\"]\n    this.engine.gameObjects.forEach((object) => {\n      if (object.constructor.name === \"Ship\") {\n        let objectTransform = object.transform\n        let pos = objectTransform.absolutePosition()\n        let explosion = new ShipExplosion(this.engine, pos, [0,0])\n      } else if (object.constructor.name === \"Bullet\") {\n        removeList.push(object)\n      }\n      else if (typesToRemove.includes(object.constructor.name)) {\n        let objectTransform = object.transform\n        let pos = objectTransform.absolutePosition()\n        let vel = objectTransform.absoluteVelocity()\n        let explosion = new ParticleExplosion(this.engine, pos, vel)\n        removeList.push(object)\n      }\n    })\n    removeList.forEach((removeThis) => {\n      removeThis.remove()\n    })\n\n  }\n\n  onPause(){\n    try {\n      this.theme.pause()\n    } catch (error) {\n    }\n    \n    var modal = document.getElementById('pauseModal');\n    modal.style.display = \"block\";\n  }\n\n  onUnPause(){\n    try {\n      this.theme.unPause()\n    } catch (error) {}\n    \n    var modal = document.getElementById('pauseModal');\n    modal.style.display = \"none\";\n  }\n\n  randomArrowDirection() {\n    let angles = [0, Math.PI / 2, Math.PI, Math.PI * 3 / 2]\n    return angles[Math.floor(Math.random() * angles.length) % angles.length]\n  }\n\n  createEnemyCreatorList() {\n    let engine = this.engine \n    return {\n      BoxBox:      (pos)        => (new BoxBox(engine, pos)),\n      Pinwheel:    (pos)        => (new Pinwheel(engine, pos)),\n      Arrow:       (pos, angle) => (new Arrow(engine, pos, angle)),\n      Grunt:       (pos)        => (new Grunt(engine, pos, this.ship.transform)),\n      Weaver:      (pos)        => (new Weaver(engine, pos, this.ship.transform)),\n      Singularity: (pos)        => (new Singularity(engine, pos)),\n      AlienShip:   (pos)        => (new AlienShip(engine, pos, [0,0], this.ship.transform)),\n    };\n  }\n\n\n\n  randomSpawnEnemy(enemy) {\n    let pos = this.randomPosition();\n    let enemyCreators = Object.values(this.enemyCreatorList)\n    enemyCreators[Math.floor(Math.random() * enemyCreators.length) % enemyCreators.length](pos);\n    // this.enemyCreatorList[\"BoxBox\"](pos)\n  }\n\n  addSequenceTypes() {\n    return {\n      Singularity: () => {\n        this.enemyCreatorList[\"Singularity\"]([700, 300])\n      },\n      EasyGroups: () => {\n        let randomPositions = []\n        for (let i = 0; i < 5; i++) {\n          let pos = this.randomPosition();\n          randomPositions.push(pos)\n        }\n        randomPositions.forEach((pos) => {\n          let possibleSpawns = [\"BoxBox\", \"Pinwheel\"] //, \"Singularity\"]\n          this.enemyCreatorList[possibleSpawns[Math.floor(Math.random() * possibleSpawns.length) % possibleSpawns.length]](pos)\n        })\n      },\n      EasyGroupsArrows: () => {\n        let randomPositions = []\n        for (let i = 0; i < 5; i++) {\n          let pos = this.randomPosition();\n          randomPositions.push(pos)\n        }\n        randomPositions.forEach((pos) => {\n          let possibleSpawns = [\"BoxBox\", \"Pinwheel\", \"Arrow\", \"Singularity\"]\n          this.enemyCreatorList[possibleSpawns[Math.floor(Math.random() * possibleSpawns.length) % possibleSpawns.length]](pos)\n        })\n      },\n      ArrowsAttack: () => {\n        let somePositions = [[200,300], [1000, 300], [600, 100]]\n        let pos = somePositions[Math.floor(Math.random() * somePositions.length) % somePositions.length]\n        for (let i = 0; i < 5; i++) {\n          pos[1] += i * 80\n          this.enemyCreatorList[\"Arrow\"](pos)\n        }\n      },\n      GruntGroups: () => {\n        let randomPos = this.randomPosition();\n        for (let i = 0; i < 3; i++) {\n          for (let j = 0; j < 3; j++) {\n              this.enemyCreatorList[\"Grunt\"]([i * 40 + randomPos[0], j * 40 + randomPos[1]])\n          }\n        }\n      },\n      GreenGroups: () => {\n        let randomPos = this.randomPosition();\n        for (let i = 0; i < 3; i++) {\n          for (let j = 0; j < 3; j++) {\n            this.enemyCreatorList[\"Weaver\"]([i * 40 + randomPos[0], j * 40 + randomPos[1]])\n          }\n        }\n      }\n\n    }\n  }\n\n  createSpawnStateMachine(){\n    // let events = this.sequenceTypes \n    // let stateIndex = {i: 0}\n    // // these are the events\n    // // times will be hard coded for each state in the queue\n    // let spawnQueue = []\n    // let singularityState = new StateMachine(this.engine, {stateIndex, event: events.Singularity})\n    // let easyGroupsState = new StateMachine(this.engine, undefined)\n  }\n\n  randomPosition() {\n    return [\n      this.DIM_X * 0.70 * Math.random(),\n      this.DIM_Y * 0.70 * Math.random(),\n      // 500,300\n    ];\n  }\n\n  spawnSequence(delta) {\n\n    if (this.deathPaused) {\n      this.deathPausedTime += delta\n      if (this.deathPausedTime > this.deathPauseTime){\n        this.deathPausedTime = 0\n        this.deathPaused = false\n      }\n    } else {\n      this.intervalTime += delta;\n    }\n\n\n\n\n    this.testing = false\n    if (this.testing) {\n      if (this.sequenceCount === 0){\n        this.enemyCreatorList[\"AlienShip\"]([500,100])\n        this.sequenceCount += 1\n      }\n    } else {\n      \n    \n    this.gameTime += delta;\n    if(this.sequenceCount === 1) {\n      this.enemyCreatorList[\"Singularity\"]([700,300])\n      this.sequenceCount += 1\n    }\n                                   // wait time              //parentIndex   // repeat count\n    if (this.intervalTime > (2500 * this.intervalTiming) && this.sequenceCount < 5) {\n      this.intervalTime = 0;\n      this.sequenceTypes[\"EasyGroups\"]() // event\n      // this.randomSpawnEnemy();\n      this.sequenceCount += 1\n\n    } else if ( this.sequenceCount === 5 && this.intervalTime > 5000 ) {\n      this.sequenceCount += 1\n    } else if (this.intervalTime > (2500 * this.intervalTiming) && this.sequenceCount > 5 && this.sequenceCount < 10) {\n      this.sequenceCount += 1\n      this.intervalTime = 0;\n      this.sequenceTypes[\"EasyGroupsArrows\"]()\n    } else if (this.sequenceCount === 10 && this.intervalTime > 5000) {\n      this.sequenceCount += 1\n    } else if (this.intervalTime > (1500 * this.intervalTiming) && this.sequenceCount > 10 && this.sequenceCount < 15) {\n      this.sequenceCount += 1;\n      this.intervalTime = 0;\n      this.sequenceTypes[\"GruntGroups\"]()\n    } else if (this.sequenceCount === 15 && this.intervalTime > 2000) {\n      this.sequenceCount += 1\n    } else if (this.intervalTime > (2000 * this.intervalTiming) && this.sequenceCount > 15 && this.sequenceCount < 20) {\n      this.sequenceCount += 1;\n      this.intervalTime = 0;\n      this.sequenceTypes[\"GreenGroups\"]()\n    } else if (this.sequenceCount === 20 && this.intervalTime > 3000) {\n      this.sequenceCount += 1\n    } \n    // else if (this.intervalTime > (2500 * this.intervalTiming) && this.sequenceCount === 10 && this.hugeSequenceTime % 2 === 1) {\n    //   this.intervalTime = 0\n    //   this.sequenceCount += 1\n    //   let enemies_to_spawn = []\n    //   let randomPos = this.randomPosition();\n    //   for (let i = 0; i < 2; i++) {\n    //     for (let j = 0; j < 2; j++) {\n    //       this.enemyCreatorList[\"Weaver\"]([i * 40 + randomPos[0], j * 40 + randomPos[1]])\n    //     }\n    //   }\n\n    // } else if (this.intervalTime > (5000 * this.intervalTiming) && this.sequenceCount === 11) {\n    //   this.intervalTime = 0;\n    //   this.sequenceCount += 1;\n    //}\n    else if (this.intervalTime > 375 && this.sequenceCount > 20 && this.sequenceCount < 30 && this.hugeSequenceTime % 2 === 0) {\n        this.ship.upgradeBullets()\n        this.intervalTime = 0;\n        this.sequenceCount += 1;\n\n      let fourCorners = [\n        [40, 40],\n        [GameScript.DIM_X - 40, 40],\n        [40, GameScript.DIM_Y - 40],\n        [GameScript.DIM_X - 40, GameScript.DIM_Y - 40]\n      ]\n      fourCorners.forEach((corner) => {\n        this.enemyCreatorList[\"Grunt\"](corner)\n      })\n    } else if (this.intervalTime > 375 && this.sequenceCount > 20 && this.sequenceCount < 30 && this.hugeSequenceTime % 2 === 1) {\n      this.intervalTime = 0;\n      this.sequenceCount += 10;\n      let arrowWallPositions = []\n      let arrowDirection = Math.PI * 3 / 2 + Math.PI\n      for (let i = 40; i < GameScript.DIM_X; i += 40) {\n        arrowWallPositions.push([i, 50])\n      }\n\n      arrowWallPositions.forEach((position) => {\n        this.enemyCreatorList[\"Arrow\"](position, arrowDirection)\n      })\n\n    } \n              // this is the spawner event. \n              // it runs through all the child states\n              // for the event to be triggered\n    else if  (this.sequenceCount >= 30) {\n      this.sequenceCount = 0;\n      if (!(this.intervalTiming < 0.5)) {\n        this.intervalTiming *= 0.9;\n      }\n      this.hugeSequenceTime += 1;\n    }\n  \n    }\n\n\n\n\n    // if (this.gameTime % 2000 === 0){\n    //   this.spawned = false\n    // }\n  }\n\n  createShip() {\n    return new Ship(this.engine, this.startPosition)\n  }\n\n  createWalls(){\n    return new Walls(this.engine, this)\n  }\n  \n  createGrid(){\n    return new Grid(this.engine, this)\n  }\n\n  createOverlay(){\n    return new Overlay(this.engine, this, this.ship.transform)\n  }\n\n  isOutOfBounds(pos, radius) {\n    let max = [GameScript.DIM_X - radius, GameScript.DIM_Y - radius]\n    if (radius) {\n      return(\n        (pos[0] <= radius || pos[0] >= max[0]) || \n        (pos[1] <= radius || pos[1] >= max[1]) \n      )\n    } else {\n      return (pos[0] < 0) || (pos[1] < 0) ||\n        (pos[0] > GameScript.DIM_X) || (pos[1] > GameScript.DIM_Y);\n    }\n    \n  }\n\n  updateShipFireAngle() {\n    this.ships[0].setFireAngle()\n  }\n\n  // bounce(pos){\n  //   return [\n  //     Util.bounce(pos[0], GameScript.DIM_X), Util.bounce(pos[1], GameScript.DIM_Y)\n  //   ];\n  // }\n\n  bounce(transform, radius = 0) {\n    let max = [this.DIM_X - radius, this.DIM_Y - radius]\n    let pos = transform.absolutePosition()\n    if (pos[0] <= radius || pos[0] >= max[0]) {\n      transform.vel[0] = -transform.vel[0];\n    }\n    if (pos[1] <= radius || pos[1] >= max[1]) {\n      transform.vel[1] = -transform.vel[1];\n    }\n  }\n\n  wallGraze(transform, radius = 0){\n    let max = [this.DIM_X - radius, this.DIM_Y - radius]\n    let pos = transform.absolutePosition()\n    let vel = transform.absoluteVelocity()\n\n    // X bounds, left right\n    if (pos[0] <= radius && vel[0] < 0){\n      transform.vel[0] = 0.1;\n    } else if (pos[0] >= max[0] && vel[0] > 0){\n      transform.vel[0] = -0.1;\n    }\n\n    // Y bounds, top bottom\n    if(pos[1] <= radius && vel[1] < 0) {\n      transform.vel[1] = 0.1\n    } else if (pos[1] >= max[1] && vel[1] > 0){\n      transform.vel[1] = -0.1\n    }\n\n  }\n\n  redirect(transform) {\n    let max = [this.DIM_X, this.DIM_Y]\n    let pos = transform.absolutePosition()\n    \n    if (pos[0] <= 0 || pos[0] >= max[0]) {\n      if (pos[0] <= 0) {\n        pos[0] = 1\n\n        \n      }\n      if (pos[0] >= max[0]) {\n        pos[0] = max[0] - 1\n\n      }\n    }\n    if (pos[1] <= 0 || pos[1] >= max[1]) {\n      if (pos[1] <= 0) {\n        pos[1] = 1\n\n      }\n      if (pos[1] >= max[1]) {\n        pos[1] = max[1] - 1\n\n      }\n    }\n\n    transform.vel[0] = -transform.vel[0];\n    transform.vel[1] = -transform.vel[1];\n  }\n\n}\n\nGameScript.BG_COLOR = \"#000000\";\n\nGameScript.DIM_X = 1000;\nGameScript.DIM_Y = 600;\n// GameScript.FPS = 32;\n// GameScript.NUM_BOXES = 10;\n// GameScript.NUM_PINWHEELS = 0;\n// GameScript.NUM_ARROWS = 0;\n// GameScript.NUM_GRUNTS = 0;\n// GameScript.NUM_WEAVERS = 0;\n// GameScript.NUM_SINGULARITIES = 1;\nmodule.exports = GameScript;\n\nGameScript.Spawn1 = {\n  BoxBox: 50,\n}\n\nGameScript.spawnListList = [\n  GameScript.Spawn1\n]","class GameView {\n  constructor(engine, ctx, canvasEl) {\n    this.ctx = ctx; \n    this.engine = engine;\n    // this.ship = this.game.addShip(); belongs in game script\n    this.canvasEl = canvasEl;\n    this.initialUnmute = true;\n    this.gameStarted = false;\n    this.modelClosed = false;\n    this.bindKeyboardKeys = this.bindKeyboardKeys.bind(this)\n    this.animate = this.animate.bind(this)\n  }\n\n  bindKeyboardKeys(){\n    window.addEventListener('keydown', this.doKeyEvent(true), true);\n    window.addEventListener('keyup', this.doKeyEvent(false), true);\n  }\n\n  updateMovementDirection(move, down){\n    this.engine.gameScript.ship.updateLeftControlStickInput(move, down);\n  }\n\n  /*\n    if true, change movement direction to the direction\n    if false, remove movement direction if it's the \n    same as the current movement direction\n  */\n\n  doKeyEvent(down) {\n    return (e) => {\n      // if (e.key === \"p\"){\n      //   this.engine.togglePause()\n      // }\n      if (e.key === \"m\" && this.initialUnmute) {\n        this.initialUnmute = false\n        this.engine.gameScript.theme.play()\n      }\n\n      if(e.key === \"m\" && down){\n        this.engine.toggleMute()\n        if (this.engine.muted){\n          this.engine.gameScript.theme.mute()\n        } else{\n          this.engine.gameScript.theme.unmute()\n        }\n        \n      }\n\n      let unitVector = GameView.MOVES[e.key]\n      if (unitVector) {\n        this.updateMovementDirection(e.key, down)\n      }\n      if (e.key === \"p\") {\n        this.engine.updateStartButtonListeners(e.key, down)\n      }\n    }\n  }\n\n  bindKeyHandlers() {\n    const engine = this.engine\n    // Object.keys(GameView.MOVES).forEach((k) => {\n    //   const move = GameView.MOVES[k];\n    //   key(k, () => {\n    //     this.engine.gameScript.ship.updateLeftControlStickInput(move);\n    //   });\n    // });\n\n    // key(\"m\", () => {\n    //   engine.muted = !engine.muted;\n    //   if (engine.muted) {\n    //     this.theme.pause();\n    //   } else {\n    //     this.theme.play();\n    //   }\n    // })\n\n    window.addEventListener('mousemove', (e) => {\n      const x = {x: e.layerX};\n      const y = {y: e.layerY};\n      const mousePos = [e.layerX, e.layerY];\n      this.engine.updateMousePos(mousePos)\n      // ship.setFireAngle(mousePos); add to game script event listener thing\n    });\n\n    // function preventDefault(e) {\n    //   e = e || window.event;\n    //   if (e.preventDefault)\n    //     e.preventDefault();\n    //   e.returnValue = false;\n    // }\n\n\n    // function disableScroll() {\n    //   if (window.addEventListener) // older FF\n    //     window.addEventListener('DOMMouseScroll', preventDefault, false);\n    //   // window.onwheel = preventDefault; // modern standard\n    //   // window.onmousewheel = document.onmousewheel = preventDefault; // older browsers, IE\n    //   // window.ontouchmove = preventDefault; // mobile\n    //   // document.onkeydown = preventDefaultForScrollKeys;\n    // }\n\n   \n\n    \n\n\n    // if (window.addEventListener) // older FF\n    //   window.addEventListener('DOMMouseScroll', preventDefault, false);\n    // window.onwheel = preventDefault; // modern standard\n    // window.onmousewheel = document.onmousewheel = preventDefault; // older browsers, IE\n    // window.ontouchmove = preventDefault; // mobile\n   \n  }\n\n  end(){\n    var endModal = document.getElementById('endModal')\n  }\n\n  start() {\n    this.lastTime = 0;\n    this.bindKeyHandlers();\n\n     // Get the modal\n     var modal = document.getElementById('myModal');\n\n     // Get the button that opens the modal\n     // var btn = document.getElementById(\"myBtn\");\n\n     // Get the <span> element that closes the modal\n     var xclose = document.getElementsByClassName(\"close\")[0];\n\n     // When the user clicks on <span> (x), close the modal\n     xclose.onclick = (e) => {\n       e.stopPropagation()\n       modal.style.display = \"none\";\n       this.modelClosed = true\n     }\n\n     // When the user clicks anywhere outside of the modal, close it\n    //  window.addEventListener('click', (e) => {\n     window.onclick = (event) => {\n       if (this.modelClosed && !this.gameStarted) {\n         this.gameStarted = true\n         this.bindKeyboardKeys()\n         requestAnimationFrame(this.animate);\n       }\n       if (event.target == modal) {\n         this.modelClosed = true\n         modal.style.display = \"none\";\n       }\n     }\n  }\n  \n  animate(time) {\n    const timeDelta = time - this.lastTime;\n    this.engine.tick(timeDelta, this.ctx);\n    this.lastTime = time;\n    // every call to animate requests causes another call to animate\n    requestAnimationFrame(this.animate.bind(this));\n  }\n}\n\nconst KEYMAP = {\n  87: \"W\",\n  82: \"R\",\n  90: \"Z\",\n  88: \"X\",\n  67: \"C\",\n  70: \"F\",\n  83: \"S\",\n  69: \"E\",\n  65: \"D\",\n  68: \"A\",\n}\n\nGameView.MOVES = {\n  s: [0,1],\n  a: [-1,0],\n  w: [0,-1],\n  d: [1,0],\n}\n\nmodule.exports = GameView;\n"],"sourceRoot":""}